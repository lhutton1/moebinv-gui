%	$Id: figure.nw,v 1.40 2014/09/15 12:53:54 kisilv Exp $
%&biglatex

% -*- mode: Noweb; noweb-code-mode: c++-mode; tab-width: 4 -*--*-
\newif\ifshort
\makeatletter
\def\solutionfile{figure-short}\edef\solutionfile{\expandafter\strip@prefix\meaning\solutionfile}
\edef\JobName{\jobname}
\ifx\JobName\solutionfile
\shorttrue
\else
\shortfalse
\fi
\newif\ifelsevier
%\elseviertrue

\ifelsevier
\documentclass[twoside,a4paper,amsthm]{elsart}
\usepackage{yjsco}
\else
\documentclass[twoside,a4paper]{amsart}
\fi
\usepackage[pdfauthor={Vladimir V. Kisil},%
  pdftitle={An Extension of Moebius--Lie Geometry
    with Conformal Ensembles of Cycles
    and Its Implementation in a GiNaC Library},%
  pdfsubject={Lie geometry},%
  backref=page,%
  pagebackref=true, %
  pdfkeywords={GiNaC, cycle, CAS},%
  breaklinks=true,%
  bookmarks=true,%
]{hyperref}

\PassOptionsToPackage{british}{babel}
\ifshort
\providecommand{\nwfilename}[1]{}
\providecommand{\nwbegindocs}[1]{}
\providecommand{\nwenddocs}[1]{}
\providecommand{\nwdocspar}{}
\providecommand{\nwendquote}{}
\providecommand{\Tt}{\texttt}
\providecommand{\Rm}{\textrm}
\providecommand{\nwnewline}{}
\else
\usepackage{noweb}
\pagestyle{noweb}
%\nwfilename{figure.nw}
\makeatletter
\let\tab=&
\def\idxexample#1{\nwix@id@uses#1}
\fi
\usepackage{animate}

\def\publname{arXiv:
  \href{http://arXiv.org/abs/1512.02960}{\texttt{1512.02960}}, 2015}

\usepackage{listings}
\lstset
{ %Formatting for code in appendix
    language=Python,
    basicstyle=\footnotesize,
    numbers=left,
    stepnumber=1,
    showstringspaces=false,
    tabsize=1,
    breaklines=true,
    breakatwhitespace=false,
}

\ifelsevier
\noweboptions{scriptsizecode}
\providecommand{\email}[2]{\ead{#2}}
\providecommand{\urladdr}[1]{}
\providecommand{\subjclass}[2][2010]{\par\emph{AMS subject classification (#1)}: #2}
\usepackage{amsfonts,amsmath}
\usepackage[author-year,initials,nobysame,short-journals]{amsrefs}
\else
  \ifshort
  \else
  \textheight 26.5cm
  \textwidth 18cm
  \oddsidemargin -.9cm
  \evensidemargin -.9cm
  \topmargin -1.5cm
  \fi
  \renewcommand{\baselinestretch}{1}
  \newtheorem{thm}{Theorem}
  \theoremstyle{definition}
  \newtheorem{example}[thm]{Example}
  \newtheorem{defn}[thm]{Definition}
  \theoremstyle{remark}
  \newtheorem{rem}[thm]{Remark}
  \PII{\relax}
  \copyrightinfo{}{\relax}
  \newenvironment{frontmatter}{}{\maketitle}
  \usepackage[initials,nobysame,short-journals]{amsrefs}
\fi
%\RequirePackage[author-year,initials,backrefs,nobysame,short-journals]{amsrefs}\relax
%\RequirePackage{my_abbreviations}\relax
%\RequirePackage[author-year,initials,nobysame,short-journals]{amsrefs}\relax
% See amsref documentation for the meaning of the options

%% FORMAT OF THE REFERENCES :

%% One must define how editors and translators are identified. Three solution are available:
%%
%% - \PrintEditorsA: Foo and Bar (eds.)
%% - \PrintEditorsB: Foo and Bar eds.
%% - \PrintEditorsC: Edited by Foo and Bar
%%
%% - \PrintTranslatorsA: Foo and Bar (trans.)
%% - \PrintTranslatorsB: macin and Bar trans.
%% - \PrintTranslatorsC: Translated by Foo et Bar
\ifelsevier
\BibSpecAlias{incollection}{inproceedings}
\BibSpec{article}{%
    +{}  {\hspace*{-.5em}\PrintAuthors}                {author}
    +{,} { \PrintDateB}                 {date}
    +{.} { }                            {title}
    +{.} { }                            {part}
    +{:} { }                            {subtitle}
    +{.} { \PrintContributions}         {contribution}
    +{.} { \PrintPartials}              {partial}
    +{.} { \emph}                       {journal}
    +{,} { \textbf}                            {volume}
    +{}  { \parenthesize}               {number}
    +{:} {}                             {pages}
    +{,} { }                            {status}
    +{.} { \PrintTranslation}           {translation}
    +{.} { Reprinted in \PrintReprint}  {reprint}
    +{.} { }                            {note}
    +{.} {}                             {transition}
}

\BibSpec{partial}{%
    +{}  {\hspace*{-.5em}}                             {part}
    +{,} { \PrintDateB}                 {date}
    +{:} { }                            {subtitle}
    +{.} { \PrintContributions}         {contribution}
    +{.} { \emph}                       {journal}
    +{,} { \textbf}                            {volume}
    +{}  { \parenthesize}               {number}
    +{:} {}                             {pages}
}

\BibSpec{book}{%
    +{}  {\hspace*{-.5em}\PrintPrimary}                {transition}
    +{,} { \PrintDateB}                 {date}
    +{.} { \emph}                       {title}
    +{.} { }                            {part}
    +{:} { \emph}                       {subtitle}
    +{.} { }                            {series}
    +{,} { \voltext}                    {volume}
    +{.} { Edited by \PrintNameList}    {editor}
    +{.} { Translated by \PrintNameList}{translator}
    +{.} { \PrintContributions}         {contribution}
    +{.} { }                            {publisher}
    +{.} { }                            {organization}
    +{,} { }                            {address}
    +{,} { \PrintEdition}               {edition}
    +{.} { }                            {note}
    +{.} {}                             {transition}
    +{.} { \PrintTranslation}           {translation}
    +{.} { Reprinted in \PrintReprint}  {reprint}
    +{.} {}                             {transition}
}

\BibSpec{collection.article}{%
    +{}  {\hspace*{-.5em}\PrintAuthors}                {author}
    +{,} { \PrintDateB}                 {date}
    +{.} { }                            {title}
    +{.} { }                            {part}
    +{:} { }                            {subtitle}
    +{.} { \PrintContributions}         {contribution}
    +{.} { \PrintConference}            {conference}
    +{.} { \PrintBook}                  {book}
    +{.} { In \PrintEditorsA}              {editor}
    +{.} { \emph}                         {booktitle}
    +{,} { pages~}                      {pages}
    +{,} { }                            {publisher}
    +{,} { }                            {organization}
    +{,} { }                            {address}
    +{.} { \PrintTranslation}           {translation}
    +{.} { Reprinted in \PrintReprint}  {reprint}
    +{.} { }                            {note}
    +{.} {}                             {transition}
}

 \BibSpec{inproceedings}{%
     +{}  {\hspace*{-.5em}\PrintAuthors}                {author}
     +{,} { \PrintDateB}                 {date}
     +{.} { }                            {title}
     +{.} { }                            {part}
     +{:} { }                            {subtitle}
     +{.} { \PrintContributions}         {contribution}
     +{.} { \PrintConference}            {conference}
     +{.} { \PrintBook}                  {book}
     +{.} { In \PrintEditorsA}              {editor}
     +{.} {  \emph}                         {booktitle}
     +{,} { pages~}                      {pages}
     +{,} { }                            {publisher}
     +{,} { }                            {organization}
     +{,} { }                            {address}
     +{.} { \PrintTranslation}           {translation}
     +{.} { Reprinted in \PrintReprint}  {reprint}
     +{.} { }                            {note}
     +{.} {}                             {transition}
 }

\BibSpec{conference}{%
    +{}  {\hspace*{-.5em}}                        {title}
    +{}  {\PrintConferenceDetails} {transition}
}

\BibSpec{innerbook}{%
    +{.} { \emph}                       {title}
    +{.} { }                            {part}
    +{:} { \emph}                       {subtitle}
    +{.} { }                            {series}
    +{,} { \voltext}                    {volume}
    +{.} { Edited by \PrintNameList}    {editor}
    +{.} { Translated by \PrintNameList}{translator}
    +{.} { \PrintContributions}         {contribution}
    +{.} { }                            {publisher}
    +{.} { }                            {organization}
    +{,} { }                            {address}
    +{,} { \PrintEdition}               {edition}
    +{,} { \PrintDateB}                 {date}
    +{.} { }                            {note}
    +{.} {}                             {transition}
}

\BibSpec{report}{%
    +{}  {\hspace*{-.5em}\PrintPrimary}                {transition}
    +{,} { \PrintDateB}                 {date}
    +{.} { \emph}                       {title}
    +{.} { }                            {part}
    +{:} { \emph}                       {subtitle}
    +{.} { \PrintContributions}         {contribution}
    +{.} { Technical Report }           {number}
    +{,} { }                            {series}
    +{.} { }                            {organization}
    +{,} { }                            {address}
    +{.} { \PrintTranslation}           {translation}
    +{.} { Reprinted in \PrintReprint}  {reprint}
    +{.} { }                            {note}
    +{.} {}                             {transition}
}

\BibSpec{thesis}{%
    +{}  {\hspace*{-.5em}\PrintAuthors}                {author}
    +{,} { \PrintDateB}                 {date}
    +{,} { \emph}                       {title}
    +{:} { \emph}                       {subtitle}
    +{.} { \PrintThesisType}            {type}
    +{.} { }                            {organization}
    +{,} { }                            {address}
    +{.} { \PrintTranslation}           {translation}
    +{.} { Reprinted in \PrintReprint}  {reprint}
    +{.} { }                            {note}
    +{.} {}                             {transition}
}
\else
\BibSpecAlias{incollection}{inproceedings}
\BibSpec{article}{%
    +{}  {\PrintAuthors}                {author}
    +{.} { }                            {title}
    +{.} { }                            {part}
    +{:} { }                            {subtitle}
    +{.} { \PrintContributions}         {contribution}
    +{.} { \PrintPartials}              {partial}
    +{.} { \emph}                       {journal}
    +{,} { \textbf}                            {volume}
    +{}  { \parenthesize}               {number}
    +{:} {}                             {pages}
    +{,} { \PrintDateB}                 {date}
    +{,} { }                            {status}
    +{.} { \PrintTranslation}           {translation}
    +{.} { Reprinted in \PrintReprint}  {reprint}
    +{.} { }                            {note}
    +{.} {}                             {transition}
}

\BibSpec{partial}{%
    +{}  {}                             {part}
    +{:} { }                            {subtitle}
    +{.} { \PrintContributions}         {contribution}
    +{.} { \emph}                       {journal}
    +{,} { \textbf}                            {volume}
    +{}  { \parenthesize}               {number}
    +{:} {}                             {pages}
    +{,} { \PrintDateB}                 {date}
}

\BibSpec{book}{%
    +{}  {\PrintPrimary}                {transition}
    +{.} { \emph}                       {title}
    +{.} { }                            {part}
    +{:} { \emph}                       {subtitle}
    +{.} { }                            {series}
    +{,} { \voltext}                    {volume}
    +{.} { Edited by \PrintNameList}    {editor}
    +{.} { Translated by \PrintNameList}{translator}
    +{.} { \PrintContributions}         {contribution}
    +{.} { }                            {publisher}
    +{.} { }                            {organization}
    +{,} { }                            {address}
    +{,} { \PrintEdition}               {edition}
    +{,} { \PrintDateB}                 {date}
    +{.} { }                            {note}
    +{.} {}                             {transition}
    +{.} { \PrintTranslation}           {translation}
    +{.} { Reprinted in \PrintReprint}  {reprint}
    +{.} {}                             {transition}
}

\BibSpec{collection.article}{%
    +{}  {\PrintAuthors}                {author}
    +{.} { }                            {title}
    +{.} { }                            {part}
    +{:} { }                            {subtitle}
    +{.} { \PrintContributions}         {contribution}
    +{.} { \PrintConference}            {conference}
    +{.} { \PrintBook}                  {book}
    +{.} { In \PrintEditorsA}              {editor}
    +{.} { \emph}                         {booktitle}
    +{,} { pages~}                      {pages}
    +{,} { }                            {publisher}
    +{,} { }                            {organization}
    +{,} { }                            {address}
    +{,} { \PrintDateB}                 {date}
    +{.} { \PrintTranslation}           {translation}
    +{.} { Reprinted in \PrintReprint}  {reprint}
    +{.} { }                            {note}
    +{.} {}                             {transition}
}

 \BibSpec{inproceedings}{%
     +{}  {\PrintAuthors}                {author}
     +{.} { }                            {title}
     +{.} { }                            {part}
     +{:} { }                            {subtitle}
     +{.} { \PrintContributions}         {contribution}
     +{.} { \PrintConference}            {conference}
     +{.} { \PrintBook}                  {book}
     +{.} { In \PrintEditorsA}              {editor}
     +{.} {  \emph}                         {booktitle}
     +{,} { pages~}                      {pages}
     +{,} { }                            {publisher}
     +{,} { }                            {organization}
     +{,} { }                            {address}
     +{,} { \PrintDateB}                 {date}
     +{.} { \PrintTranslation}           {translation}
     +{.} { Reprinted in \PrintReprint}  {reprint}
     +{.} { }                            {note}
     +{.} {}                             {transition}
 }

\BibSpec{conference}{%
    +{}  {}                        {title}
    +{}  {\PrintConferenceDetails} {transition}
}

\BibSpec{innerbook}{%
    +{.} { \emph}                       {title}
    +{.} { }                            {part}
    +{:} { \emph}                       {subtitle}
    +{.} { }                            {series}
    +{,} { \voltext}                    {volume}
    +{.} { Edited by \PrintNameList}    {editor}
    +{.} { Translated by \PrintNameList}{translator}
    +{.} { \PrintContributions}         {contribution}
    +{.} { }                            {publisher}
    +{.} { }                            {organization}
    +{,} { }                            {address}
    +{,} { \PrintEdition}               {edition}
    +{,} { \PrintDateB}                 {date}
    +{.} { }                            {note}
    +{.} {}                             {transition}
}

\BibSpec{report}{%
    +{}  {\PrintPrimary}                {transition}
    +{.} { \emph}                       {title}
    +{.} { }                            {part}
    +{:} { \emph}                       {subtitle}
    +{.} { \PrintContributions}         {contribution}
    +{.} { Technical Report }           {number}
    +{,} { }                            {series}
    +{.} { }                            {organization}
    +{,} { }                            {address}
    +{,} { \PrintDateB}                 {date}
    +{.} { \PrintTranslation}           {translation}
    +{.} { Reprinted in \PrintReprint}  {reprint}
    +{.} { }                            {note}
    +{.} {}                             {transition}
}

\BibSpec{thesis}{%
    +{}  {\PrintAuthors}                {author}
    +{,} { \emph}                       {title}
    +{:} { \emph}                       {subtitle}
    +{.} { \PrintThesisType}            {type}
    +{.} { }                            {organization}
    +{,} { }                            {address}
    +{,} { \PrintDateB}                 {date}
    +{.} { \PrintTranslation}           {translation}
    +{.} { Reprinted in \PrintReprint}  {reprint}
    +{.} { }                            {note}
    +{.} {}                             {transition}
}
\fi
%\input{cyr.fd}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%	$Id: cyr.fd,v 1.2 2000/01/27 11:36:04 kisilv Exp $
% File: cyr.fd
%
\DeclareFontFamily{OT1}{cyr}{}
\DeclareFontShape{OT1}{cyr}{m}{n}
   {  <5> <6> <7> <8> <9> gen * wncyr
      <10> <10.95> <12> <14.4> <17.28> <20.74> <24.88> wncyr10}{}
\DeclareFontShape{OT1}{cyr}{m}{it}
    {
       <5> <6> <7> <8> <9> gen * wncyi
      <10> <10.95> <12> <14.4> <17.28> <20.74> <24.88>wncyi10
      }{}
\DeclareFontShape{OT1}{cyr}{m}{ss}
    {
       <5> <6> <7> <8> wncyss8
       <9> wncy9
      <10> <10.95> <12> <14.4> <17.28> <20.74> <24.88>wncyss10
      }{}
\DeclareFontShape{OT1}{cyr}{m}{sc}
    {
       <5> <6> <7> <8> <9> <10> <10.95> <12> <14.4> <17.28> <20.74> <24.88>wncysc10
      }{}
%%%%%%%% bold extended series
\DeclareFontShape{OT1}{cyr}{bx}{n}
   {
       <5> <6> <7> <8> <9> gen * wncyb
      <10> <10.95> <12> <14.4> <17.28> <20.74> <24.88>wncyb10
      }{}
\DeclareTextFontCommand{\textcyr}{\fontfamily{cyr}\selectfont}
\providecommand{\cyr}{\fontfamily{cyr}\selectfont\def\cprime{\~}}
\providecommand{\cprime}{\textquotesingle}

\usepackage{graphicx}
%\noweboptions{longxref,subscriptidents}

\def\theenumi{(\roman{enumi})}
\def\labelenumi{\theenumi}
\makeatother
%\newlabel{th-FSCc-intertwine}{{4.13}{45}{}{}{}}
\providecommand{\comment}[1]{}
\providecommand{\Space}[3][]{\ensuremath{\mathbb{#2}^{#3}_{#1}{}}}
\providecommand{\Cliff}[2][\comment]{{\ensuremath{%
\mathcal{C}\kern-0.18em\ell(#1,#2)}}}
\providecommand{\norm}[2][\relax]{\left\|#2\right\|\ifx#1\relax\else_{#1}\fi}
\providecommand{\modulus}[2][\relax]{\left| #2 \right|\ifx#1\relax\else_{#1}\fi}
\providecommand{\rmi}{\mathrm{i}}
\providecommand{\scalar}[3][\relax]{\left\langle #2,#3
        \right\rangle\ifx#1\relax\else_{#1}\fi}
\providecommand{\nscalar}[3][\relax]{\left[ #2,#3
        \right]\ifx#1\relax\else_{#1}\fi}
\providecommand{\wiki}[2]{\href{http://en.wikipedia.org/wiki/#1}{#2}}
\providecommand{\Zbl}[1]{Zbl\href{http://www.emis.de:80/cgi-bin/zmen/ZMATH/en/zmathf.html?first=1&maxdocs=3&type=html&an=#1&format=complete}{#1}}
\DeclareMathOperator{\arccosh}{arccosh}

\newcommand*\vtick{\kern -.1em\textsc{\char13}}

\def\nwbackslash{\texttt{\char92}}
\def\nwlbrace{\textbf{\texttt{\char123}}}
\def\nwrbrace{\textbf{\texttt{\char125}}}
\newcommand{\CPP}{\textsf{C++}}
\newcommand{\CPPeleven}{\textsf{C++11}}
\newcommand{\Python}{\textsf{Python}}
\newcommand{\NoWEB}{\texttt{noweb}}
\providecommand{\MetaPost}{\texttt{Meta}\-\texttt{Post}}
\providecommand{\GiNaC}{\textsf{GiNaC}}
\providecommand{\pyGiNaC}{\textsf{pyGiNaC}}
\providecommand{\cycle}[3][]{{#1 C^{#2}_{#3}}}
\providecommand{\realline}[3][]{#1 R^{#2}_{#3}}
\providecommand{\Asymptote}{\texttt{Asymptote}}
\providecommand{\myeprint}[2]{E-print: \href{#1}{\texttt{#2}}}
\providecommand{\bs}{\breve{\sigma}}
\providecommand{\rs}{\mathring{\sigma}}
\newif\iftth
\let\myappendix=\appendix
\providecommand{\tr}{\mathop{\mathrm{tr}}}
\providecommand{\vecbf}[1]{\mathbf{#1}}
\providecommand{\clifford}[2][]{\ifcase #1 #2\or \tilde{#2} \or \breve{#2} \fi}
\hypersetup{colorlinks=true,bookmarks=true}

\begin{document}
@
\ifshort
\else

@ %keyword basic
@ %keyword ex
@ %keyword numeric
@ %keyword idx
@ %keyword varidx
@ %keyword matrix
@ %keyword symbol
@ %keyword realsymbol
@ %keyword relational
@ %keyword indexed
@ %keyword tensor
@ %keyword tensormetric
@ %keyword lst
@ %keyword clifford
@ %keyword cycle
@ %keyword cycle2D
@ %keyword figure
@ %keyword subfigure
@ %keyword cycle_data
@ %keyword cycle_node
@ %keyword cycle_relation
\fi

\begin{frontmatter}

\title[Extension of Lie Geometry: Ensembles and their
  Implementation]{An Extension of M\"obius--Lie Geometry\\
    with Conformal Ensembles of Cycles\\
    and Its Implementation in a \GiNaC\ Library}

%\thanks{On  leave from Odessa University.}

\author{Vladimir V. Kisil}
\address{School of Mathematics, University of Leeds, Leeds LS2 9JT, England}
\email{\href{mailto:kisilv@maths.leeds.ac.uk}{kisilv@maths.leeds.ac.uk}}
\urladdr{\href{http://www.maths.leeds.ac.uk/~kisilv/}{http://www.maths.leeds.ac.uk/\~{}kisilv/}}

\date{\today\ (v3.1)}

\begin{abstract}
  We propose to consider ensembles of cycles (quadrics), which are
  interconnected through conformal-invariant geometric relations
  (e.g. ``to be orthogonal'', ``to be tangent'', etc.), as new objects
  in an extended M\"obius--Lie geometry.  It was recently
  demonstrated in several related papers, that such ensembles of
  cycles naturally parameterise many other conformally-invariant
  objects, e.g. loxodromes or continued fractions.

  The paper describes a method, which reduces a collection of
  conformally in\-vari\-ant geometric relations to a system of linear
  equations, which may be accompanied by one fixed quadratic
  relation. To show its usefulness, the method is implemented as a {\CPP}
  library. It operates with numeric and symbolic data of cycles in
  spaces of arbitrary dimensionality and metrics with any
  signatures. Numeric calculations can be done in exact or approximate
  arithmetic. In the two- and three-dimensional cases illustrations
  and animations can be produced. An interactive {\Python} wrapper of the
  library is provided as well.
\end{abstract}

\subjclass[2010]{Primary 51B25; Secondary 51N25, 51B10, 68U05, 11E88, 68W30.}

\end{frontmatter}

\ifelsevier
\pagestyle{plain}
\fi

@
\ifshort
\else
\tableofcontents

\listoffigures
\fi

@
\section{Introduction}
\label{sec:introduction}

@ \href{https://en.wikipedia.org/wiki/Lie_sphere_geometry}{Lie sphere
  geometry}~\citelist{ \cite{Cecil08a} \cite{Benz07a}*{Ch.~3}} in the
simplest planar setup unifies circles, lines and points---all together
called \emph{cycles} in this setup.  Symmetries of Lie spheres
geometry include (but are not limited to) fractional linear
transformations (FLT) of the form:
\begin{equation}
  \label{eq:flt-defn}
  \begin{pmatrix}
    a&b\\c&d
  \end{pmatrix}:\  x \mapsto
  \frac{ax+b}{cx+d}\,, \qquad \text{where }
  \det\begin{pmatrix}
    a&b\\c&d
  \end{pmatrix}\neq 0.
\end{equation}
Following other sources, e.g. ~\cite{Simon11a}*{\S~9.2}, we call
\eqref{eq:flt-defn} by FLT and reserve the name ``M\"obius maps'' for
the subgroup of FLT which fixes a particular cycle. For example, on
the complex plane FLT are generated by elements of
\(\mathrm{SL}_2(\Space{C}{})\) and M\"obius maps fixing the real line
are produced by
\(\mathrm{SL}_2(\Space{R}{})\)~\cite{Kisil12a}*{Ch.~1}.

There is a natural set of FLT-invariant geometric relations between
cycles (to be orthogonal, to be tangent, etc.) and the restriction of
Lie sphere geometry to invariants of FLT is called \emph{M\"obius--Lie
  geometry}.  Thus, an ensemble of cycles, structured by a set of such
relations, will be mapped by FLT to another ensemble with the same
structure.

It was shown recently that ensembles of cycles with certain
FLT-invariant relations provide helpful parametrisations of new
objects, e.g. points of the Poincar\'e extended space~\cite{Kisil15a},
loxodromes~\cite{KisilReid18a} or continued
fractions~\cites{BeardonShort14a,Kisil14a}, see
Example~\ref{ex:ensamble-math} below for further details. Thus, we
propose \emph{to extend M\"obius--Lie geometry and consider ensembles
  of cycles as its new objects}, cf. formal
Defn.~\ref{de:extended-Lie-Moebius}. Naturally, ``old''
objects---cycles---are represented by simplest one-element ensembles
without any relation. This paper provides conceptual foundations of
such extension and demonstrates its practical implementation as a
{\CPP} library [[figure]]\footnote{All described software is licensed
  under GNU GPLv3~\cite{GNUGPL}.}. Interestingly, the development of
this library shaped the general approach, which leads to specific
realisations in~\cites{Kisil15a,Kisil14a,KisilReid18a}.

@ More specifically, the library [[figure]] manipulates ensembles of
cycles (quadrics) interrelated by certain FLT-invariant geometric
conditions.  The code is build on top of the previous library
[[cycle]]~\cites{Kisil05b,Kisil12a,Kisil06a}, which manipulates
individual cycles within the \GiNaC~\cite{GiNaC} computer algebra
system. Thinking an ensemble as a graph, one can say that the library
[[cycle]] deals with individual vertices (cycles), while [[figure]]
considers edges (relations between pairs of cycles) and the whole
graph. Intuitively, an interaction with the library [[figure]] reminds
compass-and-straightedge constructions, where new lines or circles are
added to a drawing one-by-one through relations to already presented
objects (the line through two points, the intersection point or the
circle with given centre and a point). See
Example~\ref{ex:touch-centres-collinear} of such interactive
construction from the {\Python} wrapper, which provides an analytic
proof of a simple geometric statement.

It is important that both libraries are capable to work in spaces of
any dimensionality and metrics with an arbitrary signatures:
Euclidean, Minkowski and even degenerate. Parameters of objects can be
symbolic or numeric, the latter admit calculations with exact or
approximate arithmetic.  Drawing routines work with any (elliptic,
parabolic or hyperbolic) metric in two dimensions and the euclidean
metric in three dimensions.

The mathematical formalism employed in the library [[cycle]] is based
on Clifford algebras, which are intimately connected to fundamental
geometrical and physical objects
\cites{HestenesSobczyk84a,Hestenes15a}. Thus, it is not surprising
that Clifford algebras have been already used in various geometric
algorithms for a long time, for example see
\cites{Hildenbrand13a,Vince08a,DorstDoranLasenby02a} and further
references there. Our package deals with cycles through
Fillmore--Springer--Cnops construction (FSCc) which also has a long
history, see~\citelist{\cite{Schwerdtfeger79a}*{\S~1.1}
  \cite{Cnops02a}*{\S~4.1}
  \cite{FillmoreSpringer90a} \cite{Kirillov06}*{\S~4.2}
  \cite{Kisil05a} \cite{Kisil12a}*{\S~4.2}} and
section~\ref{sec:lie-spheres-geometry} below. Compared to a plain
analytical treatment~\citelist{\cite{Pedoe95a}*{Ch.~2}
  \cite{Benz07a}*{Ch.~3}}, FSCc is much more efficient and
conceptually coherent in dealing with FLT-invariant properties of
cycles. Correspondingly, the computer code based on FSCc is easy to
write and maintain.

The paper outline is as follows. In Section~\ref{sec:math-backgr} we
sketch the mathematical theory (M\"obius--Lie geometry) covered by the
package of the previous library [[cycle]]~\cite{Kisil05b} and the
present library [[figure]]. We expose the subject with some
references to its history since this can facilitate further
development.

Sec.~\ref{sec:conn-quadr-cycl} describes the principal mathematical
tool used by the library [[figure]].  It allows to reduce a collection
of various linear and quadratic equations (expressing geometrical
relations like orthogonality and tangency) to a set of linear
equations and \emph{at most one} quadratic
relation~\eqref{eq:det-normalisation-cond}. Notably, the quadratic
relation is the same in all cases, which greatly simplifies its
handling. This approach is the cornerstone of the library
effectiveness both in symbolic and numerical computations.  In
Sec.~\ref{sec:figures-as-families} we present several examples of
ensembles, which were already used in mathematical
theories~\cites{Kisil15a,Kisil14a,KisilReid18a}, then we describe how
ensembles are encoded in the present library [[figure]] through the
functional programming framework.

Sec.~\ref{sec:mathematical-results} outlines several typical usages of
the package. An example of a new statement discovered and demonstrated
by the package is given in Thm.~\ref{th:nine-points}.  In
Sec.~\ref{sec:do} we list of some further tasks, which will extend
capacities and usability of the package.

\ifshort
All coding-related material is enclosed as appendices in the full
documentation on the project page~\cite{Kisil05b}. They contain:
\begin{enumerate}
\item Numerous examples of the library usage
  starting from the very simple ones.
\item  A systematic list of callable
  methods.
\item Actual code of the library.
\end{enumerate}
Sec.~\ref{sec:math-backgr}, Example~\ref{ex:touch-centres-collinear}
below or the above-mentioned first two appendices of the full
documentation can serve as an entry point for a reader with respective
preferences and background.  \else All coding-related material is
enclosed as appendices.  App.~\ref{sec:examples} contains examples of
the library usage starting from the very simple ones. A systematic
list of callable methods is given in
Apps~\ref{sec:publ-meth-figure}--\ref{sec:addtional-utilities}. Any of
Sec.~\ref{sec:math-backgr} or
Apps~\ref{sec:examples}--\ref{sec:publ-meth-figure} can serve as an
entry point for a reader with respective preferences and
background. Actual code of the library is collected in
Apps~\ref{sec:figure-header-file}--\ref{sec:impl-class}.  \fi

@
\section{M\"obius--Lie Geometry and the [[cycle]] Library}
\label{sec:math-backgr}
We briefly outline mathematical formalism of the extend M\"obius--Lie
geometry, which is implemented in the present package. We do not aim
to present the complete theory here, instead we provide a minimal
description with a sufficient amount of references to further
sources. The hierarchical structure of the theory naturally splits the
package into two components: the routines handling individual cycles
(the library [[cycle]] briefly reviewed in this section), which were
already introduced elsewhere~\cite{Kisil05b}, and the new component
implemented in this work, which handles families of interrelated
cycles (the library [[figure]] introduced in the next section).

@
\subsection{M\"obius--Lie geometry and FSC construction}
\label{sec:lie-spheres-geometry}
M\"obius--Lie geometry in \(\Space{R}{n}\) starts from an observation
that points can be treated as spheres of zero radius and planes are
the limiting case of spheres with radii diverging to
infinity. Oriented spheres, planes and points are called together
\emph{cycles}\index{cycle}. Then, the second crucial step is to treat
cycles not as subsets of \(\Space{R}{n}\) but rather as points of some
projective space of higher dimensionality,
see~\citelist{\cite{Benz08a}*{Ch.~3} \cite{Cecil08a} \cite{Pedoe95a}
  \cite{Schwerdtfeger79a}}.

To distinguish two spaces we will call \(\Space{R}{n}\) as the \emph{point
  space}%
\index{point!space}%
\index{space!point} and the higher dimension space, where cycles are
represented by points---the \emph{cycle space}%
\index{cycle!space}%
\index{space!cycle}. Next important observation is that geometrical
relations between cycles as subsets of the point space can be
expressed in term of some indefinite metric on the cycle
space. Therefore, if an indefinite metric shall be considered anyway,
there is no reason to be limited to spheres in Euclidean space \(\Space{R}{n}\)
only. The same approach shall be adopted for quadrics in
spaces \(\Space{R}{pqr}\) of an arbitrary signature
\(p+q+r=n\), including \(r\) nilpotent elements,
cf.~\eqref{eq:clifford-defn} below.

A useful addition to M\"obius--Lie geometry is provided by the
Fillmore--Springer--Cnops construction
(FSCc)~\citelist{\cite{Schwerdtfeger79a}*{\S~1.1}
  \cite{Cnops02a}*{\S~4.1} \cite{Porteous95}*{\S~18}
  \cite{FillmoreSpringer90a} \cite{Kirillov06}*{\S~4.2}
  \cite{Kisil05a} \cite{Kisil12a}*{\S~4.2}}. It is a correspondence
between the cycles (as points of the cycle space) and certain
\(2\times 2\)-matrices defined in~\eqref{eq:spheres-Rn} below. The
main advantages of FSCc are:
\begin{enumerate}
\item The correspondence between cycles and matrices respects the
  projective structure of the cycle space.
\item The correspondence is FLT covariant.
\item The indefinite metric on the cycle space can be expressed
  through natural operations on the respective matrices.
\end{enumerate}
The last observation is that for restricted groups of M\"obius
transformations the metric of the cycle space may not be completely
determined by the metric of the point space,
see~\citelist{\cite{Kisil06a} \cite{Kisil05a}
  \cite{Kisil12a}*{\S~4.2}} for an example in two-dimensional space.

FSCc is useful in consideration of the Poincar\'e extension of
M\"obius maps~\cite{Kisil15a}, loxodromes~\cite{KisilReid18a} and
continued fractions~\cites{Kisil14a}. In theoretical physics FSCc
nicely describes conformal compactifications of various space-time
models~\citelist{\cite{HerranzSantander02b} \cite{Kisil06b}
  \cite{Kisil12a}*{\S~8.1}}.  Regretfully, FSCc have not yet
propagated back to the most fundamental case of complex numbers,
cf.~\cite{Simon11a}*{\S~9.2} or somewhat cumbersome techniques used
in~\cite{Benz07a}*{Ch.~3}. Interestingly, even the founding fathers
were not always strict followers of their own techniques,
see~\cite{FillmoreSpringer00a}.

We turn now to the explicit definitions.

\subsection{Clifford algebras, FLT transformations, and Cycles}
\label{sec:cliff-algebr-mobi}
We describe here the mathematics behind the the first library called
[[cycle]], which implements fundamental geometrical relations between
quadrics in the space \(\Space{R}{pqr}\) with the dimensionality
\(n=p+q+r\) and metric
\(x_1^2+\ldots+x_p^2-x_{p+1}^2-\ldots-x_{p+q}^2\). A version
simplified for complex numbers only can be found
in~\cites{Kisil15a,KisilReid18a,Kisil14a}.

The Clifford algebra \(\Cliff{p,q,r}\) is the associative unital algebra over
\(\Space{R}{}\) generated by the elements \(e_1\),\ldots,\(e_n\)
satisfying the following relation:
\begin{equation}
\label{eq:clifford-defn}
  e_i e_j =- e_je_i\,, \quad \text{ and } \quad e_i^2=\left\{
    \begin{array}{ll}
      -1,&\text{ if } 1\leq i\leq p;\\
      1,&\text{ if } p+1\leq i\leq p+q;\\
      0,&\text{ if } p+q+1\leq i\leq p+q+r.
    \end{array}
  \right.
\end{equation}
It is common~\cites{DelSomSou92,Cnops02a,Porteous95,%
  HestenesSobczyk84a,Hestenes15a} to consider mainly Clifford algebras
\(\Cliff{n}=\Cliff{n,0,0}\) of the Euclidean space or the algebra
\(\Cliff{p,q}=\Cliff{p,q,0}\) of the pseudo-Euclidean (Minkowski)
spaces. However, Clifford algebras \(\Cliff{p,q,r}\), \(r>0\) with
nilpotent generators \(e_i^2=0\) correspond to interesting
geometry~\cites{Kisil12a,Kisil05a,Yaglom79,Mustafa17a} and
physics~\cites{GromovKuratov06a,Gromov10a,Gromov12a,%
  Kisil12c,Kisil09e,Kisil17a} as well. Yet, the geometry with
idempotent units in spaces with dimensionality \(n>2\) is still not
sufficiently elaborated.

An element of
\(\Cliff{p,q,r}\) having the form \(x=x_1e_1+\ldots+x_ne_n\) can be
associated with the vector \((x_1,\ldots,x_n)\in\Space{R}{pqr}\).  The
\emph{reversion} \(a\mapsto a^*\) in
\(\Cliff{p,q,r}\)~\cite{Cnops02a}*{(1.19(ii))} is defined on vectors by
\(x^*=x\) and extended to other elements by the relation
\((ab)^*=b^*a^*\). Similarly the \emph{conjugation} is defined on
vectors by \(\bar{x}=-x\) and the relation
\(\overline{ab}=\bar{b}\bar{a}\). We also use the notation
\(\modulus{a}^2=a\bar{a}\) for any product \(a\) of vectors.
An important observation is that any non-zero \(x\in\Space{R}{n00}\) has a
multiplicative inverse: \(x^{-1}=\frac{\bar{x}}{\modulus{x}^2}\).
% By~\citelist{\cite{Porteous95}*{\S~18} \cite{Cnops02a}*{Thm.~4.10}})
% a matrix \(M=
% \begin{pmatrix}
%   a&b\\c&d
% \end{pmatrix}\) with Clifford entries defines a linear-fractional transformation of
% \(\Space{R}{p,q}\) if the
% following conditions are satisfied:
% \begin{enumerate}
% \item \(a\), \(b\), \(c\) and \(d\) are products of vectors in
%   \(\Space{R}{p,q}\);
% \item\label{it:ab-cd-ca-db-vectors} \(ab^*\), \(cd^*\), \(c^*a\) and \(d^*b\) are vectors in
%   \(\Space{R}{p,q}\);
% \item the pseudodeterminant \(\delta:=ad^*-bc^*\) is a non-zero real number.
% \end{enumerate}
% Clearly, we can scale the matrix to have the pseudodeterminant
% \(\delta=\pm 1\) without an effect on the related linear-fractional
% transformation.
For a \(2\times 2\)-matrix \(M=
 \begin{pmatrix}
   a&b\\c&d
 \end{pmatrix}\) with Clifford entries we define,
 cf.~\cite{Cnops02a}*{(4.7)}
\begin{equation}
  \label{eq:matrix-bar-star}
  \bar{M}=
\begin{pmatrix}
  d^*&-b^*\\-c^*&a^*
\end{pmatrix}\qquad \text{ and } \qquad
M^*=\begin{pmatrix}
  \bar{d} &\bar{b}\\\bar{c}&\bar{a}
\end{pmatrix}.
\end{equation}
Then \(M\bar{M}=\delta I\) for the \emph{pseudodeterminant} \(\delta:=ad^*-bc^*\) .
% and \(\bar{M}=\kappa M^*\), where
%\(\kappa=1\) or \(-1\) depending either \(d\) is a product of even or
%odd number of vectors.

% Here we use vector rather than paravector formalism,
% see~\cite{Cnops02a}*{(1.42)}.  Namely, we consider vectors
% \(x\in\Space{R}{n+1}\) as elements \(x=x_1e_1+\ldots+x_ne_n+x_{n+1}
% e_{n+1}\) in \(\Cliff{n+1}\).  Therefore we can extend the FLT
%  defined by \(M=
% \begin{pmatrix}
%   a&b\\c&d
% \end{pmatrix}\) with \(a,b,c,d\in\Cliff{p,q,r}\) to act on
% \(\Space{R}{n+1}\). Again, such transformations commute with the
% reflection \(R\) in the hyperplane \(x_{n+1}=0\):
% \begin{displaymath}
%   R:\quad x_1e_1+\ldots+x_ne_n+x_{n+1} e_{n+1}\quad
%   \mapsto \quad x_1e_1+\ldots+x_ne_n-x_{n+1} e_{n+1}.
% \end{displaymath}
% Thus we can consider FLT acting on the equivalence
% classes \(x\sim R(x)\).

Quadrics in \(\Space{R}{pq}\)---which we continue to
call cycles---can be associated to
\(2\times 2\) matrices through the FSC
construction~\citelist{\cite{FillmoreSpringer90a}
  \cite{Cnops02a}*{(4.12)} \cite{Kisil12a}*{\S~4.4}}:
\begin{equation}
  \label{eq:spheres-Rn}
  k\bar{x}x-l\bar{x}-x\bar{l}+m=0 \quad \leftrightarrow \quad
  \cycle{}{}=
  \begin{pmatrix}
    l & m\\
    k & \bar{l}
  \end{pmatrix},
\end{equation}
where \(k, m\in\Space{R}{}\) and \(l\in\Space{R}{pq}\).  For brevity
we also encode a cycle by its coefficients \((k,l,m)\).  A
justification of~\eqref{eq:spheres-Rn} is provided by the identity:
\begin{displaymath}
  \begin{pmatrix}
    1&\bar{x}
  \end{pmatrix}
  \begin{pmatrix}
    l & m\\
    k & \bar{l}
  \end{pmatrix}
  \begin{pmatrix}
    {x}\\1
  \end{pmatrix}=
  kx\bar{x}-l\bar{x}-x\bar{l}+m,\quad \text{ since } \bar{x}=-x \text{
    for } x\in\Space{R}{pq}.
\end{displaymath}
The identification is also FLT-covariant in the sense that the
transformation~\eqref{eq:flt-defn} associated with the matrix \(M=
\begin{pmatrix}
  a&b\\c&d
\end{pmatrix}
\) sends a cycle
\(\cycle{}{}\) to the cycle \(M\cycle{}{}M^{*}\)~\cite{Cnops02a}*{(4.16)}.
% The equivalence  \(x\sim R(x)\) is extended to spheres:
% \begin{displaymath}
%   \begin{pmatrix}
%     l & m\\
%     k & \bar{l}
%   \end{pmatrix}\quad\sim   \quad
%   \begin{pmatrix}
%     R(l) & m\\
%     k & R(\bar{l})
%   \end{pmatrix}
% \end{displaymath}
% since it is preserved by the FLT with
% coefficients from \(\Cliff{p,q,r}\).
We define the FLT-invariant inner product of cycles
\(\cycle{}{1}\) and \(\cycle{}{2}\) by the
identity
\begin{align}
  \label{eq:cycle-product}
  \scalar{\cycle{}{1}}{\cycle[]{}{2}}&=\Re
\tr(\cycle{}{1}\cycle{}{2})\,,
\end{align}
where \(\Re\) denotes the scalar part of a Clifford number. This
definition in term of matrices immediately implies that the inner
product is FLT-invariant. The explicit expression in terms of
 components of cycles \(\cycle{}{1}=(k_1,l_1,m_1)\) and
\(\cycle{}{2}=(k_2,l_2,m_2)\) is also useful sometimes:
\begin{align}
  \label{eq:cycle-product-expl}
  \scalar{\cycle{}{1}}{\cycle[]{}{2}}&=l_1 l_2+ \bar{l}_1 \bar{l}_2+m_1k_2+m_2k_1\,.
\end{align}
As usual, the relation \(\scalar{\cycle{}{1}}{\cycle[]{}{2}}=0\) is
called the \emph{orthogonality} of cycles \(\cycle{}{1}\) and
\(\cycle{}{2}\). In most cases it corresponds to orthogonality of
quadrics in the point space. More generally, most of
FLT-invariant relations between quadrics may be expressed in
terms FLT-invariant inner product~\eqref{eq:cycle-product}. For
the full description of methods on individual cycles, which are
implemented in the library [[cycle]], see the respective
documentation~\cite{Kisil05b}.

\begin{rem}
  Since cycles are elements of the projective space, the following
  \emph{normalised cycle product}:
  \begin{equation}
    \label{eq:norm-cycle-prod}
    \nscalar{C_1}{C_2}:=\frac{\scalar{C_1}{C_2}}{\sqrt{\scalar{C_1}{C_1}
        \scalar{C_2}{C_2}}}
  \end{equation}
  is more meaningful than the cycle product~\eqref{eq:cycle-product}
  itself. Note that, \(\nscalar{C_1}{C_2}\) is defined only if neither
  \(C_1\) nor \(C_2\) is a zero-radius cycle (i.e. a point). Also, the
  normalised cycle product is \(\mathrm{GL}_2(\Space{C}{})\)-invariant
  in comparison to \(\mathrm{SL}_2(\Space{C}{})\)-invariance
  of~\eqref{eq:cycle-product}.
\end{rem}

We finish this brief review of the library [[cycle]] by pointing to
its light version written in \textsf{Asymptote}
language~\cite{Asymptote} and distributed together with the
paper~\cite{KisilReid18a}. Although the light version mostly inherited
API of the library [[cycle]],  there are some significant limitations caused
by the absence of {\GiNaC} support:
\begin{enumerate}
\item there is no symbolic computations of any sort;
\item the light version works in two dimensions only;
\item only elliptic metrics in the point and cycle spaces are supported.
\end{enumerate}
On the other hand, being integrated with  \textsf{Asymptote} the light
version simplifies production of illustrations, which are its main target.

\section{Ensembles of Interrelated Cycles and the [[figure]] Library}
\label{sec:library-figure}

The library [[figure]] has an ability to store and resolve the system of
geometric relations between cycles. We explain below some mathematical
foundations, which greatly simplify this task.

\subsection{Connecting quadrics and cycles}
\label{sec:conn-quadr-cycl}
We need a vocabulary, which translates geometric properties of
quadrics on the point space to corresponding relations in the cycle
space. The key ingredient is the cycle
product~\eqref{eq:cycle-product}--\eqref{eq:cycle-product-expl}, which
is linear in each cycles\vtick\  parameters. However, certain conditions,
e.g. tangency of cycles, involve polynomials of cycle products and
thus are non-linear.  For a successful algorithmic implementation, the
following observation is important: \emph{all non-linear conditions
  below can be linearised if the additional quadratic condition of
  normalisation type is imposed}:
\begin{equation}
  \label{eq:det-normalisation-cond}
  \scalar{\cycle{}{}}{\cycle{}{}}=\pm1.
\end{equation}
This observation in the context of the Apollonius problem was already
made in~\cite{FillmoreSpringer00a}. Conceptually the present work has
a lot in common with the above mentioned paper of Fillmore and
Springer, however a reader need to be warned that our implementation is
totally different (and, interestingly, is more closer to another
paper~\cite{FillmoreSpringer90a} of Fillmore and Springer).
\begin{rem}
  Interestingly, the method of order reduction for algebraic equations is
  conceptually similar to the method of order reduction of
  differential equations used to build a geometric dynamics of quantum
  states in~\cite{AlmalkiKisil18a}.
\end{rem}

Here is the list of relations between cycles implemented in the
current version of the library [[figure]].
\begin{enumerate}
\item  \label{item:quadric-flat}
  A quadric is flat (i.e. is a hyperplane), that is, its equation
  is linear. Then, either of two equivalent conditions can be used:
  \begin{enumerate}
  \item \(k\) component of the cycle vector is zero;
  \item the cycle is orthogonal
    \(\scalar{\cycle{}{1}}{\cycle[]{}{\infty}}=0\) to the ``zero-radius cycle at
    infinity'' \(\cycle[]{}{\infty}=(0,0,1)\).
  \end{enumerate}
\item \label{it:lobachevski-line}
  A quadric on the plane represents a line in Lobachevsky-type
  geometry if it is orthogonal
  \(\scalar{\cycle{}{1}}{\cycle[]{}{\Space{R}{}}}=0\)  to the real line cycle
  \(\cycle{}{\Space{R}{}}\). A similar condition is meaningful in
  higher dimensions as well.
\item \label{it:point-zero-radius}
  A quadric \(\cycle{}{}\) represents a point, that is, it has zero
  radius at given metric of the point space. Then, the determinant of
  the corresponding FSC matrix is zero or, equivalently, the cycle is
  self-orthogonal (isotropic):
  \(\scalar{\cycle{}{}}{\cycle[]{}{}}=0\). Naturally, such a cycle
  cannot be normalised to the form~\eqref{eq:det-normalisation-cond}.
\item Two quadrics are orthogonal in the point space
  \(\Space{R}{pq}\). Then, the matrices representing cycles are
  orthogonal in the sense of the inner
  product~\eqref{eq:cycle-product}.
\item Two cycles \(\cycle{}{}\) and \(\cycle[\tilde]{}{}\)
  are tangent. Then we have the following quadratic condition:
  \begin{equation}
    \label{eq:tangent-condition-defn}
    \scalar{\cycle{}{}}{\cycle[\tilde]{}{}}^2
    =  \scalar{\cycle{}{}}{\cycle{}{}}
    \scalar{\cycle[\tilde]{}{}}{\cycle[\tilde]{}{}}
    \qquad \left(\text{ or }
    \nscalar{\cycle{}{}}{\cycle[\tilde]{}{}}=\pm 1\right).
  \end{equation}
  With the assumption, that the cycle \(\cycle{}{}\) is normalised by
  the condition~\eqref{eq:det-normalisation-cond}, we may re-state
  this condition in the relation, which is linear to components of the cycle
  \(\cycle{}{}\):
  \begin{equation}
    \label{eq:tangent-condition-linear}
    \scalar{\cycle{}{}}{\cycle[\tilde]{}{}}
    = \pm \sqrt{\scalar{\cycle[\tilde]{}{}}{\cycle[\tilde]{}{}}}.
  \end{equation}
  Different signs here represent internal and outer touch.
\item Inversive distance \(\theta\) of two (non-isotropic) cycles is
  defined by the formula:
  \begin{equation}
    \label{eq:inversive-distance}
    \scalar{\cycle{}{}}{\cycle[\tilde]{}{}}
    = \theta \sqrt{
    \scalar{\cycle{}{}}{\cycle{}{}}}
  \sqrt{\scalar{\cycle[\tilde]{}{}}{\cycle[\tilde]{}{}}}
  \end{equation}
  In particular, the above discussed orthogonality corresponds to
  \(\theta=0\) and the tangency to \(\theta=\pm1\). For intersecting
  spheres \(\theta\) provides the cosine of the intersecting
  angle. For other metrics, the geometric interpretation of inversive
  distance shall be modified accordingly.

  If we are looking for a cycle \({\cycle{}{}}\) with a given
  inversive distance \(\theta\) to a given cycle
  \({\cycle[\tilde]{}{}}\), then the
  normalisation~\eqref{eq:det-normalisation-cond} again turns the
  defining relation~\eqref{eq:inversive-distance} into a linear with
  respect to parameters of the unknown cycle  \({\cycle{}{}}\).
\item A generalisation of Steiner power \(d\) of two cycles is defined
  as, cf.~\cite{FillmoreSpringer00a}*{\S~1.1}:
  \begin{equation}
    \label{eq:steiner-power}
    d=    \scalar{\cycle{}{}}{\cycle[\tilde]{}{}}
    + \sqrt{\scalar{\cycle{}{}}{\cycle{}{}}}
  \sqrt{\scalar{\cycle[\tilde]{}{}}{\cycle[\tilde]{}{}}},
  \end{equation}
  where both cycles \(\cycle{}{}\) and \(\cycle[\tilde]{}{}\) are
  \(k\)-normalised, that is the coefficient in front the quadratic
  term in~\eqref{eq:spheres-Rn} is \(1\). Geometrically, the
  generalised Steiner power for spheres provides the square of
  tangential distance. However, this relation is again non-linear for
  the cycle \(\cycle{}{}\).

  If we replace \(\cycle{}{}\) by the cycle
  \(\cycle{}{1}=\frac{1}{\sqrt{\scalar{\cycle{}{}}{\cycle{}{}}}}\cycle{}{}\)
  satisfying~\eqref{eq:det-normalisation-cond}, the
  identity~\eqref{eq:steiner-power} becomes:
  \begin{equation}
    \label{eq:steiner-power-linear}
    d\cdot k=    \scalar{\cycle{}{1}}{\cycle[\tilde]{}{}}
    +   \sqrt{\scalar{\cycle[\tilde]{}{}}{\cycle[\tilde]{}{}}},
  \end{equation}
  where \(k=\frac{1}{\sqrt{\scalar{\cycle{}{}}{\cycle{}{}}}}\) is the
  coefficient in front of the quadratic term of \(\cycle{}{1}\). The
  last identity is linear in terms of the coefficients of
  \(\cycle{}{1}\).
\end{enumerate}
Summing up: if an unknown cycle is connected to already given cycles
by any combination of the above relations, then all conditions can be
expressed as \emph{a system of linear equations for coefficients of the
unknown cycle and at most one quadratic
equation~\eqref{eq:det-normalisation-cond}}.

@
\subsection{Figures as families of cycles---functional approach}
\label{sec:figures-as-families}

We start from some examples of ensembles of cycles, which conveniently
describe FLT-invariant families of objects.

\begin{example}
  \label{ex:ensamble-math}
  \begin{enumerate}
  \item \label{it:poincare-extension}
    The Poincar\'e extension of M\"obius transformations from the
  real line to the upper half-plane of complex numbers is described by
  a triple of cycles \(\{\cycle{}{1}, \cycle{}{2}, \cycle{}{3}\}\)
  such that:
  \begin{enumerate}
  \item    \(\cycle{}{1}\) and \(\cycle{}{2}\) are orthogonal  to
    the real line;
  \item \(\scalar{\cycle{}{1}}{\cycle{}{2}}^2\leq
    \scalar{\cycle{}{1}}{\cycle{}{1}}
    \scalar{\cycle{}{2}}{\cycle{}{2}}\);
  \item \(\cycle{}{3}\) is orthogonal to any cycle in the triple
    including itself.
  \end{enumerate}
  A modification~\cites{Kisil14a} with ensembles of four cycles
  describes an extension from the real line to the upper half-plane of
  complex, dual or double numbers.  The construction can be
  generalised to arbitrary dimensions~\cite{Beardon95}.
\item\label{it:param-loxodromes}
  A parametrisation of loxodromes is provided by a triple of
  cycles \(\{\cycle{}{1}, \cycle{}{2}, \cycle{}{3}\}\) such
  that, cf.~\cite{KisilReid18a} and Fig.~\ref{fig:equiv-param-loxodr}: 
  \begin{enumerate}
  \item \(\cycle{}{1}\) is orthogonal to \(\cycle{}{2}\) and  \(\cycle{}{3}\);
  \item \(\scalar{\cycle{}{2}}{\cycle{}{3}}^2\geq
    \scalar{\cycle{}{2}}{\cycle{}{2}}
    \scalar{\cycle{}{3}}{\cycle{}{3}}\).
  \end{enumerate}
  Then, main invariant properties of M\"obius--Lie geometry,
  e.g. tangency of loxodromes, can be expressed in terms of this
  parametrisation~\cite{KisilReid18a}. 
\item A continued fraction is described by an infinite ensemble of
  cycles \((\cycle{}{k})\) such that~\cite{BeardonShort14a}:
  \begin{enumerate}
  \item All \(\cycle{}{k}\) are touching the real line (i.e. are
    \emph{horocycles});
  \item \((\cycle{}{1})\) is a horizontal line passing through
    \((0,1)\);
  \item \(\cycle{}{k+1}\) is tangent to \(\cycle{}{k}\) for all \(k>1\).
  \end{enumerate}
  This setup was extended in \cites{Kisil14a} to several similar
  ensembles. The key analytic properties of continued
  fractions---their convergence---can be linked to asymptotic
  behaviour of such an infinite ensemble~\cite{BeardonShort14a}.
\item A remarkable relation exists between discrete integrable systems
  and M\"obius geometry of finite configurations of
  cycles~\cites{BobenkoSchief18a,%
    KonopelchenkoSchief02a,KonopelchenkoSchief02b,%
    KonopelchenkoSchief05a,SchiefKonopelchenko09a}.  It comes from
  ``reciprocal force diagrams'' used in 19th-century statics, starting
  with J.C.~Maxwell. It is demonstrated in that the geometric
  compatibility of reciprocal figures corresponds to the algebraic
  compatibility of linear systems defining these configurations. On
  the other hand, the algebraic compatibility of linear systems lies
  in the basis of integrable systems. In
  particular~\cites{KonopelchenkoSchief02a,KonopelchenkoSchief02b},
  important integrability conditions encapsulate nothing but a
  fundamental theorem of ancient Greek geometry.
\item \label{it:wave-envelope}
  An important example of an infinite ensemble is provided by the
  representation of an arbitrary wave as the envelope of a continuous
  family of spherical waves. A finite subset of spheres can be used as
  an approximation to the infinite family. Then, discrete snapshots of
  time evolution of sphere wave packets represent a FLT-covariant
  ensemble of cycles~\cite{Bateman55a}. Further physical applications
  of FLT-invariant ensembles may be looked at~\cite{Kastrup08a}.
\end{enumerate}
\end{example}

One can easily note that the above parametrisations of some objects by
ensembles of cycles are not necessary unique. Naturally, two ensembles
parametrising  the same object are again connected by
FLT-invariant conditions. We presented only one example
here, cf.~\cite{KisilReid18a}.
\begin{figure}[htbp]
  \centering
    \animategraphics[controls=true,width=.9\textwidth,poster=first]{50}{_loxodromes}{1}{200}
    \caption[Equivalent parametrisation of a loxodrome]{Animated
      graphics of equivalent three-cycle parametrisations of a
      loxodrome. The green cycle is \(\cycle{}{1}\), two red circles are
      \(\cycle{}{2}\) and \(\cycle{}{3}\).}
  \label{fig:equiv-param-loxodr}
\end{figure}
\begin{example}
  Two non-degenerate triples \(\{\cycle{}{1},\cycle{}{2},\cycle{}{3}\}\) and
  \(\{\cycle[\tilde]{}{1},\cycle[\tilde]{}{2},\cycle[\tilde]{}{3}\}\) parameterise the same loxodrome as
  in Ex.~\ref{ex:ensamble-math}\ref{it:param-loxodromes} if and only if all the following
  conditions are satisfied:
  \begin{enumerate}
  \item \label{item:same-pencil}
    Pairs \(\{\cycle{}{2},\cycle{}{3}\}\) and \(\{\cycle[\tilde]{}{2},\cycle[\tilde]{}{3}\}\)  span the same
    hyperbolic pencil. That is cycles \(\cycle[\tilde]{}{2}\) and \(\cycle[\tilde]{}{3}\) are linear
    combinations of \(\cycle{}{2}\) and \(\cycle{}{3}\) and vise versa.
  \item \label{item:same-lambda}
    Pairs \(\{\cycle{}{2},\cycle{}{3}\}\) and \(\{\cycle[\tilde]{}{2},\cycle[\tilde]{}{3}\}\) have the same
    normalised cycle product~\eqref{eq:norm-cycle-prod}:
    \begin{equation}
      \label{eq:equal-lambdas}
      \nscalar {\cycle{}{2}}{\cycle{}{3}}=\nscalar {\cycle[\tilde]{}{2}}{\cycle[\tilde]{}{3}}.
    \end{equation}
  \item \label{item:ellipt-hyperb-ident}
    The elliptic-hyperbolic identity holds:
    \begin{equation}
      \label{eq:ellipt-hyperb-equat}
      \frac{\arccosh\nscalar {\cycle{}{j}}{\cycle[\tilde]{}{j}}}{\arccosh\nscalar{\cycle{}{2}}{\cycle{}{3}}}
      \equiv
      \frac{1}{2\pi}\arccos\nscalar {\cycle{}{1}}{\cycle[\tilde]{}{1}} \pmod{1}\,,
    \end{equation}
    where \(j\) is either \(2\) or \(3\).
  \end{enumerate}
  Various triples of cycles parametrising the same loxodrome are
  animated on Fig.~\ref{fig:equiv-param-loxodr}.
\end{example}
The respective equivalence relation for parametrisation of Poincar\'e
extension from Ex.~\ref{ex:ensamble-math}\ref{it:poincare-extension} is provided
in~\cite{Kisil15a}*{Prop.~12}.  These examples suggest that one can
expand the subject and applicability of M\"obius--Lie geometry through
the following formal definition.
\begin{defn}
  \label{de:extended-Lie-Moebius}
  Let \(X\) be a set, \(R \subset X\times X\) be an oriented graph
  on \(X\) % such that any two elements of \(X\) are connected a
  % non-oriented path within \(R\). For
  and \(f\) be a function on \(R\) with values in FLT-invariant
  relations from \S~\ref{sec:conn-quadr-cycl}. Then
  \emph{\((R,f)\)-ensemble} is a collection of cycles
  \(\{C_j\}_{j\in X}\) such that
  \begin{displaymath}
    C_i \text { and } C_j \text{ are in the relation } f(i,j) \text {
      for all } (i,j)\in R.
  \end{displaymath}
  For a fixed FLT-invariant equivalence 
  relations \(\sim\) on the set \(\mathcal{E}\) of all \((R,f)\)-ensembles,
  \emph{the extended M\"obius--Lie geometry} studies properties of cosets
  \(\mathcal{E}/\sim\).
\end{defn}
This definition can be suitably modified for
\begin{enumerate}
\item ensembles with relations of more then two cycles; and/or
\item ensembles parametrised by continuous sets \(X\), cf. wave
  envelopes in Ex.~\ref{ex:ensamble-math}\ref{it:wave-envelope}.
\end{enumerate}

The above extension was developed along with the realisation
the library [[figure]] within the \emph{functional programming}
framework. More specifically, an object from the [[class \ figure]] stores
defining relations, which link new cycles to the previously introduced
ones. This also may be treated as classical geometric
compass-and-straightedge constructions, where new lines or circles are
drawn through already existing elements. If requested, an explicit
evaluation of cycles\vtick\ parameters from this data may be
attempted.

To avoid ``chicken or the egg'' dilemma all cycles are stored in a
hierarchical structure of generations, numbered by integers. The basic
principles are:
\begin{enumerate}
\item Any explicitly defined cycle (i.e., a cycle which is not related to any
  previously known cycle) is placed into generation-0;
\item Any new cycle defined by relations to \emph{previous} cycles
  from generations \(k_1\), \(k_2\), \ldots, \(k_n\) is placed to the
  generation \(k\) calculated as:
  \begin{equation}
    \label{eq:generation-calculation}
    k=\max(k_1,k_2,\ldots,k_n)+1 .
  \end{equation}
  This rule does not forbid a cycle to have a relation to itself,
  e.g. isotropy (self-orthogonality) condition
  \(\scalar{\cycle{}{}}{\cycle{}{}}=0\), which specifies point-like
  cycles, cf. relation~\ref{it:point-zero-radius} in~\S~\ref{sec:conn-quadr-cycl}.  In fact, this is the only
  allowed type of relations to cycles in the same (not even speaking
  about younger) generations.
\end{enumerate}
There are the following alterations of the above rules:
\begin{enumerate}
\item From the beginning, every figure has two pre-defined cycles: the
  real line (hyperplane) \(\cycle{}{\Space{R}{}}\), and the zero radius cycle at infinity
  \(\cycle{}{\infty}=(0,0,1)\). These cycles are required for
  relations~\ref{item:quadric-flat} and~\ref{it:lobachevski-line} from
  the previous subsection. As predefined cycles, \(\cycle{}{\Space{R}{}}\) and
  \(\cycle{}{\infty}\) are placed in negative-numbered
  generations defined by the macros [[REAL_LINE_GEN]] and
  [[INFINITY_GEN]].
\item If a point is added to generation-0 of a figure, then it is
  represented by a zero-radius cycle with its centre at the given
  point. Particular parameter of such cycle dependent on the used
  metric, thus this cycle is not considered as explicitly
  defined. Thereafter, the cycle shall have some parents at a
  negative-numbered generation defined by the macro [[GHOST_GEN]].
\end{enumerate}
A figure can be in two different modes: [[freeze]] or [[unfreeze]],
the second is default. In the [[unfreeze]] mode an addition of a new
cycle by its relation prompts an evaluation of its parameters. If the
evaluation was successful then the obtained parameters are stored and
will be used in further calculations for all children of the cycle. Since many
relations (see the previous Subsection) are connected to quadratic
equation~\eqref{eq:det-normalisation-cond}, the solutions may come in
pairs. Furthermore, if the number or nature of conditions is not
sufficient to define the cycle uniquely (up to natural quadratic
multiplicity), then the cycle will depend on a number of free
(symbolic) variable.

There is a macro-like tool, which is called [[subfigure]]. Such a
[[subfigure]] is a [[figure]] itself, such that its inner hierarchy of
generations and relations is not visible from the current
[[figure]]. Instead, some cycles (of any generations) of the current
[[figure]] are used as predefined cycles of generation-0 of
[[subfigure]]. Then only one dependent cycle of [[subfigure]], which
is known as result, is returned back to the current [[figure]]. The
generation of the result is calculated from generations of input
cycles by the same formula~\eqref{eq:generation-calculation}.

There is a possibility to test certain conditions (``are two cycles
orthogonal?'') or measure certain quantities (``what is their
intersection angle?'') for already defined cycles. In particular, such
methods can be used to prove geometrical statements according to the
Cartesian programme, that is replacing the synthetic geometry by
purely algebraic manipulations.
\begin{example}
  \label{ex:touch-centres-collinear}
  As an elementary demonstration, let us prove that if a cycle [[r]]
  is orthogonal to a circle [[a]] at the point [[C]] of its contact with a
  tangent line [[l]], then [[r]] is also orthogonal to the line
  [[l]]. To simplify setup we assume that [[a]] is the unit
  circle. Here is the {\Python} code:
\begin{lstlisting}
F=figure()
a=F.add_cycle(cycle2D(1,[0,0],-1),"a")
l=symbol("l")
C=symbol("C")
F.add_cycle_rel([is_tangent_i(a),is_orthogonal(F.get_infinity()),only_reals(l)],l)
F.add_cycle_rel([is_orthogonal(C),is_orthogonal(a),is_orthogonal(l),only_reals(C)],C)
r=F.add_cycle_rel([is_orthogonal(C),is_orthogonal(a)],"r")
Res=F.check_rel(l,r,"cycle_orthogonal")
for i in range(len(Res)):
    print "Tangent and radius are orthogonal: %s" %\
    bool(Res[i].subs(pow(cos(wild(0)),2)==1-pow(sin(wild(0)),2)).normal())
\end{lstlisting}
The first line creates an empty figure [[F]] with the default
euclidean metric. The next line explicitly uses parameters
\((1,0,0,-1)\) of [[a]] to add it to [[F]]. Lines~3--4 define symbols
[[l]] and [[C]], which are needed because cycles with these labels are
defined in lines~5--6 through some relations to themselves and the
cycle [[a]]. In both cases we want to have cycles with real
coefficients only and [[C]] is additionally self-orthogonal (i.e. is a
zero-radius). Also, [[l]] is orthogonal to infinity (i.e. is a line)
and [[C]] is orthogonal to [[a]] and [[l]] (i.e. is their common
point). The tangency condition for [[l]] and self-orthogonality of
[[C]] are both quadratic relations.  The former has two solutions each
depending on one real parameter, thus line [[l]] has two
instances. Correspondingly, the point of contact [[C]] and the
orthogonal cycle [[r]] through [[C]] (defined in line~7) each have two
instances as well. Finally, lines~8--11 verify that every instance of
[[l]] is orthogonal to the respective instance of [[r]], this is
assisted by the trigonometric substitution \(\cos^2(*)=1-\sin^2(*)\)
used for parameters of [[l]] in line~11.  The output predictably is:
\begin{verbatim}
Tangent and circle r are orthogonal: True
Tangent and circle r are orthogonal: True
\end{verbatim}
\end{example}
An original statement proved by the library [[figure]] for the first
time will be considered in the next Section.

@
\section{Mathematical Usage of the Library}
\label{sec:mathematical-results}

The developed library [[figure]] has several different uses:
\begin{itemize}
\item It is easy to produce high-quality illustrations, which are
  fully-accurate in mathematical sence. The user is not responsible
  for evaluation of cycles\vtick\ parameters, all computations are
  done by the library as soon as the figure is defined in terms of few
  geometrical relations. This is especially helpful for complicated
  images which may contain thousands of interrelated cycles. See
  Escher-like Fig.~\ref{fig:action-modular-group} which shows images
  of two circles under the modular group
  action~\cite{StewartTall02a}*{\S~14.4}\ifshort\else,
  cf.~\ref{sec:an-illustr-modul}\fi.
\begin{figure}[htbp]
  \centering
  \includegraphics[,width=.9\textwidth]{modular-group.pdf}
  \caption{Action of the modular group on the upper half-plane.}
  \label{fig:action-modular-group}
\end{figure}
\begin{figure}[htbp]
  \centering
  \includegraphics[scale=.5]{shot_06-13_165537.png}
  \caption{An example of Apollonius problem in three dimensions.}
  \label{fig:apollonius-3D}
\end{figure}
\item The package can be used for computer experiments in M\"obius--Lie
  geometry. There is a possibility to create an arrangement of cycles
  depending on one or several parameters. Then, for particular values
  of those parameters certain conditions, e.g. concurrency of cycles,
  may be numerically tested or graphically visualised. It is possible
  to create animations with gradual change of the parameters, which
  are especially convenient for illustrations, see
  Fig.~\ref{fig:nine-points-anim} and~\cite{Kisil16a}.
\item Since the library is based on the \GiNaC\ system, which provides a
  symbolic computation engine, there is a possibility to make fully
  automatic proofs of various statements in M\"obius--Lie geometry.  Usage
  of computer-supported proofs in geometry is already an established
  practice~\cites{Kisil12a,Pech07a} and it is naturally to expect its further
  rapid growth.
\item Last but not least, the combination of classical beauty of Lie
  sphere geometry and modern computer technologies is a useful
  pedagogical tool to widen interest in mathematics through visual and
  hands-on experience.
\end{itemize}

Computer experiments are especially valuable for Lie geometry of
indefinite or nilpotent metrics since our intuition is not elaborated
there in contrast to the Euclidean
space~\cites{Kisil07a,Kisil06a,Kisil05a}. Some advances in
the two-dimensional space were achieved
recently~\cites{Mustafa17a,Kisil12a}, however further developments in
higher dimensions are still awaiting their researchers.

As a non-trivial example of automated proof accomplished by the [[figure]]
library for the first time, we present a FLT-invariant version of the
classical nine-point theorem~\citelist{\cite{Pedoe95a}*{\S~I.1}
  \cite{CoxeterGreitzer}*{\S~1.8}},
cf. Fig.~\ref{fig:illustr-conf-nine}(a):
\begin{thm}[Nine-point cycle]
  \label{th:nine-points}
  Let \(ABC\) be an arbitrary triangle with the orthocenter (the
  points of intersection of three altitudes) \(H\), then
  the following nine points belongs to the same cycle, which may be a
  circle or a hyperbola:
  \begin{enumerate}
    \item Foots of three altitudes, that is points of pair-wise
      intersections \(AB\) and \(CH\), \(AC\) and \(BH\), \(BC\) and \(AH\).
    \item Midpoints of sides \(AB\), \(BC\) and \(CA\).
    \item Midpoints of intervals \(AH\), \(BH\) and \(CH\).
  \end{enumerate}
\end{thm}
There are many further interesting properties,
e.g. nine-point circle is externally tangent to that triangle three
excircles and internally tangent to its incircle as it seen from
Fig.~\ref{fig:illustr-conf-nine}(a).

To adopt the statement for cycles geometry we need to find a
FLT-invariant meaning of the midpoint \(A_m\) of an interval \(BC\),
because the equality of distances \(BA_m\) and \(A_mC\) is not
FLT-invariant. The definition in cycles geometry can be done by either
of the following equivalent relations:
\begin{itemize}
\item The midpoint \(A_m\) of an interval \(BC\) is defined by the
  cross-ratio \(\frac{BA_m}{CA_m} : \frac{BI}{CI}=1\), where \(I\) is
  the point at infinity.
\item We construct the midpoint \(A_m\) of an interval \(BC\) as the
  intersection of the interval and the line orthogonal to \(BC\) and
  to the cycle, which uses \(BC\) as its diameter. The latter
  condition means that the cycle passes both points \(B\) and \(C\)
  and is orthogonal to the line \(BC\).
\end{itemize}
Both procedures are meaningful if we replace the point at infinity
\(I\) by an arbitrary fixed point \(N\) of the plane. In the second
case all lines will be replaced by cycles passing through \(N\), for
example the line through \(B\) and \(C\) shall be replaced by a cycle
through \(B\), \(C\) and \(N\). If we similarly replace ``lines'' by
``cycles passing through \(N\)'' in Thm.~\ref{th:nine-points} it turns
into a valid FLT-invariant version,
cf. Fig.~\ref{fig:illustr-conf-nine}(b). Some additional properties,
e.g. the tangency of the nine-points circle to the ex-/in-circles, are
preserved in the new version as well.  Furthermore, we can illustrate
the connection between two versions of the theorem by an animation,
where the infinity is transformed to a finite point \(N\) by a
continuous one-parameter group of FLT,
see. Fig.~\ref{fig:nine-points-anim} and further examples
at~\cite{Kisil16a}.

It is natural to test the nine-point theorem in the hyperbolic and the
parabolic spaces. Fortunately, it is very easy under the given
implementation: we only need to change the defining metric of the
point space, this can be done for an already defined figure\ifshort\else,
see~\ref{sec:example:-nine-points}\fi. The corresponding figures
Fig.~\ref{fig:illustr-conf-nine}(c) and~(d) suggest that the
hyperbolic version of the theorem is still true in the plain and even
FLT-invariant forms. We shall clarify that the hyperbolic version
of the Thm.~\ref{th:nine-points} specialises the nine-point conic of a
complete quadrilateral \cites{CerinGianella06a,DeVilliers06a}: in
addition to the existence of this conic, our theorem specifies its
type for this particular arrangement as equilateral hyperbola with the
vertical axis of symmetry.

\begin{figure}[htbp]
  \centering
  \ifelsevier
  \makebox[0pt][l]{(a)}\includegraphics[scale=.6]{nine-points-thm-plain.pdf}\hfill
  \makebox[0pt][l]{(b)}\includegraphics[scale=.6]{nine-points-thm.pdf}\\
  \makebox[0pt][l]{(c)}\includegraphics[scale=.6]{nine-points-thm-plain-hyp.pdf}\hfill
  \makebox[0pt][l]{(d)}\includegraphics[scale=.6]{nine-points-thm-hyp.pdf}
  \else
  \ifshort
  \makebox[0pt][l]{(a)}\includegraphics[scale=.58]{nine-points-thm-plain-saved.pdf}\hfill
  \makebox[0pt][l]{(b)}\includegraphics[scale=.58]{nine-points-thm-saved.pdf}\\[1em]
  \makebox[0pt][l]{(c)}\includegraphics[scale=.58]{nine-points-thm-plain-hyp-saved.pdf}\hfill
  \makebox[0pt][l]{(d)}\includegraphics[scale=.58]{nine-points-thm-hyp-saved.pdf}
  \else
  \makebox[0pt][l]{(a)}\includegraphics[scale=.8]{nine-points-thm-plain-saved.pdf}\hfill
  \makebox[0pt][l]{(b)}\includegraphics[scale=.8]{nine-points-thm-saved.pdf}\\
  \makebox[0pt][l]{(c)}\includegraphics[scale=.8]{nine-points-thm-plain-hyp-saved.pdf}\hfill
  \makebox[0pt][l]{(d)}\includegraphics[scale=.8]{nine-points-thm-hyp-saved.pdf}
  \fi
  \fi
  \caption[The illustration of the conformal nine-points theorem]
  {The illustration of the conformal nine-points theorem. The
    left column is the statement for a triangle with straight sides
    (the point [[N]] is at infinity), the right column is its
    conformal version (the point [[N]] is at the finite part). The
    first row show the elliptic point space, the second row---the
    hyperbolic point space. Thus, the top-left picture shows the
    traditional theorem, three other pictures---its different modifications.}
  \label{fig:illustr-conf-nine}
\end{figure}
\begin{figure}[htbp]
  \centering
  \animategraphics[controls=true,width=.9\textwidth]{50}{_nine-points-anim}{}{}
  \caption[Animated transition between the classical and conformal
  nine-point theorems]{Animated transition between the classical and
    conformal versions of the nine-point theorem. Use control buttons to activate
    it. You may need \textsf{Adobe Acrobat Reader} for this feature.}
  \label{fig:nine-points-anim}
\end{figure}

The computational power of the package is sufficient not only to hint
that the new theorem is true but also to make a complete proof. To
this end we define an ensemble of cycles with exactly same
interrelations, but populate the generation-0 with points \(A\), \(B\)
and \(C\) with symbolic coordinates, that is, objects of the \GiNaC\
[[class\ realsymbol]]. Thus, the entire figure defined from them will
be completely general. Then, we may define the hyperbola passing
through three bases of altitudes and check by the symbolic
computations that this hyperbola passes another six ``midpoints'' as
well\ifshort\else, see~\ref{sec:prov-theor-symb}
\fi.

In the parabolic space the nine-point Thm.~\ref{th:nine-points} is not
preserved in this manner. It is already
observed~\cites{Kisil12a,Kisil05a,%
  Kisil15a,Kisil07a,Kisil09e,Kisil11a,Mustafa17a,BarrettBolt10a}, that
the degeneracy of parabolic metric in the point space requires certain
revision of traditional definitions. The parabolic variation of
nine-point theorem may prompt some further considerations as well. An
expanded discussion of various aspects of the nine-point construction
shall be the subject of a separate paper.

\section{To Do List}
\label{sec:do}

The library is still under active development. Along with continuous
bug fixing there is an intention to extend both functionality and
usability. Here are several nearest tasks planned so far:
\begin{itemize}
\item Expand class [[subfigure]] in a way suitable for encoding
  loxodromes and other objects of an  extended M\"obius--Lie
  geometry~\cites{KisilReid18a,Kisil15a}.
\item Add non-point transformations, extending the package to Lie
  sphere geometry.
\item  Add a method which will apply a FLT
  to the entire figure.
\item Provide an effective parametrisation of solutions of a single
  quadratics condition.
\item Expand drawing facilities in three dimensions to hyperboloids
  and paraboloids.
\item Maintain and improve the Graphical User Interface which makes
  the library accessible to users without programming skills.
\item Investigate cloud computing options which can free a user from
  the burden of software installation.
\end{itemize}
Being an open-source project the library is open for contributions and
suggestions of other developers and users.

@
\section*{Acknowledgement}
\label{sec:acknowledgement}

I am grateful to Prof.~Jay~P.~Fillmore for stimulating discussion,
which enriched the library [[figure]]. Cameron Kumar wrote
.

The University of Leeds provided a generous summer internship to work
on Graphical User Interface to the library, which was initiated by
Luke Hutton with skills and enthusiasm. Cameron Kumar wrote the
initial version of a
\href{https://sourceforge.net/projects/cycle3dvis.moebinv.p/}{3D cycle
  visualiser} as a part of his BSc project at the University of Leeds.

@
% \ifshort
% \subsection*{Data accessibility
% }
% \providecommand{\myeprint}[2]{\texttt{#2}}
% \providecommand{\arXiv}[1]{\myeprint{http://arXiv.org/abs/#1}{arXiv:#1}}
% Source code of both libraries ([[cycle]] and [[figire]]) and a
% test-suit are published under GPLv3~\cite{GNUGPL} as
% \arXiv{cs.MS/0512073} and \arXiv{1512.02960}. The open code is also
% maintained at \url{http://moebinv.sourceforge.net/}.

% \subsection*{Competing interests
% }
% The author does not have competing interests.

% \subsection*{Author contribution
% }
% The whole text of the paper and the described code is written by the
% author. I have provided references to others' results to best of%'
% my knowledge.

% \subsection*{Funding statement
% }
% This project was not funded by any particular grant.

% \subsection*{Ethics statement  }
% This work did not involve any ethics-sensible material.

% \fi

@
%\bibliographystyle{plain}
\bibliography{arare,aclifford,abbrevmr,akisil,ageometry,algebra,analyse,aphysics}

@
\ifshort
\else
\newpage
\appendix

@
\textheight 26.5cm
\textwidth 18cm
\oddsidemargin -.9cm
\evensidemargin -.9cm
\topmargin -1.5cm
\renewcommand{\baselinestretch}{1}

@
\section{Examples of Usage}
\label{sec:examples}
This section presents several examples, which may be used for quick
start. We begin with very elementary one, but almost all aspects of
the library usage will be illustrated by the end of this section. See
the beginning of Section~\ref{sec:publ-meth-figure} for installation
advise. The collection of these programmes is also serving as a test
suit for the library.

@ 
<<separating chunk>>=

@
\subsection{Hello, Cycle!}
\label{sec:hello-cycle}

This is a minimalist example showing how to obtain a simple drawing of
cycles in non-Euclidean geometry. Of course, we are starting from the
library header file.
<<hello-cycle.cpp>>=
<<license>>
#include "figure.h"
<<using all namespaces>>
int main(){

@ To save keystrokes, we use the following [[namespace]]s.
<<using all namespaces>>=
using namespace std;
using namespace GiNaC;
using namespace MoebInv;
@ %def MoebInv

@ We declare the figure [[F]] which will be constructed with the
default elliptic metric in two dimensions.
<<hello-cycle.cpp>>=
	figure F;
@ %def figure

@ Next we define a couple of points [[A]] and [[B]]. Every point is
added to [[F]] by giving its explicit coordinates as a [[lst]] and a
string, which will be used to label the point. The returned value is a
\GiNaC\ expression of [[symbol]] class, which will be used as a key
of the respective point. All points are added to the zero generation.
<<hello-cycle.cpp>>=
	ex A=F.add_point(lst{-1,.5},"A");
	ex B=F.add_point(lst{1,1.5},"B");
@ %def add_point

@ Now we add a ``line'' in the Lobachevsky half-plane. It passes both
points [[A]] and [[B]] and is orthogonal to the real line. The real
line and the point at infinity were automatically added to [[F]] at
its initialisation. The real line is accessible as
[[F.get_real_line()]] method in [[figure]] class. A cycle
passes a point if it is orthogonal to the cycle defined by this
point. Thus, the line is defined through a list of three
orthogonalities~\citelist{\cite{Kisil06a} \cite{Kisil12a}*{Defn.~6.1}}
(other pre-defined relations between cycles are listed in
Section~\ref{sec:publ-meth-cycl}). We also supply a string to label
this cycle. The returned valued is a [[symbol]], which is a key for this
cycle.
<<hello-cycle.cpp>>=
	ex a=F.add_cycle_rel(lst{is_orthogonal(A),is_orthogonal(B),is_orthogonal(F.get_real_line())},"a");
@ %def add_cycle_rel get_real_line

@ Now, we draw our figure to a file. Its format (e.g. EPS, PDF, PNG,
etc.) is determined by your default \Asymptote settings. This can be
overwritten if a format is explicitly requested, see examples below.
The output is shown at Figure~\ref{fig:lobachevky-line}.
<<hello-cycle.cpp>>=
	F.asy_write(300,-3,3,-3,3,"lobachevsky-line");
	return 0;
}
@ %def asy_write

@
\begin{figure}[htbp]
  \centering
  \includegraphics[scale=.8]{lobachevsky-line.pdf}
  \caption{Lobachevky line.}
  \label{fig:lobachevky-line}
\end{figure}
@ 
<<separating chunk>>=

@
\subsection{Animated cycle}
\label{sec:animated-cycle}

We use the similar construction to make an animation.
<<hello-cycle-anim.cpp>>=
<<license>>
#include "figure.h"
<<using all namespaces>>
int main(){

@ It is preferable to [[freeze]] a figure with a symbolic parameter in
order to avoid useless but expensive symbolic computations. It will be
automatically [[unfreeze]] by [[asy_animate]] method below.
<<hello-cycle-anim.cpp>>=
	figure F=figure().freeze();
	symbol t("t");
@ %def freeze unfreeze

@ This time the point [[A]] on the figure depends from the above parameter
[[t]] and the point [[B]] is fixed as before.
<<hello-cycle-anim.cpp>>=
	ex A=F.add_point(lst{-1*t,.5*t+.5},"A");
	ex B=F.add_point(lst{1,1.5},"B");

@ The Lobachevsky line [[a]] is defined exactly as in the previous
example but is implicitly (through [[A]]) depending on [[t]] now.
<<hello-cycle-anim.cpp>>=
	ex a=F.add_cycle_rel(lst{is_orthogonal(A),is_orthogonal(B),is_orthogonal(F.get_real_line())},"a");

@ The new straight line [[b]] is defined as a cycle passing
(orthogonal to) the point at infinity. It is accessible by
[[get_infinity]] method.
<<hello-cycle-anim.cpp>>=
	ex b=F.add_cycle_rel(lst{is_orthogonal(A),is_orthogonal(B),is_orthogonal(F.get_infinity())},"b");
@ %def get_infinity

@ Now we define the set of values for the parameter [[t]] which will
be used for substitution into the figure.
<<hello-cycle-anim.cpp>>=
	lst val;
	for (int i=0; i<40; ++i)
		val.append(t==numeric(i+2,30));

@ Finally animations in different formats are created similarly to the
static picture from the previous example.
<<hello-cycle-anim.cpp>>=
	F.asy_animate(val,500,-2.2,3,-2,2,"lobachevsky-anim","mng");
	F.asy_animate(val,300,-2.2,3,-2,2,"lobachevsky-anim","pdf");
	return 0;
}
@ %def asy_animate

@ The second command creates two files: \verb|lobachevsky-anim.pdf|
and \verb|_lobachevsky-anim.pdf| (notice the underscore (\verb|_|) in
front of the file name, which makes the difference). The former is a
stand-alone PDF file containing the desired animation. The latter may
be embedded into another PDF document as shown on
Fig.~\ref{fig:lobachevsky-anim}. To this end the \LaTeX\ file need to
have the command
\begin{verbatim}
\usepackage{animate}
\end{verbatim}
in its preamble. To include the animation we use the command:
\begin{verbatim}
\animategraphics[controls]{50}{_lobachevsky-anim}{}{}
\end{verbatim}
More options can be found in the
\href{rors.ctan.org/macros/latex/contrib/animate/animate.pdf}{documentation
  of \texttt{animate} package}.
Finally, the \LaTeX\ file need to be compiled with the
\texttt{pdf}\LaTeX\ command.
\begin{figure}[htbp]
  \centering
  \animategraphics[controls]{50}{_lobachevsky-anim}{}{}
  \caption[Animated Lobachevsky line]{Animated Lobachevsky line: use
    the control buttons to run the animation. You may need
    \textsf{Adobe Acrobat Reader} for this feature.}
  \label{fig:lobachevsky-anim}
\end{figure}
@ 
<<separating chunk>>=

@
\subsection{An illustration of the modular group action}
\label{sec:an-illustr-modul}

The library allows to build figures out of cycles which are obtained
from each other by means of FLT. We are going to
illustrate this by the action of the modular group
\(\mathrm{SL}_2(\mathbb{Z})\) on a single
circle~\cite{StewartTall02a}*{\S~14.4}. We repeatedly apply FLT \(T=
\begin{pmatrix}
  1&1\\0&1
\end{pmatrix}\)
for translations and \(S=
\begin{pmatrix}
  0&-1\\1&0
\end{pmatrix}\) for the inversion in the unit circle.

@ Here is the standard start of a programme with some additional
variables being initialised.
<<modular-group.cpp>>=
<<license>>
#include "figure.h"
<<using all namespaces>>
int main(){
	char buffer [50];
	int steps=3, trans=15;
	double epsilon=0.00001; // square of radius for a circle to be ignored
	figure F;

@ We will use the metric associated to the figure, it can be extracted
by [[get_point_metric]] method.
<<modular-group.cpp>>=
	ex e=F.get_point_metric();

@ %def get_point_metric

@ Firstly, we add to the figure an initial cycle and, then, add new
generations of its shifts and reflections.
<<modular-group.cpp>>=
	ex a=F.add_cycle(cycle2D(lst{0,numeric(3,2)},e,numeric(1,4)),"a");
	ex c=F.add_cycle(cycle2D(lst{0,numeric(11,6)},e,numeric(1,36)),"c");
	for (int i=0; i<steps;++i) {

@ We want to shift all cycles in the previous
generation. Their key are grasped by [[get_all_keys]] method.
<<modular-group.cpp>>=
		lst L=ex_to<lst>(F.get_all_keys(2*i,2*i));
		if (L.nops() == 0) {
			cout << "Terminate on iteration " << i << endl;
			break;
		}
@ %def get_all_keys

@ Each cycle with the collected key is shifted horizontally by an
integer \(t\) in range [\(-\)[[trans]],[[trans]]{}]. This done by
[[moebius_transform]] relations and it is our responsibility to
produce proper Clifford-valued entries to the matrix,
see~\cite{Kisil05a}*{\S~2.1} for an advise.
<<modular-group.cpp>>=
		for (const auto& ck: L) {
			lst L1=ex_to<lst>(F.get_cycles(ck));
			for (auto x: L1) {
				for (int t=-trans; t<=trans;++t) {
					sprintf (buffer, "%s-%dt%d",ex_to<symbol>(ck).get_name().c_str(),i,t);

@ We shift initial cycles by zero in order to have their copies in the this generation.
<<modular-group.cpp>>=
					if ((t !=0 || i ==0)

@ To simplify the picture we are skipping circles whose radii would be
smaller than the threshold.
<<modular-group.cpp>>=
						&& ! ((ex_to<cycle>(x).det()-(pow(t,2)-1)*epsilon).evalf()<0)){
						ex b=F.add_cycle_rel(moebius_transform(ck,true,
															   lst{dirac_ONE(),t*e.subs(e.op(1).op(0)==0),0,dirac_ONE()}),buffer);
@ %def moebius_transform

@ We want the colour of a cycle reflect its generation, smaller cycles
also need to be drawn by a finer pen. This can be set for each cycle
by [[set_asy_style]] method.
<<modular-group.cpp>>=
						sprintf (buffer, "rgb(0,0,%.2f)+%.3f" ,1-1/(i+1.),1/(i+1.5));
						F.set_asy_style(b,buffer);
					}
				}
			}
		}
@ %def set_asy_style rgb

@ Similarly, we collect all key from the previous generation cycles
to make their reflection in the unit circle.
<<modular-group.cpp>>=
		if (i<steps-1)
			L=ex_to<lst>(F.get_all_keys(2*i+1,2*i+1));
		else
			L=lst{};
		for (const auto& ck: L) {
			sprintf (buffer, "%ss",ex_to<symbol>(ck).get_name().c_str());

@ This time we keep things simple and are using [[sl2_transform]]
relation, all Clifford algebra adjustments are taken by the
library. The drawing style is setup accordingly.
<<modular-group.cpp>>=
			ex b=F.add_cycle_rel(sl2_transform(ck,true,lst{0,-1,1,0}),buffer);
			sprintf (buffer, "rgb(0,0.7,%.2f)+%.3f" ,1-1/(i+1.),1/(i+1.5));
			F.set_asy_style(b,buffer);
		}
	}
@ %def sl2_transform


@ Finally, we draw the picture. This time we do not want cycles label
to appear, thus the last parameter [[with_labels]] of [[asy_write]] is
[[false]]. We also want to reduce the size of \Asymptote\ file and
will not print headers of cycles, thus specifying
[[with_header=true]]. The remaining parameters are explicitly assigned
their default values.
<<modular-group.cpp>>=
	ex u=F.add_cycle(cycle2D(lst{0,0},e,numeric(1)),"u");
	F.asy_write(300,-2.17,2.17,0,2,"modular-group","pdf",default_asy,default_label,true,false,0,"rgb(0,.9,0)+4pt",true,false);
	return 0;
}
@ %def asy_write

@ 
<<separating chunk>>=

@
\subsection{Simple analysitcal demonstration  }
\label{sec:simple-analys-demons}

The following example essentially repeats the code from
Example~\ref{ex:touch-centres-collinear}. It will be better to start
from a simpler case before we will consider more advanced usage in the
next subsection. Also this example checks how cycle solver is handling
cycles with free parameters if relations do not determine it uniquely.

The first line creates an empty figure [[F]] with the default
euclidean metric.
<<figure-ortho-anlytic-proof.cpp>>=
<<license>>
#include "figure.h"
<<using all namespaces>>
int main(){
	figure F=figure();

@ The next line explicitly uses parameters \((1,0,0,-1)\) of [[a]] to add it to [[F]].
<<figure-ortho-anlytic-proof.cpp>>=
	ex a=F.add_cycle(cycle2D(1,lst{0,0},-1),"a");

@ Next lines define symbols [[l]] and [[C]], which are needed because
cycles with these labels are defined in next lines through some
relations to themselves and the cycle [[a]].
<<figure-ortho-anlytic-proof.cpp>>=
	ex l=symbol("l");
	ex C=symbol("C");

@ In both cases we want to have cycles with real
coefficients only and [[C]] is additionally self-orthogonal (i.e. is a
zero-radius). Also, [[l]] is orthogonal to infinity (i.e. is a line)
and [[C]] is orthogonal to [[a]] and [[l]] (i.e. is their common
point). The tangency condition for [[l]] and self-orthogonality of
[[C]] are both quadratic relations. The former has two solutions each
depending on one real parameter, thus line [[l]] has two
instances.
<<figure-ortho-anlytic-proof.cpp>>=
	F.add_cycle_rel(lst{is_tangent_i(a),is_orthogonal(F.get_infinity()),only_reals(l)},l);

@ Correspondingly, the point of contact [[C]]\ldots
<<figure-ortho-anlytic-proof.cpp>>=
	F.add_cycle_rel(lst{is_orthogonal(C),is_orthogonal(a),is_orthogonal(l),only_reals(C)},C);

@ \ldots and the orthogonal cycle [[r]] through [[C]] (defined in line~7) each have two
instances as well.
<<figure-ortho-anlytic-proof.cpp>>=
	ex r=F.add_cycle_rel(lst{is_orthogonal(C),is_orthogonal(a)},"r");

@  Finally, we  verify that every instance of [[l]] is orthogonal to
the respective instance of [[r]].
<<figure-ortho-anlytic-proof.cpp>>=
	ex Res=F.check_rel(l, r, cycle_orthogonal);
@ %def check_rel

@ This is assisted by the trigonometric substitution \(\cos^2(*)=1-\sin^2(*)\)
used for parameters of [[l]].
<<figure-ortho-anlytic-proof.cpp>>=
	for (size_t i=0; i< Res.nops(); ++i) {
		cout << "Tangent and radius are orthogonal: " << boolalpha
			 << bool(ex_to<relational>(Res.op(i).subs(pow(cos(wild(0)),2)==1-pow(sin(wild(0)),2)).normal()))
			 << endl;
	}

@ The output predictably is:
\begin{verbatim}
Tangent and circle r are orthogonal: true
Tangent and circle r are orthogonal: true
\end{verbatim}

@ An additional check. We add a point \((1,0)\) on [[c]]\ldots
<<figure-ortho-anlytic-proof.cpp>>=
	ex B=F.add_cycle(cycle2D(lst{1,0}),"B");

@ \ldots and a generic cycle touching to [[c]] at [[B]].
<<figure-ortho-anlytic-proof.cpp>>=
	ex b=symbol("b");
	F.add_cycle_rel(lst{is_tangent(a),is_orthogonal(B),only_reals(b)}, b);

@ Add zero-radius cycles at the centres of [[a]] and [[b]]\ldots
<<figure-ortho-anlytic-proof.cpp>>=
	ex Ca=F.add_cycle(cycle2D(ex_to<lst>(ex_to<cycle2D>(F.get_cycles(a).op(0)).center())),"Ca");
	ex Cb=F.add_cycle(cycle2D(ex_to<lst>(ex_to<cycle2D>(F.get_cycles(b).op(0)).center())),"Cb");

@ \ldots and then a cycle passing two centres and the contact point.
<<figure-ortho-anlytic-proof.cpp>>=
	ex d=F.add_cycle_rel(lst{is_orthogonal(B), is_orthogonal(Ca), is_orthogonal(Cb)},"d");

@ Finally check that the cycle [[d]] is a line (passes the infinity).
<<figure-ortho-anlytic-proof.cpp>>=
	Res = F.check_rel(d, F.get_infinity(), cycle_orthogonal);
	for (size_t i=0; i< Res.nops(); ++i)
		cout << "Centres and the contact point are collinear: "
			 << bool(ex_to<relational>(Res.op(i)))
			 << endl;
}

@ The output, as expected, is:
\begin{verbatim}
Centres and the contact point are collinear: true
\end{verbatim}
@ 
<<separating chunk>>=

@
\subsection{The nine-points theorem---conformal version}
\label{sec:example:-nine-points}

Here we present further usage of the library by an aesthetically
attractive example, see Section~\ref{sec:mathematical-results}.

@ The start of our file is minimalistic, we definitely need to
include the header of [[figure]] library.
<<nine-points-thm.cpp>>=
<<license>>
#include "figure.h"
<<using all namespaces>>
int main(){
	<<initial data for drawing>>
	<<build medioscribed cycle>>

@ We define exact coordinates of points which will be used for our picture.
<<initial data for drawing>>=
	numeric x1(-10,10), y1(0,1), x2(10,10), y2(0,1), x3(-1,5), y3(-3,2), x4(1,2), y4(-5,2);
	int sign=-1;
@ %def numeric

@ We declare the figure [[F]] which will be constructed.
<<build medioscribed cycle>>=
	figure F(lst{-1,sign});
@ %def figure

@ We will need several ``midpoints'' in our constructions, the
corresponding figure [[midpoint_constructor]] is readily available
from the library.
<<build medioscribed cycle>>=
	figure SF=ex_to<figure>(midpoint_constructor());

@ Next we define vertices of the ``triangle'' [[A]], [[B]], [[C]] and
the point [[N]] which will be an image if infinity. Every point is
added to [[F]] by giving its explicit coordinates and a string, which
will used to label it. The returned value is a \GiNaC\ expression of
[[symbol]] class which will be used as the key of a respective
point. All points are added to the zero generation.
<<build medioscribed cycle>>=
	ex A=F.add_point(lst{x1,y1},"A");
	ex B=F.add_point(lst{x2, y2},"B");
	ex C=F.add_point(lst{x3,y3},"C");
@ %def add_point

@ There is the special point in the construction, which play the role
of infinity. We first put this as cycle at infinity to make picture simple.
<<build medioscribed cycle>>=
	ex N=F.add_cycle(cycle_data(0,lst{0,0},1),"N");
@ %def add_cycle cycle_data

@ This is an alternative selection of point with [[N]] being at the
centre of the triangle.
<<build medioscribed cycle>>=
	//Fully symmetric data
	// ex A=F.add_point(lst{-numeric(10,10},numeric(0,1)),"A")
	// ex B=F.add_point(lst{numeric(10,10},numeric(0,1)),"B")
	// ex C=F.add_point(lst{numeric(0,4},-numeric(1732050807,1000000000)),"C")
	// ex N=F.add_point(lst{numeric(0,4},-numeric(577350269,1000000000)),"N")

@ Now we add ``sides'' of the triangle, that is cycles passing two
vertices and [[N]]. A cycle passes a point if it is orthogonal to the
cycle defined by this point. Thus, each side is defined through a list
of three orthogonalities~\citelist{\cite{Kisil06a}
  \cite{Kisil12a}*{Defn.~6.1}}. We also supply a string to label this
side. The returned valued is a [[symbol]] which is a key for this cycle.
<<build medioscribed cycle>>=
	ex a=F.add_cycle_rel(lst{is_orthogonal(B),is_orthogonal(C),is_orthogonal(N)},"a");
	ex b=F.add_cycle_rel(lst{is_orthogonal(A),is_orthogonal(C),is_orthogonal(N)},"b");
	ex c=F.add_cycle_rel(lst{is_orthogonal(A),is_orthogonal(B),is_orthogonal(N)},"c");
@ %def add_cycle_rel is_orthogonal

@ We define the custom \Asymptote~\cite{Asymptote} drawing style for
sides of the triangle: the dark blue ([[rgb]] colour (0,0,0.8)) and line thickness 1pt.
<<build medioscribed cycle>>=
	F.set_asy_style(a,"rgb(0,0,.8)+1");
	F.set_asy_style(b,"rgb(0,0,.8)+1");
	F.set_asy_style(c,"rgb(0,0,.8)+1");
@ %def set_asy_style rgb

@ Now we drop ``altitudes'' in our triangle, that is again
provided through three orthogonality relations. They will be draw as
dashed lines.
<<build medioscribed cycle>>=
	   ex ha=F.add_cycle_rel(lst{is_orthogonal(A),is_orthogonal(N),is_orthogonal(a)},"h_a");
	F.set_asy_style(ha,"dashed");
	ex hb=F.add_cycle_rel(lst{is_orthogonal(B),is_orthogonal(N),is_orthogonal(b)},"h_b");
	F.set_asy_style(hb,"dashed");
	ex hc=F.add_cycle_rel(lst{is_orthogonal(C),is_orthogonal(N),is_orthogonal(c)},"h_c");
	F.set_asy_style(hc,"dashed");

@ We need the base of altitude [[ha]], which is the intersection points
of the side [[a]]  and respective altitude [[ha]]. A point can be can
be characterised as a cycle which is orthogonal to
itself~\citelist{\cite{Kisil12a}*{Defn.~5.13} \cite{Kisil06a}}. To
define a relation of a cycle to itself we first need to define a
symbol [[A1]] and then add a cycle with the key [[A1]] and the
relation [[is_orthogonal]] to [[A1]]. Finally, there are two such
points: the base of altitude and [[N]]. To exclude the second one we
add the relation [[is_adifferent]] (``almost different'') to [[N]].
<<build medioscribed cycle>>=
	ex A1=symbol("A_h");
 F.add_cycle_rel(lst{is_orthogonal(a),is_orthogonal(ha),is_orthogonal(A1),is_adifferent(N)},A1);
@ %def is_adifferent

@ Two other bases of altitude are defined in a similar manner.
<<build medioscribed cycle>>=
	ex B1=symbol("B_h");
 F.add_cycle_rel(lst{is_orthogonal(b),is_orthogonal(hb),is_adifferent(N),is_orthogonal(B1)},B1);
	ex C1=symbol("C_h");
	F.add_cycle_rel(lst{is_adifferent(N),is_orthogonal(c),is_orthogonal(hc),is_orthogonal(C1)},C1);

@ We add the cycle passing all three bases of altitudes.
<<build medioscribed cycle>>=
	ex p=F.add_cycle_rel(lst{is_orthogonal(A1),is_orthogonal(B1),is_orthogonal(C1)},"p");
	F.set_asy_style(p,"rgb(0,.8,0)+1");

@ We build ``midpoint'' of the arc of [[a]] between [[B]] and
[[C]]. To this end we use subfigure [[SF]] and supply the list of
parameters [[B]], [[C]] and [[N]] (``infinity'') which are required
by [[SF]].
<<build medioscribed cycle>>=
	ex A2=F.add_subfigure(SF,lst{B,C,N},"A_m");
@ %def add_subfigure

@ Similarly we build other two ``midpoints'', they all will belong to
the cycle [[p]].
<<build medioscribed cycle>>=
	ex B2=F.add_subfigure(SF,lst{C,A,N},"B_m");
	ex C2=F.add_subfigure(SF,lst{A,B,N},"C_m");

@ [[O]] is the intersection point of altitudes [[ha]] and [[hb]],
again it is defined as a cycle with key [[O]] orthogonal to itself.
<<build medioscribed cycle>>=
	ex O=symbol("O");
 F.add_cycle_rel(lst{is_orthogonal(ha),is_orthogonal(hb),is_orthogonal(O),is_adifferent(N)},O);

@ We build three more ``midpoints'' which belong to [[p]] as well.
<<build medioscribed cycle>>=
	ex A3=F.add_subfigure(SF,lst{O,A,N},"A_d");
	ex B3=F.add_subfigure(SF,lst{B,O,N},"B_d");
	ex C3=F.add_subfigure(SF,lst{C,O,N},"C_d");

	<<check the theorem>>

@ Now we want to check that the six additional points all belong to
the build cycle [[p]]. The list of pre-defined conditions which may be
checked is listed in Section~\ref{sec:check-relat-betw}.
<<check the theorem>>=
	cout << "Midpoint BC belongs to the cycle: " <<  F.check_rel(p,A2,cycle_orthogonal) << endl;
	cout << "Midpoint AC belongs to the cycle: " <<  F.check_rel(p,B2,cycle_orthogonal) << endl;
	cout << "Midpoint AB belongs to the cycle: " <<  F.check_rel(p,C2,cycle_orthogonal) << endl;
	cout << "Midpoint OA belongs to the cycle: " << F.check_rel(p,A3,cycle_orthogonal) << endl;
	cout << "Midpoint OB belongs to the cycle: " <<  F.check_rel(p,B3,cycle_orthogonal) << endl;
	cout << "Midpoint OC belongs to the cycle: " <<  F.check_rel(p,C3,cycle_orthogonal) << endl;
@ %def check_rel

@ We inscribe the cycle [[va]] into the triangle through the relation
[[is_tangent_i]] (that is ``tangent from inside'') and [[is_tangent_]]
(that is ``tangent from outside'')to sides of the triangle. We also
provide custom \Asymptote\ drawing style: dar red colour and line
thickness 0.5pt.
<<nine-points-thm.cpp>>=
	ex va=F.add_cycle_rel(lst{is_tangent_o(a),is_tangent_i(b),is_tangent_i(c)},"v_a");
	F.set_asy_style(va,"rgb(0.8,0,0)+.5");
@ %def is_tangent_o  is_tangent_i

@ Similarly we define two other tangent cycles: touching two sides
from inside and  the third from outside (the relation
[[is_tangent_o]]). We also define custom \Asymptote\ styles for the
new cycles.
<<nine-points-thm.cpp>>=
	ex vb=F.add_cycle_rel(lst{is_tangent_i(a),is_tangent_o(b),is_tangent_i(c)},"v_b");
	F.set_asy_style(vb,"rgb(0.8,0,0)+.5");
	ex vc=F.add_cycle_rel(lst{is_tangent_i(a),is_tangent_i(b),is_tangent_o(c)},"v_c");
	F.set_asy_style(vc,"rgb(0.8,0,0)+.5");
	<<check that cycles are tangent>>

@ We also want to check the touching property between cycles:
<<check that cycles are tangent>>=
	cout << "p and va are tangent: " <<  F.check_rel(p,va,check_tangent).evalf() << endl;
	cout << "p and vb are tangent: " <<  F.check_rel(p,vb,check_tangent).evalf() << endl;
	cout << "p and vc are tangent: " <<  F.check_rel(p,vc,check_tangent).evalf() << endl;

@ Now, we draw our figure to the PDF and PNG files, it is shown at
Figure~\ref{fig:illustr-conf-nine}.
<<nine-points-thm.cpp>>=
	F.asy_write(300,-3.1,2.4,-3.6,1.3,"nine-points-thm-plain", "pdf");
	F.asy_write(600,-3.1,2.4,-3.6,1.3,"nine-points-thm-plain", "png");
@ %def asy_write

@ We also can modify a cycle at zero level by [[move_point]]. This
time we restore the initial value of [[N]] as a debug check: this is a
transition from a pre-defined [[cycle]] given above to a point
(which is a calculated object due to the internal representation).
<<nine-points-thm.cpp>>=
	F.move_point(N,lst{numeric(1,2),-numeric(5,2)});
	cerr << F << endl;
	F.asy_draw(cout,cerr,"",-3.1,2.4,-3.6,1.3);

	F.asy_write(300,-3.1,2.4,-3.6,1.3,"nine-points-thm", "pdf");
	F.asy_write(600,-3.1,2.4,-3.6,1.3,"nine-points-thm", "png");
	<<check the theorem>>
	<<check that cycles are tangent>>
@ %def move_point

@ And now we use [[move_point]] to change coordinates of the point
(without a change of its type).
<<nine-points-thm.cpp>>=
	F.move_point(N,lst{numeric(4,2),-numeric(5,2)});
	F.asy_write(300,-3.1,2.4,-3.6,1.3,"nine-points-thm2");
	<<check the theorem>>
	<<check that cycles are tangent>>

@ Then, we move the cycle [[N]] to represent the point at infinity [[(0,lst{0,0},1)]],
thus the drawing becomes the classical Nine Points Theorem in
Euclidean geometry.
<<nine-points-thm.cpp>>=
	F.move_cycle(N, cycle_data(0,lst{0,0},1));
	F.asy_write(300,-3.1,2.4,-3.6,1.3,"nine-points-thm1");
	<<check the theorem>>
	<<check that cycles are tangent>>
@ %def move_cycle  cycle_data

@ We can draw the same figures in the hyperbolic metric as well. The
checks show that the nine-point theorem is still valid!
<<nine-points-thm.cpp>>=
	F.move_cycle(N, cycle_data(0,lst{0,0},1));
	F.set_metric(diag_matrix(lst{-1,1}));
	F.asy_write(300,-3.1,2.4,-3.6,1.3,"nine-points-thm-plain-hyp");
	<<check the theorem>>
	<<check that cycles are tangent>>
	F.move_point(N,lst{numeric(1,2),-numeric(5,2)});
	F.asy_write(300,-3.1,2.4,-3.6,1.3,"nine-points-thm-hyp", "pdf");
	F.asy_write(600,-3.1,2.4,-3.6,1.3,"nine-points-thm-hyp","png");
	<<check the theorem>>
	<<check that cycles are tangent>>
	//F.set_metric(diag_matrix(lst{-1,0}));
	//F.asy_write(300,-3.1,2.4,-3.6,1.3,"nine-points-thm-par", "pdf");

@ Finally, we produce an animation, which illustrate the transition
from the traditional nine-point theorem to its conformal version. To
this end we return to the elliptic metric and freeze the figure. This
can be time-consuming and may be not performed by default.
<<nine-points-thm.cpp>>=
	 if (true) {
		F.set_metric(diag_matrix(lst{-1,-1}));
		F.freeze();

@ We define a symbolic parameter [[t]] and make the point [[N]] depends on it.
<<nine-points-thm.cpp>>=
		realsymbol t("t");
		F.move_point(N,lst{(1.0+t)/2.0,-(5.0+t)/2.0});

@ Then, the range of values [[val]] for the parameter [[t]] and then
produce an animation based on these values. The resulting animation is
presented on the Fig.~\ref{fig:nine-points-anim}.
<<nine-points-thm.cpp>>=
		lst val;
		 int num=50;
		for (int i=0;i<=num;++i)
			val.append(t==exp(pow(2.2*(num-i)/num,2.2))-1.0);
		F.asy_animate(val,300,-3.1,2.4,-3.6,1.3,"nine-points-anim", "pdf");
	}

@  We produce an illustration of [[SF]] in the canonical position. Everything is done now.
<<nine-points-thm.cpp>>=
	return 0;
}
@ 
<<separating chunk>>=

@
<<*>>=
<<nine-points-thm.cpp>>

@
\subsection{Proving the theorem: Symbolic computations}
\label{sec:prov-theor-symb}

@
<<nine-points-thm-symb.cpp>>=
<<license>>
#include "figure.h"
<<using all namespaces>>
int main(){
	cout << "Prooving the theorem, this shall take a long time..."
		 << endl;
	<<initial data for proof>>
	<<build medioscribed cycle>>

@ We define variables from [[realsymbol]] class to be used in symbolic computations.
<<initial data for proof>>=
	realsymbol x1("x1"), y1("y1"), x2("x2"), y2("y2"), x3("x3"), y3("y3"), x4("x4"), y4("y4");
@ %def realsymbol

@ We also define the sign for the hyperbolic metric. The proof will
work in the elliptic (conformal Euclidean) space as well, however we
have synthetic poofs in this case. Symbolic computations in the
hyperbolic space are mathematically sufficient for demonstration, but
Figure~\ref{fig:illustr-conf-nine} from the previous subsection is
physiologically more convincing on the individual level. A synthetic
proof for hyperbolic space would be interesting to obtain as well.
<<initial data for proof>>=
	int sign=1;

@ We got the output, which make a full demonstration that the theorem
holds in the hyperbolic space as well:
\begin{verbatim}
Midpoint BC belongs to the cycle {0==0}
Midpoint AC belongs to the cycle {0==0}
Midpoint AB belongs to the cycle {0==0}
Midpoint OA belongs to the cycle {0==0}
Midpoint OB belongs to the cycle {0==0}
Midpoint OC belongs to the cycle {0==0}
\end{verbatim}
But be prepared, that that will take a long time (about 6 hours of CPU time of my slow PC).
<<nine-points-thm-symb.cpp>>=
	return 0;
}
@ 
<<separating chunk>>=

@
\subsection{Numerical relations}
\label{sec:numerical-relations}

@ To illustrate the usage of relations with numerical parameters we are
solving the following problem
from~\cite{FillmoreSpringer00a}*{Problem~A}:
\begin{quote}
  Find the cycles having (all three conditions):
  \begin{itemize}
  \item tangential distance \(7\) from the circle
    \begin{displaymath}
      (u-7)^2+(v-1)^2=2^2;
    \end{displaymath}
  \item angle \(\arccos \frac{4}{5}\) with the circle
    \begin{displaymath}
      (u-5)^2+(v-3)^2=5^2;
    \end{displaymath}
  \item centres lying on the line
    \begin{displaymath}
      \frac{5}{13} u + \frac{12}{13} v=0.
    \end{displaymath}
  \end{itemize}
\end{quote}
The statement of the problem uses orientation of cycles. Geometrically
it is given by the inward or outward direction of the normal. In our
library the orientation represented by the direction of the vector in
the projective space, it changes to the opposite if the vector is
multiplied by \(-1\).

@ The start of of our code is similar to the previous one.
<<fillmore-springer-example.cpp>>=
<<license>>
#include "figure.h"
<<using all namespaces>>
int main(){
	ex sign=-numeric(1);
	varidx nu(symbol("nu", "\\nu"), 2);
	ex e = clifford_unit(nu, diag_matrix(lst{-numeric(1),sign}));
	figure F(e);

@ Now we define three circles given in the problem statement above.
<<fillmore-springer-example.cpp>>=
	ex A=F.add_cycle(cycle(lst{numeric(7),numeric(1)},e,numeric(4)),"A");
	ex B=F.add_cycle(cycle(lst{numeric(5),numeric(3)},e,numeric(25)),"B");
	ex C=F.add_cycle(cycle(numeric(0),lst{numeric(5,13),numeric(12,13)},0,e),"C");

@ All given data will be drawn in black inc.
<<fillmore-springer-example.cpp>>=
	F.set_asy_style(A,"rgb(0,0,0)");
	F.set_asy_style(B,"rgb(0,0,0)");
	F.set_asy_style(C,"rgb(0,0,0)");

@ The solution [[D]] is a circle defined by the three above
conditions. The solution will be drawn in red.
<<fillmore-springer-example.cpp>>=
	realsymbol D("D"), T("T");
 F.add_cycle_rel(lst{tangential_distance(A,true,numeric(7)), // The tangential distance to [[A]] is  7
							 make_angle(B,true,numeric(4,5)), // The angle with [[B]] is  arccos(4/5)
							 is_orthogonal(C), // If the centre is on [[C]], then [[C]] and [[D]] are orthogonal
			 is_real_cycle(D)}, D); // We require [[D]] be a real circle, as there are two imaginary solutions as well
	F.set_asy_style(D,"rgb(0.7,0,0)");
@ %def tangential_distance make_angle is_real_cycle

@ The output tells parameters of two solutions:
\begin{verbatim}
  Solutions: {(-1.0, [0,0]~D, 0.99999999999999999734),
(-0.0069444444444444444444, [-0.089285714285714285705,0.037202380952380952383]~D, -1.0)}
\end{verbatim}
Here, as in [[cycle]] library, the set of four numbers \((k,[l,n],m)\)
represent the circle equation \(k(u^2+v^2)-2lu-2nv+m=0\).
<<fillmore-springer-example.cpp>>=
    cout << "Solutions: "<< F.get_cycles(D).evalf() << endl;

@ To visualise the tangential distances we may add the joint tangent
lines to the figure. Some solutions are lines with imaginary
coefficients, to avoid them we use [[only_reals]] condition. The
tangents will be drawn in blue inc.
<<fillmore-springer-example.cpp>>=
	F.add_cycle_rel(lst{is_tangent_i(D),is_tangent_i(A),is_orthogonal(F.get_infinity()),only_reals(T)},T);
	F.set_asy_style(T,"rgb(0,0,0.7)");
@ %def only_reals

@ Finally we draw the picture, see
Fig.~\ref{fig:illustr-fillm-spring}, which shall be compared
with~\cite{FillmoreSpringer00a}*{Fig.~1}.
<<fillmore-springer-example.cpp>>=
	F.asy_write(400,-4,20,-12.5,9,"fillmore-springer-example");

@ Out of curiosity we may want to know that is square of tangents
intervals which are separate circles [[A]], [[D]]. The output is:
\begin{verbatim}
Sq. cross tangent distance: {41.000000000000000003,-7.571428571428571435}
\end{verbatim}
Thus one solution does have such tangents with length \(\sqrt{41}\),
and for the second solution such tangents are imaginary since the
square is negative. This happens because one solution [[D]] intersects [[A]].
<<fillmore-springer-example.cpp>>=
	cout << "Sq. cross tangent distance: " << F.measure(D,A,sq_cross_t_distance_is).evalf() << endl;
   return 0;
}
@ %def measure sq_cross_t_distance_is

@
\begin{figure}[htbp]
  \centering
  \includegraphics[scale=.7]{fillmore-springer-example.pdf}
  \caption[The illustration to Fillmore--Springer example]{The
    illustration to Fillmore--Springer example, which may be compared
    with~\cite{FillmoreSpringer00a}*{Fig.~1}.}
  \label{fig:illustr-fillm-spring}
\end{figure}
@ 
<<separating chunk>>=

@
\subsection{Three-dimensional examples}
\label{sec:an-example-calc}

@ The most of the library functionality (except graphical methods) is
literally preserved for quadrics in arbitrary dimensions. We
demonstrate this on the following stereometric problem of
\href{https://en.wikipedia.org/wiki/Problem_of_Apollonius}{Apollonius
  type}, cf.~\cite{FillmoreSpringer00a}*{\S~8}. Let four spheres of
equal radii \(R\) %\(\frac{\sqrt{3}}{2}\)
have centres at four points \((1,1,1)\), \((-1,-1,1)\), \((-1,1,-1)\),
\((1,-1,-1)\). These points are vertices of a regular
\href{https://en.wikipedia.org/wiki/Platonic_solid}{tetrahedron} and
are every other vertices of a cube with the diagonal \(2\sqrt{3}\).

There are two obvious spheres with the centre at the
origin \((0,0,0)\) touching all four given spheres, they have radii
\(R+\sqrt{3}\) and \(\sqrt{3}-R\). Are there any others?

@ We start from the standard initiation and define the metric of three
dimensional Euclidean space.
<<3D-figure-example.cpp>>=
<<3D-figure-example-common>>

@ The following two chunks are shared with the next example.
<<3D-figure-example-common>>=
<<license>>
#include "figure.h"
<<using all namespaces>>
int main(){
	ex e3D = clifford_unit(varidx(symbol("lam"), 3), diag_matrix(lst{-1,-1,-1})); // Metric for 3D space
	possymbol R("R");
	figure F(e3D);

@ Then we put four given spheres to the figure. They are defined by
their centres and square of radii.
<<3D-figure-example-common>>=
	/* Numerical radii */
	/*	ex P1=F.add_cycle(cycle(lst{1,1,1}, e3D, numeric(3,4)), "P1");
	ex P2=F.add_cycle(cycle(lst{-1,-1,1}, e3D, numeric(3,4)), "P2");
	ex P3=F.add_cycle(cycle(lst{1,-1,-1}, e3D, numeric(3,4)), "P3");
	ex P4=F.add_cycle(cycle(lst{-1,1,-1}, e3D, numeric(3,4)), "P4");
	*/
	ex P1=F.add_cycle(cycle(lst{1,1,1}, e3D, pow(R,2)), "P1");
	ex P2=F.add_cycle(cycle(lst{-1,-1,1}, e3D, pow(R,2)), "P2");
	ex P3=F.add_cycle(cycle(lst{1,-1,-1}, e3D, pow(R,2)), "P3");
	ex P4=F.add_cycle(cycle(lst{-1,1,-1}, e3D, pow(R,2)), "P4");

@ Then we introduce the unknown cycle by the four tangency
conditions to given spheres. We also put two conditions to rule out
non-geometric solutions: [[is_real_cycle]] checks that the radius is
real, [[only_reals]] requires that all coefficients are real.
<<3D-figure-example.cpp>>=
	realsymbol N3("N3");
	F.add_cycle_rel(lst{is_tangent(P1), is_tangent(P2), is_tangent(P3),is_tangent(P4)
						/* Tests below forbid all spheres with symbolic parameters */
						//, only_reals(N3), is_real_cycle(N3)
			 }, N3);
@ %def is_tangent is_real_cycle only_reals

@ Then we output the solutions and their radii.
<<3D-figure-example.cpp>>=
	lst L=ex_to<lst>(F.get_cycles(N3));
	cout << L.nops() << " spheres found" << endl;
        for (auto x: L)
		cout << "Sphere: " << ex_to<cycle>(x).normal()
		 << ", radius sq: " << (ex_to<cycle>(x).det()).normal()
		 <<endl;
	return 0;
}

@ For the numerical value \(R=\frac{\sqrt{3}}{2}\), the program found
\(16\) different solutions which satisfy to [[is_real_cycle]] and
[[only_reals]] conditions. If we omit these conditions then additional
\(16\) imaginary spheres will be producing (\(32\) in total).

For the symbolic radii \(R\) again \(32\) different spheres are
found. The condition [[only_reals]] leaves only two obvious spheres,
discussed at the beginning of the subsection. This happens because for
some value of \(R\) coefficient of other spheres may turn to be
complex. Finally, if we use the condition [[is_real_cycle]], then no
sphere passes it---the square of its radius may become negative for
some \(R\).

@ For visualisation we can partially re-use the previous code.
<<3D-figure-visualise.cpp>>=
<<3D-figure-example-common>>

@ To simplify the structure we eliminate spheres which are different
only up to the rotational symmetry of the initial set-up. To this end
we explicitly specify inner or outer tangency for different spheres.
<<3D-figure-visualise.cpp>>=
	realsymbol N0("N0"), N1("N1"), N2("N2"), N3("N3"),  N4("N4");
	F.add_cycle_rel(lst{is_tangent_o(P1), is_tangent_o(P2), is_tangent_o(P3),is_tangent_o(P4),
				is_real_cycle(N0), only_reals(N0)}, N0);
	F.add_cycle_rel(lst{is_tangent_o(P1), is_tangent_o(P2), is_tangent_o(P3),is_tangent_i(P4),
				is_real_cycle(N1), only_reals(N1)}, N1);
	F.add_cycle_rel(lst{is_tangent_o(P1), is_tangent_o(P2), is_tangent_i(P3),is_tangent_i(P4),
				is_real_cycle(N2), only_reals(N2)}, N2);
	F.add_cycle_rel(lst{is_tangent_o(P1), is_tangent_i(P2), is_tangent_i(P3),is_tangent_i(P4),
				is_real_cycle(N3), only_reals(N3)}, N3);

@ Now we save the arrangement for the numerical value \(R^2=\frac{3}{4}\).
<<3D-figure-visualise.cpp>>=
	F.subs(R==sqrt(ex_to<numeric>(3))/2).arrangement_write("appolonius");
	return 0;
}
@ %def arrangement_write

@ Now this arrangement can be visualised by loading the file
\texttt{appolonius.txt} into the helper programme
\texttt{cycle3D-visualiser}. A screenshot of such visualisation is
shown on Fig.~\ref{fig:apollonius-3D}.

@
\section{Public Methods in the [[figure]] class}
\label{sec:publ-meth-figure}

This section lists all methods, which may be of interest to an
end-user. An advanced user may find further advise in
Appendix~\ref{sec:figure-header-file}, which outlines the library
header file. Methods presented here are grouped by their purpose.

The source (interleaved with documentation in a \NoWEB\ file) can be
found at \href{http://moebinv.sourceforge.net/}{SourceForge
  project page}~\cite{Kisil14b} as Git tree.  The code is written
using \NoWEB\ \href{http://en.wikipedia.org/wiki/Literate_programming}{literate
  programming} tool~\cite{NoWEB}.  The code uses some
{\CPPeleven} features, e.g. regeps and [[std::function]]. Drawing procedures
delegate to \Asymptote~\cite{Asymptote}.

The stable realises and
full documentation are in
\href{https://sourceforge.net/projects/moebinv/files/}{Files section
  of the project}. A release archive contain all {\CPP} files extracted
from the \NoWEB\ source, thus only the standard {\CPP} compiler is
necessary to use them.

Furthermore, a live CD with the compiled library, examples and all
required tools is distributed as an ISO image. You may find a link to
the ISO image at the start of this Web page:
\begin{quote}
\url{http://www.maths.leeds.ac.uk/~kisilv/courses/using_sw.html}
\end{quote}
It also explains how to use the live CD image either to boot your
computer or inside a Virtual Machine.

@
\subsection{Creation and re-setting of [[figure]], changing [[metric]]}

Here are methods to initialise [[figure]] and manipulate its basic property.

\label{sec:creation-re-setting}

@ This is the simplest constructor of an initial figure with the
(point) metric [[Mp]]. By default, any figure contains the [[real_line]] and
[[infinity]]. Parameter [[M]], may be same as for definition of
[[clifford_unit]] in \GiNaC, that is,  be
represented by a square [[matrix]], [[clifford]] or
[[indexed]] class object.  If the metric [[Mp]] is not provided, then the
default elliptic metric in two dimensions is used, it is given by the matrix
\(\begin{pmatrix}
  -1&0\\0&-1
\end{pmatrix}\).

An advanced user may wish to specify a different metric for point
and cycle spaces, see~\cite{Kisil12a}*{\S~4.2} for the discussion. By
default, if the metric in the point space is \(\begin{pmatrix}
  -1&0\\0&\sigma
\end{pmatrix}\) then the metric of cycle space is:
\begin{equation}
  \label{eq:int-heaviside-function}
\begin{pmatrix}
  -1&0\\0&-\chi(-\sigma)
\end{pmatrix},
\qquad \text { where } \quad
  \chi(t)=\left\{
    \begin{array}{ll}
      1,& t\geq 0;\\
      -1,& t<0.
    \end{array}\right.
\end{equation}
is the \emph{\wiki{Heaviside_step_function}{Heaviside function}}%
\index{function!Heaviside}%
\index{Heaviside!function} \(\chi(\sigma)\)
In other word, by default for elliptic and parabolic point space the
cycle space has the same metric and for the parabolic point space the
cycle space is elliptic. If a user want a different combination then
the following constructor need to be used, see also [[set_metric()]] below
<<public methods in figure class>>=
figure(const ex & Mp, const ex & Mc=0);
@ %def figure

@ The metrics set in the above constructor can be changed at any stage,
and all cycles will be re-calculated in the figure accordingly. The
parameter [[Mp]] can be the same type of object as in the first
constructor [[figure(const ex \& )]].  The first form change the point
space metric and derive respective cycle space metric as described
above. In the second form both metrics are provided explicitly.
<<public methods in figure class>>=
void set_metric(const ex & Mp, const ex & Mc=0);
@ %def set_metric

@ This constructor can be used to create a figure with the pre-defined
collection [[N]] of cycles.
<<public methods in figure class>>=
figure(const ex & Mp, const ex & Mc, const exhashmap<cycle_node> & N);
@ %def figure

@  Remove all [[cycle_node]] from the figure.  Only the
[[point_metric]], [[cycle_metric]], [[real_line]] and
[[infinity]] are preserved.
<<public methods in figure class>>=
void reset_figure();
@ %def reset_figure

@
\subsection{Adding elements to figure}
\label{sec:adding-elem-figure}

@ This method add points to the figure. A point is represented
as cycles with radius \(0\) (with respect to the cycle metric) and
coordinates \(x=(x_1, \ldots,x_n)\) of their centre (represented by a
[[lst]] of the suitable length). The procedure returns a
symbol, which can be used later to refer this point. In the first form
parameters [[name]] and (optional) [[TeXname]] provide respective
string to name this new symbol. In the second form the whole symbol
[[key]] is provided (and it will be returned by the procedure).
<<public methods in figure class>>=
ex add_point(const ex & x, string name, string TeXname="");
ex add_point(const ex & x, const ex & key);
@ %def add_point name TeXname key

@ This method add a cycle at zero generation without parents. The
returned value and parameters [[name]], [[TeXname]] and [[key]] are as
in the previous methods [[add_point()]].
<<public methods in figure class>>=
ex add_cycle(const ex & C, string name, string TeXname="");
ex add_cycle(const ex & C, const ex & key);
@ %def add_cycle

@ Add a new node by a set [[rel]] of relations. The
returned value and parameters [[name]], [[TeXname]] and [[key]] are as
in methods [[add_point()]].
<<public methods in figure class>>=
ex add_cycle_rel(const lst & rel, string name, string TeXname="");
ex add_cycle_rel(const lst & rel, const ex & key);
ex add_cycle_rel(const ex & rel, string name, string TeXname="");
ex add_cycle_rel(const ex & rel, const ex & key);
@ %def add_cycle_rel

@ Add a new cycle as the result of certain subfigure [[F]]. The list
[[L]] provides nodes from the present figure, which shall be
substituted to the zero generation of [[F]]. See
[[midpoint_constructor()]] for an example, how subfigure shall be
defined, The returned value and parameters [[name]], [[TeXname]] and
[[key]] are as in methods [[add_point()]].
<<public methods in figure class>>=
ex add_subfigure(const ex & F, const lst & L, string name, string TeXname="");
ex add_subfigure(const ex & F, const lst & L, const ex & key);
@ %def add_subfigure

@
\subsection{Modification, deletion and searches of nodes}
\label{sec:modification-nodes}
@ This method modifies a node created by [[add_point()]] by moving the
centre to new coordinates \(x=(x_1, \ldots,x_n)\) (represented by a
[[lst]] of the suitable length).
<<public methods in figure class>>=
void move_point(const ex & key, const ex & x);
@ %def move_point

@ This method replaced a node referred by [[key]] with the value of a
cycle [[C]]. This can be applied to a node without parents only.
<<public methods in figure class>>=
void move_cycle(const ex & key, const ex & C);
@ %def move_cycle

@ Remove a node given [[key]] and all its children and grand
children in all generations
<<public methods in figure class>>=
void remove_cycle_node(const ex & key);
@ %def remove_cycle_node

@ Return the label for [[cycle_node]] with the first matching
name. If the name is not found, the zero expression is returned.
<<public methods in figure class>>=
ex get_cycle_key(string name) const;
@ %def get_cycle_key

@ Finally, we provide the methods to obtain the [[lst]] of keys for
all nodes in generations between [[mingen]] and [[maxgen]]
inclusively. The default value [[GHOST_GEN]] of [[maxgen]] removes the
check of the upper bound. Thus, the call of the method with the
default values produce the list of all key except the ghost
generation. The second method orders keys from smaller to larger
generations. The first method is faster on figures with many
generation.
<<public methods in figure class>>=
ex get_all_keys(const int mingen = GHOST_GEN+1, const int maxgen = GHOST_GEN) const;
ex get_all_keys_sorted(const int mingen = GHOST_GEN+1, const int maxgen = GHOST_GEN) const;
@ %def get_all_keys get_all_keys_sorted

@
\subsection{Check relations and measure parameters}
\label{sec:check-relat-betw}

@ To prove theorems we need to measure ([[measure]]) some quantities
or to check ([[check_rel]]) if two cycles from the figure are
in a certain relation to each other, which were not explicitly defined by the
construction.

@
\subsubsection{Checking relations}
\label{sec:checking-relations}

@ A relation which may holds or not may be checked by the following
method. It returns a [[lst]] of [[GiNaC::relational]]s, which present
the relation between all pairs of cycles in the nodes with [[key1]]
and [[key2]]. Typically two cycles are branching in the synchronous way.
Thus it makes sense to compare only respective pairs, this is achieved
with the default value [[corresponds=true]].
<<public methods in figure class>>=
ex check_rel(const ex & key1, const ex & key2, PCR rel, bool use_cycle_metric=true,
			 const ex & parameter=0, bool corresponds=true) const;
@ %def check_rel

@ The available cycles properties to check are as follows. Most
of these properties are also behind the cycle relations described
in~\ref{sec:publ-meth-cycl}.

@ Orthogonality of cycles given by \cite{Kisil12a}*{\S~6.1}:
\begin{equation}
  \label{eq:orthog-defn}
  \scalar{\cycle{}{}}{\cycle[\tilde]{}{}}=0.
\end{equation}
For circles it coincides with usual orthogonality, for other
situations see  \cite{Kisil12a}*{Ch.~6} for detailed analysis.
<<relations to check>>=
ex cycle_orthogonal(const ex & C1, const ex & C2, const ex & pr=0);
@ %def cycle_orthogonal

@ Focal orthogonality of cycles  \cite{Kisil12a}*{\S~6.6}:
\begin{equation}
  \label{eq:focal-orthog-defn}
  \scalar{\cycle[\tilde]{}{}\cycle{}{}\cycle[\tilde]{}{}}{\Space{R}{}}=0.
\end{equation}
<<relations to check>>=
ex cycle_f_orthogonal(const ex & C1, const ex & C2, const ex & pr=0);
@ %def cycle_f_orthogonal

@ Tangent condition between two cycles which shall be used for checks.
This relation is not suitable for construction, use [[is_tangent]] and
the likes from Section~\ref{sec:publ-meth-cycl} for this.
<<relations to check>>=
ex check_tangent(const ex & C1, const ex & C2, const ex & pr=0);
@ %def check_tangent

@ Check two cycles are different.
<<relations to check>>=
ex cycle_different(const ex & C1, const ex & C2, const ex & pr=0);
@ %def cycle_different

@ Check two cycles are almost different, counting possible rounding errors.
<<relations to check>>=
ex cycle_adifferent(const ex & C1, const ex & C2, const ex & pr=0);
@ %def cycle_adifferent

@ Check that the cycle product with other cycle (or itself) is
non-positive.
<<relations to check>>=
ex product_sign(const ex & C1, const ex & C2, const ex & pr=1);
@ %def product_sign

@ We may want to exclude cycles with imaginary coefficients, this
condition check it.
<<relations to check>>=
ex coefficients_are_real(const ex & C1, const ex & C2, const ex & pr=1);
@ %def coefficients_are_real

@
\subsubsection{Measuring quantites}
\label{sec:measuring-quantites}

@ A quantity between two cycles may be measured by this
method. Typically two cycles are branching in the synchronous way.
Thus it makes sense to compare only respective pairs, this is achieved
with the default value [[corresponds=true]].
<<public methods in figure class>>=
ex measure(const ex & key1, const ex & key2, PCR rel, bool use_cycle_metric=true,
		   const ex & parameter=0, bool corresponds=true) const;
@ %def measure


@
\subsection{Accessing elements of the figure}
\label{sec:application-function}

@ We can obtain [[point_metric]] and [[cycle_metric]] form a figure by
the following methods.
<<public methods in figure class>>=
inline ex get_point_metric() const { return point_metric; }
inline ex get_cycle_metric() const { return cycle_metric; }
@ %def get_point_metric get_cycle_metric

@ Sometimes, we need to check the dimensionality of the figure,
which is essentially the dimensionality of the metric.
<<public methods in figure class>>=
inline ex get_dim() const { return ex_to<varidx>(point_metric.op(1)).get_dim(); }
@ %def get_dim()

@ All [[cycle]] associated with a key [[ck]] can be obtained through
the following method. The optional parameter tell which metric to use:
either [[point_metric]] or [[cycle_metric]]. The method returns a list
of cycles associated to the key [[ck]].
<<public methods in figure class>>=
inline ex get_cycles(const ex & ck, bool use_point_metric=true) const {
	return get_cycles(ck,use_point_metric?point_metric:cycle_metric);}
@ %def get_cycle

@ In fact, we can use a similar method to get [[cycle]] with any
permitted expression as a metric.
<<public methods in figure class>>=
ex get_cycles(const ex & ck, const ex & metric) const;
@ %def get_cycle

@ The generation of the cycle associated to the key [[ck]] is provided
by the method:
<<public methods in figure class>>=
inline ex get_generation(const ex & ck) const {
	return ex_to<cycle_node>(get_cycle_node(ck)).get_generation();}
@ %def get_generation

@ Sometimes we need to apply a function to all [[cycle]]s which
compose the [[figure]]. Here we define the type for such a function.
<<defining types>>=
using PEVAL = std::function<ex(const ex &, const ex &)>;

@ This is the method to apply a function [[func]] to all particular
[[cycle]]s which compose the [[figure]]. It returns a [[lst]] of
[[lst]]s. Each sub-list has three elements: the returned value of
[[func]], the key of the respective [[cycle_node]] and the number of
[[cycle]] in the respective node. The parameter [[use_cycle_metric]]
tells which metric shall be used: either cycle space or point space,
see~\cite{Kisil12a}*{\S~4.2}.
<<public methods in figure class>>=
ex apply(PEVAL func, bool use_cycle_metric=true, const ex & param = 0) const;
@ %def apply

@
\subsection{Drawing and printing}
\label{sec:drawing-printing}
There is a collections of methods which help to visualise a figure. We
use \Asymptote\ to produce PostScript, PDF, PNG or other files in
two-dimensions and an interactive visualisation tool is available for
three-dimensional figures.

@ The default behaviour of [[asy_write()]] is an attempt to display
files produced by {\Asymptote}. User can disable this visualisation.
<<additional functions header>>=
	void show_asy_on();
	void show_asy_off();
@ %def show_asy_on show_asy_off

@
\subsubsection{Two-dimensional graphics and animation}
\label{sec:two-dimens-graph}

@ The next method returns \Asymptote~\cite{Asymptote} string which
draws the entire figure. The drawing is controlled by two [[style]]
and [[lstring]]. Initial parameters have the same meaning as in
[[cycle2D::asy_draw()]]. Explicitly, the drawing is done within the rectangle with the
lower left vertex ([[xmin]], [[ymin]]) and upper right  ([[xmax]],
[[ymax]]). The style of drawing is controlled by [[default_asy]] and
[[default_label]], see [[asy_cycle_color()]] and [[label_pos()]] for
ideas. On
complicated figures, see Fig.~\ref{fig:action-modular-group}, we may
not want cycles label to be printed at all, this can be controlled through
[[with_labels]] parameter.
By default the [[real_line]] is drawn and the comments in the file are
presented, this can be amended through [[with_realline]] and
[[with_header]] parameters respectively. The default
number of points per arc is reasonable in most cases, however user can
override this with supplying a value to [[points_per_arc]].
The result is written to the stream [[ost]].
<<public methods in figure class>>=
void asy_draw(ostream & ost =std::cout, ostream & err=std::cerr, const string picture="",
			  const ex & xmin = -5, const ex & xmax = 5,
			  const ex & ymin = -5, const ex & ymax = 5,
			  asy_style style=default_asy, label_string lstring=default_label,
			  bool with_realline=true, bool with_header=true,
			  int points_per_arc = 0, const string imaginary_options="rgb(0,.9,0)+4pt",
			  bool with_labels=true) const;
@ %def asy_draw

@ This method creates a temporary file with \Asymptote\ commands to
draw the figure, then calls the \Asymptote\ to produce the graphic
file, the temporary file is deleted afterwards. The parameters are the
same as above in [[asy_draw()]]. The last parameter [[rm_asy_file]] tells if the
\Asymptote\ file shall be removed. User may keep it and fine-tune the
result manually.
<<public methods in figure class>>=
void asy_write(int size=300, const ex & xmin = -5, const ex & xmax = 5,
			   const ex & ymin = -5, const ex & ymax = 5,
			   string name="figure-view-tmp", string format="",
			   asy_style style=default_asy, label_string lstring=default_label,
			   bool with_realline=true, bool with_header=true,
			   int points_per_arc=0, const string imaginary_options="rgb(0,.9,0)+4pt",
			   bool rm_asy_file=true, bool with_labels=true) const;
@ %def asy_write

@ This a method to produce an animation. The figure may depend from
some parameters, for example of [[symbol]]
class. The first argument [[val]] is a [[lst]], which contains
expressions for substitutions into the figure. That is, elements of
[[val]] can be any expression suitable to use as the first parameter
of [[susb]] method in \GiNaC. For example, they may be
[[relational]]s (e.g. [[t==1.5]]) or [[lst]] of [[relational]]s
(e.g. [[lst{t==1.5,s==2.1}]]. The method make the substitution the
each element of [[lst]] into the figure and
uses the resulting \Asymptote\ drawings as a sequence of shots for the
animations. The output [[format]] may be either predefined [["pdf"]],
[["gif"]], [["mng"]] or [["mp4"]], or user-specified \Asymptote\ string.

The values of parameters can be put to the animation. The default bottom-left
position is encoded as [["bl"]] for [[values_position]], other
possible positions are [["br"]] (bottom-right),  [["tl"]] (top-left)
and [["tr"]] (top-right). Any other string (e.g. the empty one) will
preven the parameter values from printing.

The rest of parameters have the same meaning as in
[[asy_write()]]. See the end of Sect.~\ref{sec:animated-cycle} for
further advise on animation embedded into PDF files.
<<public methods in figure class>>=
void asy_animate(const ex & val,
				 int size=300, const ex & xmin = -5, const ex & xmax = 5,
				 const ex & ymin = -5, const ex & ymax = 5,
				 string name="figure-animatecf-tmp", string format="pdf",
				 asy_style style=default_asy, label_string lstring=default_label,
				 bool with_realline=true, bool with_header=true,
				 int points_per_arc = 0, const string imaginary_options="rgb(0,.9,0)+4pt",
				 const string values_position="bl", bool rm_asy_file=true,
				 bool with_labels=true) const;
@ %def asy_animate

@ Evaluation of [[cycle]] within a figure with symbolic entries may
took a long time. To prevent this we may use [[freeze]] method, and
then [[unfreeze]] after numeric substitution is done.
<<public methods in figure class>>=
inline figure freeze() const {setflag(status_flags::expanded); return *this;}
inline figure unfreeze() const {clearflag(status_flags::expanded); return *this;}
@ %def freeze unfreeze

@ To speed-up evaluation of figures we may force float evaluation
instead of exact arithmetic.
<<public methods in figure class>>=
inline figure set_float_eval() {float_evaluation=true; return *this;}
inline figure set_exact_eval() {float_evaluation=false; return *this;}
@ %def set_float_eval set_exact_eval

@ These methods allow to specify or read an \Asymptote\ drawing style
for a particular node.
<<public methods in figure class>>=
inline void set_asy_style(const ex & key, string opt) {nodes[key].set_asy_opt(opt);}
inline string get_asy_style(const ex & key) const {return ex_to<cycle_node>(get_cycle_node(key)).get_asy_opt();}
@ %def set_asy_style get_asy_style

@
\subsubsection{Three-dimensional visualisation}
\label{sec:three-dimens-visu}

@ In three dimensions a visualisation is possible with the help of an
additional interactive programme \texttt{cycle3D-visualiser}. The
following method produces a text file [[name.txt]] (the default suffix [[".txt"]] is
added to [[name]] automatically). The file can be
visualised by a helper programme. All cycles in generations starting
from [[first_gen]] are represented by their centres, radii,
generations and labels.
<<public methods in figure class>>=
void arrangement_write(string name, int first_gen=0) const;
@ %def arrangement_write

@ The written file [[filename]] then can be loaded by
texttt{cycle3D-visualiser} either through command line option or file
choosing dialog. See documentations of the helper programme for
available tools. In particular, it is possible to make screenshots
similar to Fig.~\ref{fig:apollonius-3D}.

@ To print a figure [[F]] (of any dimensionality) as a list of nodes
and relations between them it is enough to direct the figure to the
stream:
\begin{quote}
  [[ cout << F <<endl; ]]
\end{quote}

@
\subsection{Saving and openning}
\label{sec:saving-openning}
@ We can write a figure to a file as a \GiNaC\ archive
(\texttt{*.gar} file) named [[file_name]] at a node [[fig_name]].
<<public methods in figure class>>=
void save(const char* file_name, const char* fig_name="myfig") const;
@ %def save

@ This constructor reads a figure stored in a \GiNaC\ archive
(\texttt{*.gar} file) named [[file_name]] at a node [[fig_name]].
<<public methods in figure class>>=
figure(const char* file_name, string fig_name="myfig");
@ %def  figure

@ If a figure is created from a code, especially with sufficiently
comments, then the code completely describes the figure. Moreover,
such a code is probably the preferable archiving form of the
figure. However, some figure can be also created from a Graphical User
Interface by mouse clicks and stored as \GiNaC\
\texttt{gar}-archives. In such cases it can be useful to write and
store some human readable description of the figure, its author and
license. Such information can be recorded, amended or read to/from the
figure by the following methods:
<<public methods in figure class>>=
inline void info_write(string whole_text) {info_text = whole_text;}
inline void info_append(string more_text) {info_text += more_text;}
inline string info_read() const {return info_text;}
@ %def info_write info_append info_read

@
\section{Public methods in [[cycle_relation]]}
\label{sec:publ-meth-cycl}

Nodes within figure are connected by sets of relations. There is some
essential relations pre-defined in the library. Users can define their
own relations as well.

@  The following relations between cycles are predefined.
Orthogonality of cycles given by
\cite{Kisil12a}*{\S~6.1}:
\begin{equation}
  \label{eq:orthog-defn-1}
  \scalar{\cycle{}{}}{\cycle[\tilde]{}{}}=0.
\end{equation}
<<predefined cycle relations>>=
inline cycle_relation is_orthogonal(const ex & key, bool cm=true)
					{return cycle_relation(key, cycle_orthogonal, cm);}
@ %def is_orthogonal

@ Focal orthogonality of cycles~\eqref{eq:focal-orthog-defn}, see \cite{Kisil12a}*{\S~6.6}.
<<predefined cycle relations>>=
inline cycle_relation is_f_orthogonal(const ex & key, bool cm=true)
					{return cycle_relation(key, cycle_f_orthogonal, cm);}
@ %def is_f_orthogonal

@ We may want a cycle to be different from another. For example, if we
look for intersection of two lines we want to exclude the infinity,
where they are intersected anyway. Then, we may add the condition
[[is_different(F.get_infinity())]].
<<predefined cycle relations>>=
inline cycle_relation is_different(const ex & key, bool cm=true)
					{return cycle_relation(key, cycle_different, cm);}
@ %def is_different

@ Due to a possible rounding errors we include an approximate version
of [[is_different]].
<<predefined cycle relations>>=
inline cycle_relation is_adifferent(const ex & key, bool cm=true)
					{return cycle_relation(key, cycle_adifferent, cm);}
@ %def is_adifferent

@ This relation check if a cycle is a non-positive vector, for circles
this corresponds to real (non-imaginary) circles. By default we
check this in the point space metric.
<<predefined cycle relations>>=
inline cycle_relation is_real_cycle(const ex & key, bool cm=false, const ex & pr=1)
 {return cycle_relation(key, product_sign, cm, pr);}
@ %def is_real_cycle

@ Effectively this is the same check but with a different name and
other defaults. It may be used that both cycles are or are not
separated by the light cone in the indefinite metric in space of cycles.
<<predefined cycle relations>>=
inline cycle_relation product_nonpositive(const ex & key, bool cm=true, const ex & pr=1)
 {return cycle_relation(key, product_sign, cm, pr);}
@ %def product_nonpositive

@ We may want to exclude cycles with imaginary coefficients, this
condition check it.
<<predefined cycle relations>>=
inline cycle_relation only_reals(const ex & key, bool cm=true, const ex & pr=0)
 {return cycle_relation(key, coefficients_are_real, cm, pr);}
@ %def only_reals

@ This is tangency condition which shall be used to find tangent cycles.
<<predefined cycle relations>>=
inline cycle_relation is_tangent(const ex & key, bool cm=true)
					{return cycle_relation(key, cycle_tangent, cm);}
@ %def is_tangent

@ The split version for inner and outer tangent cycles.
<<predefined cycle relations>>=
inline cycle_relation is_tangent_i(const ex & key, bool cm=true)
					{return cycle_relation(key, cycle_tangent_i, cm);}
inline cycle_relation is_tangent_o(const ex & key, bool cm=true)
					{return cycle_relation(key, cycle_tangent_o, cm);}
@ %def is_tangent_i is_tangent_o

@ The relation between cycles to ``intersect with
certain angle'' (but the ``intersection'' may be imaginary). If cycles
are intersecting indeed then the value of [[pr]] is the cosine of the
angle.
<<predefined cycle relations>>=
inline cycle_relation make_angle(const ex & key, bool cm=true, const ex & angle=0)
					{return cycle_relation(key, cycle_angle, cm, angle);}
@ %def make_angle

@ The next relation defines a generalisation of a Steiner power of a
point for cycles.
<<predefined cycle relations>>=
inline cycle_relation cycle_power(const ex & key, bool cm=true, const ex & cpower=0)
					{return cycle_relation(key, steiner_power, cm, cpower);}
@ %def cycle_power

@ The next relation defines tangential distance between cycles.
<<predefined cycle relations>>=
inline cycle_relation tangential_distance(const ex & key, bool cm=true, const ex & distance=0)
					{return cycle_relation(key, steiner_power, cm, pow(distance,2));}
@ %def tangential_distance

@ The next relation defines cross-tangential distance between cycles.
<<predefined cycle relations>>=
inline cycle_relation cross_t_distance(const ex & key, bool cm=true, const ex & distance=0)
					{return cycle_relation(key, cycle_cross_t_distance, cm, distance);}
@ %def cross_t_distance

@ The next relation creates a cycle, which is a FLT of an existing
cycle. The transformation is defined by
a list of four entries which will make a \(2\times 2\) matrix. The
default value corresponds to the identity map. User will need to use a
proper Clifford algebra for the matrix to make this transformation
works. In two dimensions the next method makes a relief.
<<predefined cycle relations>>=
inline cycle_relation moebius_transform(const ex & key, bool cm=true,
										const ex & matrix=lst{numeric(1),0,0,numeric(1)})
					{return cycle_relation(key, cycle_moebius, cm, matrix);}
@ %def moebius_transform

@ This is a simplified variant of the previous transformations for two
dimension figures and transformations with real entries. The
corresponding check will be carried out by the library. Then, the library
will convert it into the proper Clifford valued matrix.
<<predefined cycle relations>>=
 cycle_relation sl2_transform(const ex & key, bool cm=true,
							  const ex & matrix=lst{numeric(1),0,0,numeric(1)});
@ %def sl2_transform

@ This is a constructor which creates a relation of the type [[rel]] to
a node labelled by [[key]]. Boolean [[cm]] tells either to chose cycle
metric or point metric for the relation. An additional parameter [[p]]
can be supplied to the relation.
<<public methods for cycle relation>>=
cycle_relation(const ex & key, PCR rel, bool cm=true, const ex & p=0);
@ %def cycle_relation

@ There is also an additional method to define a joint relation to
several parents by insertion of a [[subfigure]], see
[[midpoint_constructor]] below.
<<public methods for subfigure>>=
subfigure(const ex & F, const ex & L);
@ %def subfigure

@
\section{Addtional utilities}
\label{sec:addtional-utilities}

@ Here is a procedure which returns a figure, which can be used to
build a conformal version of the midpoint. The methods require three
points, say [[v1]], [[v2]] and [[v3]]. If [[v3]] is infinity, then the
midpoint between [[v1]] and [[v2]] can be build using the orthogonality
only. Put a cycle [[v4]] joining [[v1]], [[v2]] and [[v3]]. Then
construct a cycle [[v5]] with the diameter [[v1]]--[[v2]], that is passing
these points and orthogonal to [[v4]]. Then, put the cycle [[v6]]
which passes [[v3]] and is orthogonal to [[v4]] and [[v5]]. The
intersection [[r]] of [[v6]] and [[v4]] is the midpoint of [[v1]]--[[v2]].
<<additional functions header>>=
ex midpoint_constructor();
@ %def midpoint_constructor

@ This utility make pair-wise comparison of cycles in the list [[L]]
and deletes duplicates.
<<additional functions header>>=
ex unique_cycle(const ex & L);
@ %def unique_cycle

@ The debug output may be switched on and switched off by the
following methods.
<<additional functions header>>=
void figure_debug_on();
void figure_debug_off();
bool figure_ask_debug_status();
@ %def figure_debug_on figure_debug_off figure_ask_debug_status

@ Solution of several quadratic equations in a sequence rapidly
increases complexity of expression. We try to resolve this by some
trigonometric or hyperbolic substitutions. Those expression in the
turn need to be simplified as well in [[evaluate_cycle()]] for the
condition [[only_reals]]. Later this variable will be assigned with a
default list of trigonometric substitutions.  User have a
possibility to adjust this list in the run time.
<<additional functions header>>=
extern const ex evaluation_assist;
@ %def evaluation_assist

@ Definition of the simplification rule.
<<figure library variables and constants>>=
const ex evaluation_assist = lst{power(cos(wild(0)),2)==1-power(sin(wild(0)),2),
		power(cosh(wild(1)),2)==1+power(sinh(wild(1)),2)};
@ %def evaluation_assist

@
\section{Figure Library Header File}
\label{sec:figure-header-file}

@ Here is the header file of the library. Initially, an end-user does not need to
know its structure much beyond the material presented in
Sections~\ref{sec:publ-meth-figure}--\ref{sec:publ-meth-cycl} and
illustrated in Section~\ref{sec:examples}. Here is some further topics
which can be of interest as well:
\begin{itemize}
\item An intermediate end-user may wish to define his own
  [[subfigure]]s, see [[midpoint_constructor]] for a sample and
  Subsect.~\ref{sec:subf-class-decl}.
\item Furthermore, an advanced end-user may wish to define some
  additional [[cycle_relation]] to supplement already presented in
  Section~\ref{sec:publ-meth-cycl}, in this case only knowledge of
  [[cycle_relation]] class is required, see
  Subsect.~\ref{sec:cycl-real-class-decl}.
\item To adjust automatically created \Asymptote\ graphics user may
  want to adjust the default styles, see Subsect.~\ref{sec:asympt-cust}.
\end{itemize}

@
<<figure.h>>=
<<license>>
#ifndef ____figure__
#define ____figure__

@ Some libraries we are using.
<<figure.h>>=
#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <fstream>
#include <regex>
#include "cycle.h"

namespace MoebInv {
using namespace std;
using namespace GiNaC;
@ %def MoebInv

@ The overview of the header file.
<<figure.h>>=
<<figure define>>
<<defining types>>
<<cycle data header>>
<<cycle node header>>
<<cycle relations>>
<<asy styles>>
<<figure header>>
<<subfigure header>>
<<additional functions header>>
} // namespace MoebInv
#endif /* defined(____figure__) */

@ We use negative numbered generations to save the reference objects.
<<figure define>>=
#define REAL_LINE_GEN -1
#define INFINITY_GEN -2
#define GHOST_GEN -3
@ %def REAL_LINE_GEN INFINITY_GEN GHOST_GEN

@
\subsection{[[cycle_data]] class declaration}
\label{sec:cycl-class-decl}

@ The class to store explicit data of an individual [[cycle]]. An
end-user does not need normally to know about it.
<<cycle data header>>=
class cycle_data : public basic
{
GINAC_DECLARE_REGISTERED_CLASS(cycle_data, basic)
@ %def cycle_data

@ The parameters of the stored [[cycle]].
<<cycle data header>>=
protected:
	ex k_cd,
	l_cd,
	m_cd;

@ Public methods in the class. However, an end-user does not normally
need them.
<<cycle data header>>=
public:
	cycle_data(const ex & C);
 	cycle_data(const ex & k1, const ex l1, const ex &m1, bool normalize=false);
	ex make_cycle(const ex & metr) const;
	inline size_t nops() const { return 3; }
	ex op(size_t i) const;
	ex & let_op(size_t i);
	inline ex get_k() const { return k_cd; }
	inline ex get_l() const { return l_cd; }
	inline ex get_l(size_t i) const { return l_cd.op(0).op(i); }
	inline ex get_m() const { return m_cd;}
	inline long unsigned int get_dim() const { return l_cd.op(0).nops(); }
	void do_print(const print_dflt & con, unsigned level) const;
	void do_print_double(const print_dflt & con, unsigned level) const;
	void archive(archive_node &n) const;
	inline ex normalize() const {return cycle_data(k_cd,l_cd,m_cd,true);}
	ex num_normalize() const;
	void read_archive(const archive_node &n, lst &sym_lst);
	bool is_equal(const basic & other, bool projectively) const;
	bool is_almost_equal(const basic & other, bool projectively) const;
	cycle_data subs(const ex & e, unsigned options=0) const;
	ex subs(const exmap & em, unsigned options=0) const;
	inline bool has(const ex & x) const { return (k_cd.has(x) ||  l_cd.has(x) ||  m_cd.has(x)); }

protected:
	return_type_t return_type_tinfo() const;
};
GINAC_DECLARE_UNARCHIVER(cycle_data);

@
\subsection{[[cycle_node]] class declaration}
\label{sec:cycl-node-class-decl}

@ Forward declaration.
<<cycle node header>>=
class cycle_relation;

@ The class to store nodes containing data of particular cycles and
relations between nodes. An end-user does not need normally to know
about it.
<<cycle node header>>=
class cycle_node : public basic
{
GINAC_DECLARE_REGISTERED_CLASS(cycle_node, basic)
@ %def cycle_node

@ Members of the class.
<<cycle node header>>=
protected:
	lst cycles; // List of cycle data entries
	int generation;
	lst children; // List of keys to cycle_nodes
	lst parents; // List of cycle_relations or a list containing a single subfigure
	string custom_asy; // Custom string for Asymptote

@ Constructors in the class.
<<cycle node header>>=
public:
	cycle_node(const ex & C, int g=0);
	cycle_node(const ex & C, int g, const lst & par);
	cycle_node(const ex & C, int g, const lst & par, const lst & chil);
	cycle_node(const ex & C, int g, const lst & par, const lst & chil, string ca);
	cycle_node subs(const ex & e, unsigned options=0) const;
	void do_print_double(const print_dflt & con, unsigned level) const;
	ex subs(const exmap & m, unsigned options=0) const;

@ Add a chid [[cycle_node]] to the [[cycle_node]].
<<cycle node header>>=
protected:
	inline void add_child(const ex & c) {children.append(c);}

@ Access [[cycle]] parameters.
<<cycle node header>>=
	inline ex get_cycles_data() const {return cycles;}

@ Return the [[cycle]] object for every [[cycle_data]] stored in [[cycles]].
<<cycle node header>>=
	ex make_cycles(const ex & metr) const;
	inline ex get_cycle_data(int i) const {return cycles.op(i);}

@ Return the generation number.
<<cycle node header>>=
	inline int get_generation() const {return generation;}

@ Return the children list
<<cycle node header>>=
	inline lst get_children() const {return children;}

@ Replace the current [[cycle]] with a new [[cycle]].
<<cycle node header>>=
	void set_cycles(const ex & C);

@ Add one more [[cycle]] instance to list of [[cycles]].
<<cycle node header>>=
	void append_cycle(const ex & C);
	void append_cycle(const ex & k, const ex & l, const ex & m);

@ Return the parent list.
<<cycle node header>>=
	lst get_parents() const;

@ The method returns the list of all keys to parant cycles.
<<cycle node header>>=
	lst get_parent_keys() const ;

@ Remove a child of the [[cycle_node]].
<<cycle node header>>=
	void remove_child(const ex & c);

@ Set or read \Asymptote\ option for this particular node.
<<cycle node header>>=
	inline void set_asy_opt(const string opt)  {custom_asy=opt;}
	inline string get_asy_opt() const {return custom_asy;}

@ Service functions including printout the mathematical expression.
<<cycle node header>>=
	inline size_t nops() const { return cycles.nops()+children.nops()+parents.nops(); }
	ex op(size_t i) const;
	ex & let_op(size_t i);
	void do_print(const print_dflt & con, unsigned level) const;
	void do_print_tree(const print_tree & con, unsigned level) const;
protected:
	return_type_t return_type_tinfo() const;
	void archive(archive_node &n) const;
	void read_archive(const archive_node &n, lst &sym_lst);

friend class cycle_relation;
friend class figure;
};
GINAC_DECLARE_UNARCHIVER(cycle_node);

@
\subsection{[[cycle_relation]] class declaration}
\label{sec:cycl-real-class-decl}

@ First, we define a type to hold cycle relations. That is a pointer
to a functions with two arguments. See the definition of
[[cycle_orthogonal]], [[cycle_different]], for samples.
<<defining types>>=
using PCR = std::function<ex(const ex &, const ex &, const ex &)>;
@ %def PCR

@ This class describes relations between [[cycle_node]]s. An
advanced end-user may want to add some new relations similar to
already provided in Section~\ref{sec:publ-meth-cycl}. Note however,
that archiving (saving) of user-defined relations cannot be done as
they contain pointers to functions which are not portable.

@ Memebrs of the class.
<<cycle relations>>=
class cycle_relation : public basic
{
	GINAC_DECLARE_REGISTERED_CLASS(cycle_relation, basic)
protected:
	ex parkey; // A key to a parent cycle_node in figure
	PCR rel; // A pointer to function which produces the relation
	ex parameter; // The value, which is supplied to rel() as the third parameter
	bool use_cycle_metric; // If true uses the cycle space metric, otherwise the point space metric
@ %def cycle_relation

@ Public methods in the class.
<<cycle relations>>=
public:
	<<public methods for cycle relation>>
	inline ex get_parkey() const {return parkey;}
	inline PCR get_PCR() const {return rel;}
	inline ex get_parameter() const {return parameter;}
	inline bool cycle_metric_inuse() const {return use_cycle_metric;}
	inline ex subs(const exmap & em, unsigned options=0) const
	{return cycle_relation(parkey, rel, use_cycle_metric, parameter.subs(em,options));}

@ Protected methods in the class. The next method creates relation of
[[C1]] to its parent. [[C1]] shall be in the [[cycle_data]] class.
<<cycle relations>>=
protected:
	ex rel_to_parent(const ex & C1, const ex & pmetric, const ex & cmetric,
					 const exhashmap<cycle_node> & N) const;

@ Service methods in the class.
<<cycle relations>>=
	return_type_t return_type_tinfo() const;
	void do_print(const print_dflt & con, unsigned level) const;
	void do_print_tree(const print_tree & con, unsigned level) const;

@  (un)Archiving of [[cycle_relation]] is not universal. At present it
only can handle relations declared in the header file [[cycle_orthogonal]],
[[cycle_f_orthogonal]], [[cycle_adifferent]], [[cycle_different]],
[[cycle_tangent]],  [[cycle_power]] etc. from
Subsection~\ref{sec:publ-meth-cycl}.
<<cycle relations>>=
	void archive(archive_node &n) const;
	void read_archive(const archive_node &n, lst &sym_lst);

	inline size_t nops() const { return 2; }
	ex op(size_t i) const;
	ex & let_op(size_t i);

friend class cycle_node;
friend class figure;
};
GINAC_DECLARE_UNARCHIVER(cycle_relation);

@ The following functions are used as [[PCR]] pointers for corresponding cycle
relations.
<<cycle relations>>=
<<relations to check>>

@ The following procedures are used to construct relations but are
impractical to check.
<<cycle relations>>=
ex cycle_tangent(const ex & C1, const ex & C2, const ex & pr=0);
ex cycle_tangent_i(const ex & C1, const ex & C2, const ex & pr=0);
ex cycle_tangent_o(const ex & C1, const ex & C2, const ex & pr=0);
ex cycle_angle(const ex & C1, const ex & C2, const ex & pr);
ex steiner_power(const ex & C1, const ex & C2, const ex & pr);
ex cycle_cross_t_distance(const ex & C1, const ex & C2, const ex & pr);
@ %def cycle_tangent cycle_tangent_i cycle_tangent_o cycle_angle steiner_power cycle_cross_t_distance

@ Fractional linear transformations.
<<cycle relations>>=
ex cycle_moebius(const ex & C1, const ex & C2, const ex & pr);
ex cycle_sl2(const ex & C1, const ex & C2, const ex & pr);
@ %def cycle_moebius cycle_sl2

@ The next functions are used to measure certain quantities between cycles.
<<cycle relations>>=
ex power_is(const ex & C1, const ex & C2, const ex & pr=1);
inline ex sq_t_distance_is(const ex & C1, const ex & C2, const ex & pr=1)
 {return power_is(C1,C2,1);}
inline ex sq_cross_t_distance_is(const ex & C1, const ex & C2, const ex & pr=-1)
 {return power_is(C1,C2,-1);}
ex angle_is(const ex & C1, const ex & C2, const ex & pr=0);
@ %def power_is sq_t_distance_is sq_cross_t_distance_is angle_is

@ We include the list of pre-defined metrics in two dimensions.
<<cycle relations>>=
<<predefined cycle relations>>

@ We explicitly define three types of metrics on a plane: elliptic, parabolic, hyperbolic.
<<cycle relations>>=
extern const ex metric_e, metric_p, metric_h;
@ %def metric_e metric_p metric_h

@ The predefined metrics are based on diagonal matrices with different signatures.
<<figure library variables and constants>>=
const ex metric_e = clifford_unit(varidx(symbol("i"), numeric(2)), indexed(diag_matrix(lst{-1,-1}), sy_symm(),
																		   varidx(symbol("j"), numeric(2)), varidx(symbol("k"), numeric(2))));
const ex metric_p = clifford_unit(varidx(symbol("i"), numeric(2)), indexed(diag_matrix(lst{-1,0}), sy_symm(),
																		   varidx(symbol("j"), numeric(2)), varidx(symbol("k"), numeric(2))));
const ex metric_h = clifford_unit(varidx(symbol("i"), numeric(2)), indexed(diag_matrix(lst{-1,1}), sy_symm(),
varidx(symbol("j"), numeric(2)), varidx(symbol("k"), numeric(2))));
@ %def metric_e metric_p metric_h

@ There is the list of pre-defined metrics in two dimensions cycle
relations. Orthogonality of cycles of three types independent from a
metric stored in the figure.
<<cycle relations>>=
inline ex cycle_orthogonal_e(const ex & C1, const ex & C2, const ex & pr=0) {
	return lst{(ex)lst{ex_to<cycle>(C1).is_orthogonal(ex_to<cycle>(C2), metric_e)}};}

inline ex cycle_orthogonal_p(const ex & C1, const ex & C2, const ex & pr=0) {
	return lst{(ex)lst{ex_to<cycle>(C1).is_orthogonal(ex_to<cycle>(C2), metric_p)}};}

inline ex cycle_orthogonal_h(const ex & C1, const ex & C2, const ex & pr=0) {
	return lst{(ex)lst{ex_to<cycle>(C1).is_orthogonal(ex_to<cycle>(C2), metric_h)}};}
@ %def cycle_orthogonal_e cycle_orthogonal_p cycle_orthogonal_h

@
\subsection{[[subfigure]] class declaration}
\label{sec:subf-class-decl}

@ [[subfigure] class allows to encapsulate some common constructions.
The library provides an important example [[midpoint]]. End-user may
define his own [[subfigure]]s, they will not be handled as native
ones, including (un)archiving.

In the essence [[subfigure]] is created from a [[figure]], which were
designed to be included in another figures.
<<subfigure header>>=
class subfigure : public basic
{
	GINAC_DECLARE_REGISTERED_CLASS(subfigure, basic)
protected:
	ex subf; // A figure to be inserted
	lst parlist; // A list of key to a parent cycle_node in figure
public:
	<<public methods for subfigure>>
	inline ex subs(const exmap & em, unsigned options=0) const;
@ %def subfigure

@ Some service methods.
<<subfigure header>>=
protected:
	inline ex get_parlist() const {return parlist;}
	inline ex get_subf() const {return subf;}
	return_type_t return_type_tinfo() const;
	void do_print(const print_dflt & con, unsigned level) const;
	void do_print_tree(const print_tree & con, unsigned level) const;

@  (un)Archiving of [[cycle_relation]] is not universal. At present it
only can handle relations declared in the header file [[p_orthogonal]],
[[p_f_orthogonal]], [[p_adifferent]], [[p_different]] and [[p_tangent]] etc. from
Subsection~\ref{sec:publ-meth-cycl}.
<<subfigure header>>=
	void archive(archive_node &n) const;
	void read_archive(const archive_node &n, lst &sym_lst);

friend class cycle_node;
friend class figure;
};
GINAC_DECLARE_UNARCHIVER(subfigure);

@
\subsection{[[figure]] class declaration}
\label{sec:figure-class-header}

The essential interface to [[figure]] class was already presented in
Section~\ref{sec:publ-meth-figure}, here we keep the less-used
elements. An advanced end-user may be interested in [[figure]] class
members given in \S~\ref{sec:members-figure-class}.

@ We define [[figure]] class as a children of \GiNaC\ [[basic]].
<<figure header>>=
class figure : public basic
{
GINAC_DECLARE_REGISTERED_CLASS(figure, basic)

<<member of figure class>>
@ %def figure

@ The method to update [[cycle_node]] with labelled by the
[[key]]. Since the list of conditions may branches and  has a variable
length the method runs recursively with [[level]] parameterising the
depth of nested calls.
<<figure header>>=
protected:
	ex update_cycle_node(const ex & key, const lst & eq_cond=lst{},
						   const lst & neq_cond=lst{}, lst res=lst{}, size_t level=0);
	void set_cycle(const ex & key, const ex & C);
@ %def set_cycle update_cycle_node

@ Evaluate a cycle through a list of conditions.
<<figure header>>=
	ex evaluate_cycle(const ex & symbolic, const lst & cond) const;

@ We include here methods from Section~\ref{sec:publ-meth-figure},
which are of interest for an end-user.
<<figure header>>=
public:
	<<public methods in figure class>>

@ The following methods are public as well however may be less used.
<<figure header>>=
	inline ex get_cycle_node(const ex & ck) const {return nodes.find(ck)->second;}
	void do_print_double(const print_dflt & con, unsigned level) const;
@ %def get_cycle_node do_print_double

@ The method returning all nodes.
<<public methods in figure class>>=
	inline exhashmap<cycle_node> get_nodes() const {return nodes;}

@ Sometimes we need access to predefined [[infinity]] or the
[[real_line]], for example to specify a cycle relation to them.
<<public methods in figure class>>=
	inline ex get_real_line() const {return real_line;}
	inline ex get_infinity() const {return infinity;}
@ %def get_real_line get_infinity

@ Return the maximal generation number of cycles in this figure.
<<public methods in figure class>>=
	int get_max_generation() const;
@ %def get_max_generation

@  Some standard \GiNaC\ methods which are not very interesting for
end-user, who is working within functional programming set-up.
<<public methods in figure class>>=
	inline size_t nops() const {return 4+nodes.size();}
	ex op(size_t i) const;
	//ex & let_op(size_t i);
	ex evalf(int level=0) const;
	figure subs(const ex & e, unsigned options=0) const;
	ex subs(const exmap & m, unsigned options=0) const;
	void archive(archive_node &n) const;
	void read_archive(const archive_node &n, lst &sym_lst);
	bool info(unsigned inf) const;
@ %def nops op evalf subs archive read_archive info

@ Printing and returning the objects list.
<<figure header>>=
protected:
	void do_print(const print_dflt & con, unsigned level) const;
	return_type_t return_type_tinfo() const;

@ Update all cycles (with all children) in the given list.
<<figure header>>=
	void update_node_lst(const ex & inlist);
@ %def update_node_lst

@ Update the entire figure.
<<figure header>>=
	figure update_cycles();
};
GINAC_DECLARE_UNARCHIVER(figure);
@ %def update_cycles

@
\subsubsection{Members of [[figure]] class}
\label{sec:members-figure-class}
A knowledge of [[figure]] class members may be useful for advanced users.

@ The real line and infinity are two cycles which are present at any figure.
<<member of figure class>>=
protected:
 ex real_line, // the key for the real line
	  infinity; // the key for cycle at infinity
@ %def real_line infinity

@ We define separate metrics for the point and cycle spaces, see~\cite{Kisil12a}*{\S~4.2}.
<<member of figure class>>=
	ex point_metric; // The metric of the point space encoded as a clifford_unit object
	ex cycle_metric; // The metric of the cycle space encoded as a clifford_unit object
@ %def point_metric cycle_metric

@ This is the [[hashmap]] of [[cycle_node]] which encode the relation in the figure.
<<member of figure class>>=
	exhashmap<cycle_node> nodes; // List of cycle_node, exhashmap<cycle_node> object
@ %def nodes

@ The following variable controls either we are doing exact or float
evaluations of cycles parameters.
<<member of figure class>>=
	bool float_evaluation=false;
@ %def float_evaluation

@ A string to record any information related to the figure. This library
does not parse its content: it is primary intended for humans.
<<member of figure class>>=
	string info_text;
@ %def  info_text

@ These are symbols for internal calculations, they are out of the interest we do not
count them in [[nops()]] methods.
<<member of figure class>>=
	ex k, m; // realsymbols for symbolic calculations
	lst l;
@ %def k l m

@
\subsection{\Asymptote\ customization}
\label{sec:asympt-cust}
The library provides a possibility to fine-tune \Asymptote\ output. We
provide some default styles, a user may customise them according to
existing needs.

@  We define a type for producing colouring scheme for \Asymptote\ drawing.
<<asy styles>>=
using asy_style=std::function<string(const ex &, const ex &, lst &)>;
//typedef string (*asy_style)(const ex &, const ex &, lst &);
inline string no_color(const ex & label, const ex & C, lst & color) {color=lst{0,0,0}; return "";}
string asy_cycle_color(const ex & label, const ex & C, lst & color);
const asy_style default_asy=asy_cycle_color;

@ Similarly we produce a default labelling style.
<<asy styles>>=
using label_string=std::function<string(const ex &, const ex &, const string)>;
string label_pos(const ex & label, const ex & C, const string draw_str);
inline string no_label(const ex & label, const ex & C, const string draw_str) {return "";}
const label_string default_label=label_pos;

@
\section{Implementation of Classes}
\label{sec:impl-class}

@ This is the outline of the code.
<<figure.cpp>>=
<<license>>
#include <iostream>

#if __cplusplus >= 201703L
  #include <filesystem>
#endif

#include "figure.h"

namespace MoebInv {
using namespace std;
using namespace GiNaC;
<<figure library variables and constants>>
<<GiNaC declarations>>
<<auxillary function>>
<<add cycle relations>>
<<cycle data class>>
<<cycle relation class>>
<<subfigure class>>
<<cycle node class>>
<<figure class>>
<<addional functions>>
} // namespace MoebInv

@
<<figure library variables and constants>>=
unsigned do_not_update_subfigure = 0x0100;

@ This can de defined [[false]] to prevent some diagnostic output to [[std::cerr]].
<<figure library variables and constants>>=
bool FIGURE_DEBUG=true;
@ %def FIGURE_DEBUG

@ This can de defined [[false]] to prevent some diagnostic output to [[std::cerr]].
<<figure library variables and constants>>=
bool show_asy_graphics=true;
@ %def show_asy_graphics

@ We use \GiNaC\ implementation macros for our classes.
<<GiNaC declarations>>=
GINAC_IMPLEMENT_REGISTERED_CLASS_OPT(cycle_data, basic,
									 print_func<print_dflt>(&cycle_data::do_print))

GINAC_IMPLEMENT_REGISTERED_CLASS_OPT(cycle_relation, basic,
									 print_func<print_dflt>(&cycle_relation::do_print).
print_func<print_tree>(&cycle_relation::do_print_tree))

GINAC_IMPLEMENT_REGISTERED_CLASS_OPT(subfigure, basic,
									 print_func<print_dflt>(&subfigure::do_print))

GINAC_IMPLEMENT_REGISTERED_CLASS_OPT(cycle_node, basic,
									 print_func<print_dflt>(&cycle_node::do_print).
print_func<print_tree>(&cycle_relation::do_print_tree))

GINAC_IMPLEMENT_REGISTERED_CLASS_OPT(figure, basic,
									 print_func<print_dflt>(&figure::do_print))

@ Exact solving of quadratic equations is not always practical, thus
we relay on some rounding methods. If the outcome is not good for you
increase the precision with [[GiNaC::Digits]].
<<auxillary function>>=
const ex epsilon=GiNaC::pow(10,-Digits/2);
@ %def epsilon

@ an auxillary function to find small numbers
<<auxillary function>>=
bool is_less_than_epsilon(const ex & x)
{
		return ( x.is_zero() || abs(x).evalf() < epsilon ) ;
}
@ %def is_less_than_epsilon

@

\subsection{Implementation of [[cycle_data]] class}
\label{sec:impl-cycl-class}

@ Constructors
<<cycle data class>>=
cycle_data::cycle_data() : k_cd(), l_cd(), m_cd()
{
	;
}

@ Constructors
<<cycle data class>>=
cycle_data::cycle_data(const ex & C)
{
	if (is_a<cycle>(C)) {
		cycle C_new=ex_to<cycle>(C).normalize();
		<<cycle data class constructor common>>

@ This part of the code will be recycled.
<<cycle data class constructor common>>=
		k_cd=C_new.get_k();
		l_cd=C_new.get_l();
		m_cd=C_new.get_m();

@ similarly we copy [[cycle_data]] object.
<<cycle data class>>=
	} else if (is_a<cycle_data>(C)) {
		cycle_data C_new=ex_to<cycle_data>(C);
		<<cycle data class constructor common>>
	} else
		throw(std::invalid_argument("cycle_data(): accept only cycle or cycle_data"
									" as the parameter"));
}

@ Constructors.
<<cycle data class>>=
cycle_data::cycle_data(const ex & k1, const ex l1, const ex &m1, bool normalize)
{
	k_cd = k1;
	l_cd = l1;
	m_cd = m1;
	if (normalize) {
		ex ratio = 0;
		if (!k_cd.is_zero()) // First non-zero coefficient among k_cd, m_cd, l_0, l_1, ... is set to 1
			ratio = k_cd;
		else if (!m_cd.is_zero())
			ratio = m_cd;
		else {
			for (unsigned int i=0; i<get_dim(); i++)
				if (!l_cd.subs(l_cd.op(1) == i).is_zero()) {
					ratio = l_cd.subs(l_cd.op(1) == i);
					break;
				}
		}

		if (!ratio.is_zero()) {
			k_cd=(k_cd/ratio).normal();
			l_cd=indexed((l_cd.op(0)/ratio).evalm().normal(), l_cd.op(1));
			m_cd=(m_cd/ratio).normal();
		}
	}
}

@
<<cycle data class>>=
return_type_t cycle_data::return_type_tinfo() const
{
	return make_return_type_t<cycle_data>();
}

@
<<cycle data class>>=
int cycle_data::compare_same_type(const basic &other) const
{
       GINAC_ASSERT(is_a<cycle_data>(other));
	   return inherited::compare_same_type(other);
}


@ Printing the cycle data
<<cycle data class>>=
void cycle_data::do_print(const print_dflt & con, unsigned level) const
{
	con.s << "`";
	this->k_cd.print(con, level);
	con.s << ", ";
	this->l_cd.print(con, level);
	con.s << ", ";
	this->m_cd.print(con, level);
	con.s << "'";
}

@ Printing the cycle data in the float mode if possible.
<<cycle data class>>=
void cycle_data::do_print_double(const print_dflt & con, unsigned level) const
{
	if (! is_a<numeric>(get_dim())) {
		do_print(con, level);
	} else {

@ Check if conversion to double is possible and accurate.
<<cycle data class>>=
		con.s << "(";
		if ((is_a<numeric>(k_cd) && ! ex_to<numeric>(k_cd).is_crational())
			|| is_a<numeric>(k_cd.evalf())) {
			ex f=k_cd.evalf();
			<<common part of float output>>

@ Here is the repeating part
<<common part of float output>>=
			con.s << ex_to<numeric>(f).to_double(); // only real part is converted
			if (! ex_to<numeric>(f).is_real()) {
				double b=ex_to<numeric>(f.imag_part()).to_double();
				if (b>0)
					con.s << "+";
				con.s << b << "*I";
			}

@ back to our routine.
<<cycle data class>>=
		} else
			k_cd.print(con, level);
		con.s << ", [[";

@ Run through all elements of the [[l]] vector.
<<cycle data class>>=
		int D=ex_to<numeric>(get_dim()).to_int();
		for(int i=0; i< D; ++i) {
			if ((is_a<numeric>(l_cd.op(0).op(i)) && ! ex_to<numeric>(l_cd.op(0).op(i)).is_crational())
				|| is_a<numeric>(l_cd.op(0).op(i).evalf())) {
				ex f=ex_to<numeric>(l_cd.op(0).op(i)).evalf();
				<<common part of float output>>
			} else
				l_cd.op(0).op(i).print(con, level);
			if (i<D-1)
				con.s << ",";
		}
		con.s << "]]";
		l_cd.op(1).print(con, level);

@ Finishing with the [[m]] part.
<<cycle data class>>=
		con.s << ", ";
		if ((is_a<numeric>(m_cd) && ! ex_to<numeric>(m_cd).is_crational())
			|| is_a<numeric>(m_cd.evalf())) {
			ex f=m_cd.evalf();
			<<common part of float output>>
		} else
			m_cd.print(con, level);
		con.s << ")";
	}
}

@
<<cycle data class>>=
void cycle_data::archive(archive_node &n) const
{
	inherited::archive(n);
	n.add_ex("k-val", k_cd);
	n.add_ex("l-val", l_cd);
	n.add_ex("m-val", m_cd);
}

@
<<cycle data class>>=
void cycle_data::read_archive(const archive_node &n, lst &sym_lst)
{
	inherited::read_archive(n, sym_lst);
	n.find_ex("k-val", k_cd, sym_lst);
	n.find_ex("l-val", l_cd, sym_lst);
	n.find_ex("m-val", m_cd, sym_lst);
}

@
<<cycle data class>>=
GINAC_BIND_UNARCHIVER(cycle_data);

@
<<cycle data class>>=
ex cycle_data::op(size_t i) const
{
 GINAC_ASSERT(i<nops());
	switch(i) {
	case 0:
		return k_cd;
	case 1:
		return l_cd;
	case 2:
		return m_cd;
	default:
		throw(std::invalid_argument("cycle_data::op(): requested operand out of the range (3)"));
	}
}

@
<<cycle data class>>=
ex & cycle_data::let_op(size_t i)
{
	ensure_if_modifiable();
	GINAC_ASSERT(i<nops());
	switch(i) {
	case 0:
		return k_cd;
	case 1:
		return l_cd;
	case 2:
		return m_cd;
	default:
		throw(std::invalid_argument("cycle_data::let_op(): requested operand out of the range (3)"));
	}
}

@
<<cycle data class>>=
ex cycle_data::make_cycle(const ex & metr) const
{
	return cycle(k_cd, l_cd, m_cd, metr);
}

@
<<cycle data class>>=
bool cycle_data::is_equal(const basic & other, bool projectively) const
{
	if (not is_a<cycle_data>(other))
		return false;
	const cycle_data o = ex_to<cycle_data>(other);
	ex factor=0, ofactor=0;

	if (projectively) {
		// Check that coefficients are scalar multiples of other
		if (not ((m_cd*o.get_k()-o.get_m()*k_cd).normal().is_zero()))
			return false;
		// Set up coefficients for proportionality
		if (get_k().normal().is_zero()) {
			factor=get_m();
			ofactor=o.get_m();
		} else {
			factor=get_k();
			ofactor=o.get_k();
		}

	} else
		// Check the exact equality of coefficients
		if (not ((get_k()-o.get_k()).normal().is_zero()
				 && (get_m()-o.get_m()).normal().is_zero()))
			return false;


@ Now we iterate through the coefficients of [[l]].
<<cycle data class>>=
	for (unsigned int i=0; i<get_dim(); i++)
		if (projectively) {
			// search the the first non-zero coefficient
			if (factor.is_zero()) {
				factor=get_l(i);
				ofactor=o.get_l(i);
			} else
				if (! (get_l(i)*ofactor-o.get_l(i)*factor).normal().is_zero())
					return false;
		} else
			if (! (get_l(i)-o.get_l(i)).normal().is_zero())
				return false;

	return true;
}

@
<<cycle data class>>=
bool cycle_data::is_almost_equal(const basic & other, bool projectively) const
{
	if (not is_a<cycle_data>(other))
		return false;
	const cycle_data o = ex_to<cycle_data>(other);
	ex factor=0, ofactor=0;

	if (projectively) {
		// Check that coefficients are scalar multiples of other
		if (! (is_less_than_epsilon(m_cd*o.get_k()-o.get_m()*k_cd)))
			return false;
		// Set up coefficients for proportionality
		if (is_less_than_epsilon(get_k())) {
			factor=get_m();
			ofactor=o.get_m();
		} else {
			factor=get_k();
			ofactor=o.get_k();
		}

	} else
		// Check the exact equality of coefficients
		if (! (is_less_than_epsilon((get_k()-o.get_k()))
				 && is_less_than_epsilon(get_m()-o.get_m())))
			return false;


@ Now we iterate through the coefficients of [[l]].
<<cycle data class>>=
	for (unsigned int i=0; i<get_dim(); i++)
		if (projectively) {
			// search the the first non-zero coefficient
			if (factor.is_zero()) {
				factor=get_l(i);
				ofactor=o.get_l(i);
			} else
				if (! is_less_than_epsilon(get_l(i)*ofactor-o.get_l(i)*factor))
					return false;
		} else
			if (! is_less_than_epsilon(get_l(i)-o.get_l(i)))
				return false;

	return true;
}

@
<<cycle data class>>=
cycle_data cycle_data::subs(const ex & e, unsigned options) const
{
	return cycle_data(k_cd.subs(e,options),l_cd.subs(e,options),m_cd.subs(e,options),false);
}
@
<<cycle data class>>=
ex cycle_data::subs(const exmap & em, unsigned options) const
{
	return cycle_data(k_cd.subs(em,options),l_cd.subs(em,options),m_cd.subs(em,options),false);
}

@
<<cycle data class>>=
ex cycle_data::num_normalize() const
{
	if (! (is_a<numeric>(k_cd) && is_a<numeric>(m_cd)
		   && is_a<numeric>(l_cd.op(0).op(0))  && is_a<numeric>(l_cd.op(0).op(1))))
		return cycle_data(k_cd,l_cd,m_cd,true);

	numeric k1=ex_to<numeric>(k_cd),
		m1=ex_to<numeric>(m_cd);
	numeric r=max(abs(k1),abs(m1));
	for (unsigned int i=0; i<get_dim(); ++i)
		r=max(r,abs(ex_to<numeric>(l_cd.op(0).op(i))));

	if (is_less_than_epsilon(r))
		return cycle_data(k_cd,l_cd,m_cd,true);
	k1/=r; k1=(is_less_than_epsilon(k1)?0:k1);
	m1/=r; m1=(is_less_than_epsilon(m1)?0:m1);
	lst l1;
	for (unsigned int i=0; i<get_dim(); ++i) {
		numeric li= ex_to<numeric>(l_cd.op(0).op(i))/r;
		l1.append(is_less_than_epsilon(li)?0:li);
	}

	return cycle_data(k1,indexed(matrix(1, get_dim(), l1), l_cd.op(1)),m1);
}

@
\subsection{Implementation of [[cycle_relation]] class}
\label{sec:impl-cycl}

@
<<cycle relation class>>=
cycle_relation::cycle_relation() : parkey(), parameter()
{
  rel = cycle_orthogonal;
  use_cycle_metric = true;
}

@
<<cycle relation class>>=
cycle_relation::cycle_relation(const ex & ck, PCR r, bool cm, const ex & p) {
	parkey = ck;
	rel = r;
	use_cycle_metric = cm;
	parameter=p;
}

@
<<cycle relation class>>=
return_type_t cycle_relation::return_type_tinfo() const
{
	return make_return_type_t<cycle_relation>();
}

@
<<cycle relation class>>=
int cycle_relation::compare_same_type(const basic &other) const
{
       GINAC_ASSERT(is_a<cycle_relation>(other));
	   return inherited::compare_same_type(other);
	   /*
  const cycle_relation &o = static_cast<const cycle_relation &>(other);
	if ((parkey == o.parkey) && (&rel == &o.rel))
		return 0;
	else if ((parkey < o.parkey) || (&rel < &o.rel))
		return -1;
	else
	return 1;*/
}

@ (un)Archiving of [[cycle_relation]] is not universal. At present it
only can handle relations declared in the header file: [[cycle_orthogonal]],
[[cycle_f_orthogonal]], [[cycle_adifferent]], [[cycle_different]] and [[cycle_tangent]].
<<cycle relation class>>=
void cycle_relation::archive(archive_node &n) const
{
	inherited::archive(n);
	n.add_ex("cr-parkey", parkey);
	n.add_bool("use_cycle_metric", use_cycle_metric);
	n.add_ex("parameter", parameter);
	ex (*const* ptr)(const ex &, const ex &, const ex &)
		= rel.target<ex(*)(const ex&, const ex &,const ex&)>();
	if (ptr && *ptr == cycle_orthogonal)
		n.add_string("relation", "orthogonal");
	else if (ptr && *ptr == cycle_f_orthogonal)
		n.add_string("relation", "f_orthogonal");
	else if (ptr && *ptr == cycle_different)
		n.add_string("relation", "different");
	else if (ptr && *ptr == cycle_adifferent)
		n.add_string("relation", "adifferent");
	else if (ptr && *ptr == cycle_tangent)
		n.add_string("relation", "tangent");
	else if (ptr && *ptr == cycle_tangent_i)
		n.add_string("relation", "tangent_i");
	else if (ptr && *ptr == cycle_tangent_o)
		n.add_string("relation", "tangent_o");
	else if (ptr && *ptr == cycle_angle)
		n.add_string("relation", "angle");
	else if (ptr && *ptr == steiner_power)
		n.add_string("relation", "steiner_power");
	else if (ptr && *ptr == cycle_cross_t_distance)
		n.add_string("relation", "cross_distance");
	else if (ptr && *ptr == product_sign)
		n.add_string("relation", "product_sign");
	else if (ptr && *ptr == coefficients_are_real)
		n.add_string("relation", "are_real");
	else if (ptr && *ptr == cycle_moebius)
		n.add_string("relation", "moebius");
	else if (ptr && *ptr == cycle_sl2)
		n.add_string("relation", "sl2");
	else
		throw(std::invalid_argument("cycle_relation::archive(): archiving of this relation is not"
									" implemented"));
}

@
<<cycle relation class>>=
void cycle_relation::read_archive(const archive_node &n, lst &sym_lst)
{
	ex e;
	inherited::read_archive(n, sym_lst);
	n.find_ex("cr-parkey", e, sym_lst);
	if (is_a<symbol>(e))
		parkey=e;
	else
		throw(std::invalid_argument("cycle_relation::read_archive(): read a non-symbol as"
									" a parkey from the archive"));
	n.find_ex("parameter", parameter, sym_lst);
	n.find_bool("use_cycle_metric", use_cycle_metric);
	string relation;
	n.find_string("relation", relation);
	if (relation == "orthogonal")
		rel = cycle_orthogonal;
	else if (relation == "f_orthogonal")
		rel = cycle_f_orthogonal;
	else if (relation == "different")
		rel = cycle_different;
	else if (relation == "adifferent")
		rel = cycle_adifferent;
	else if (relation == "tangent")
		rel = cycle_tangent;
	else if (relation == "tangent_i")
		rel = cycle_tangent_i;
	else if (relation == "tangent_o")
		rel = cycle_tangent_o;
	else if (relation == "angle")
		rel = cycle_angle;
	else if (relation == "steiner_power")
		rel = steiner_power;
	else if (relation == "cross_distance")
		rel = cycle_cross_t_distance;
	else if (relation == "product_sign")
		rel = product_sign;
	else if (relation == "are_real")
		rel = coefficients_are_real;
	else if (relation == "moebius")
		rel = cycle_moebius;
	else if (relation == "sl2")
		rel = cycle_sl2;
	else
		throw(std::invalid_argument("cycle_relation::read_archive(): archive contains unknown"
									" relation"));
}

@
<<cycle relation class>>=
GINAC_BIND_UNARCHIVER(cycle_relation);

@
<<cycle relation class>>=
ex cycle_relation::rel_to_parent(const ex & C1, const ex & pmetric, const ex & cmetric,
								 const exhashmap<cycle_node> & N) const
{
       GINAC_ASSERT(is_a<cycle_data>(C1));

@ First we check if the required key exists in the cycles list. If
there is no such key, we return the relation to the calling cycle itself.
<<cycle relation class>>=
	exhashmap<cycle_node>::const_iterator  cnode=N.find(parkey);

@ Otherwise the list of equations is constructed for the found key.
<<cycle relation class>>=
	lst res,
		cycles=ex_to<lst>(cnode->second.make_cycles(use_cycle_metric? cmetric : pmetric));

	for (const auto& it : cycles) {
		lst calc=ex_to<lst>(rel(ex_to<cycle_data>(C1).make_cycle(use_cycle_metric? cmetric : pmetric),
								ex_to<cycle>(it), parameter));
		for (const auto& it1 : calc)
			res.append(it1);
	}
	return res;
}

@
<<cycle relation class>>=
void cycle_relation::do_print(const print_dflt & con, unsigned level) const
{
	con.s << parkey << (use_cycle_metric? "|" : "/");
	ex (*const* ptr)(const ex &, const ex &, const ex &)
		= rel.target<ex(*)(const ex&, const ex &, const ex &)>();
	if (ptr && *ptr == cycle_orthogonal)
		con.s << "o";
	else if (ptr && *ptr == cycle_f_orthogonal)
		con.s << "f";
	else if (ptr && *ptr == cycle_different)
		con.s << "d";
	else if (ptr && *ptr == cycle_adifferent)
		con.s << "ad";
	else if (ptr && *ptr == cycle_tangent)
		con.s << "t";
	else if (ptr && *ptr == cycle_tangent_i)
		con.s << "ti";
	else if (ptr && *ptr == cycle_tangent_o)
		con.s << "to";
	else if (ptr && *ptr == steiner_power)
		con.s << "s";
	else if (ptr && *ptr == cycle_angle)
		con.s << "a";
	else if (ptr && *ptr == cycle_cross_t_distance)
		con.s << "c";
	else if (ptr && *ptr == product_sign)
		con.s << "p";
	else if (ptr && *ptr == coefficients_are_real)
		con.s << "r";
	else if (ptr && *ptr == cycle_moebius)
		con.s << "m";
	else if (ptr && *ptr == cycle_sl2)
		con.s << "l";
	else
		con.s << "u"; // unknown type of relations
	if (! parameter.is_zero())
		con.s << "[" << parameter << "]";
}

@
<<cycle relation class>>=
void cycle_relation::do_print_tree(const print_tree & con, unsigned level) const
{
	//	inherited::do_print_tree(con,level);
	parkey.print(con,level+con.delta_indent);
	//	con.s <<  std::string(level+con.delta_indent, ' ') << (int)rel <<endl;
}

@
<<cycle relation class>>=
ex cycle_relation::op(size_t i) const
{
 GINAC_ASSERT(i<nops());
	switch(i) {
	case 0:
		return parkey;
	case 1:
		return parameter;
	default:
		throw(std::invalid_argument("cycle_relation::op(): requested operand out of the range (1)"));
	}
}

@
<<cycle relation class>>=
ex & cycle_relation::let_op(size_t i)
{
	ensure_if_modifiable();
	GINAC_ASSERT(i<nops());
	switch(i) {
	case 0:
		return parkey;
	case 1:
		return parameter;
	default:
		throw(std::invalid_argument("cycle_relation::let_op(): requested operand out of the range (1)"));
	}
}

@

\subsection{Implementation of [[subfigure]] class}
\label{sec:impl-subf-class}

@
<<subfigure class>>=
subfigure::subfigure() : inherited()
{
}

@
<<subfigure class>>=
subfigure::subfigure(const ex & F, const ex & l) {
	parlist = ex_to<lst>(l);
	subf = F;
}

@
<<subfigure class>>=
return_type_t subfigure::return_type_tinfo() const
{
	return make_return_type_t<subfigure>();
}

@
<<subfigure class>>=
int subfigure::compare_same_type(const basic &other) const
{
       GINAC_ASSERT(is_a<subfigure>(other));
	   return inherited::compare_same_type(other);
}

@ (un)Archiving of [[subfigure]] is not universal. At present it
only can handle relations declared in the header file: [[cycle_orthogonal]]
and [[cycle_f_orthogonal]].

<<subfigure class>>=
void subfigure::archive(archive_node &n) const
{
	inherited::archive(n);
	n.add_ex("parlist", ex_to<lst>(parlist));
	n.add_ex("subf", ex_to<figure>(subf));
}

@
<<subfigure class>>=
void subfigure::read_archive(const archive_node &n, lst &sym_lst)
{
	ex e;
	inherited::read_archive(n, sym_lst);
	n.find_ex("parlist", e, sym_lst);
	if (is_a<lst>(e))
		parlist=ex_to<lst>(e);
	else
		throw(std::invalid_argument("subfigure::read_archive(): read a non-lst as a parlist from"
									" the archive"));
	n.find_ex("subf", e, sym_lst);
	if (is_a<figure>(e))
		subf=ex_to<figure>(e);
	else
		throw(std::invalid_argument("subfigure::read_archive(): read a non-figure as a subf from"
									" the archive"));
}

@
<<subfigure class>>=
GINAC_BIND_UNARCHIVER(subfigure);

@
<<subfigure class>>=
void subfigure::do_print(const print_dflt & con, unsigned level) const
{
	con.s << "subfig( " ;
        parlist.print(con, level+1);
		//        subf.print(con, level+1);
	con.s << ")" ;
}

@
<<subfigure class>>=
inline ex subfigure::subs(const exmap & em, unsigned options) const {
	return subfigure(subf.subs(em,options | do_not_update_subfigure), parlist);
}

@
\subsection{Implementation of [[cycle_node]] class}
\label{sec:impem-cycl}

@ Default constructor.
<<cycle node class>>=
cycle_node::cycle_node()
{
	generation=0;
	custom_asy="";
}

@ Create a [[cycle_node]] out of [[cycle]] or [[cycle_node]].
<<cycle node class>>=
cycle_node::cycle_node(const ex & C, int g)
{
	custom_asy="";
	generation=g;
	<<set cycle data to the node>>
}

@ We use this check to initialise or change cycle info of the node.
<<set cycle data to the node>>=
	if (is_a<cycle_node>(C)) {
		cycles=ex_to<lst>(ex_to<cycle_node>(C).get_cycles_data());
		generation = ex_to<cycle_node>(C).get_generation();
		children = ex_to<cycle_node>(C).get_children();
		parents = ex_to<cycle_node>(C).get_parents();
	} else
		<<check cycles are valid>>

@
<<cycle node class>>=
cycle_node::cycle_node(const ex & C, int g, const lst & par)
{
	custom_asy="";
	generation=g;
	<<check cycles are valid>>
	<<check parents are valid>>
}

@
<<check cycles are valid>>=
 	if (is_a<lst>(C)) {
		for (const auto& it : ex_to<lst>(C))
			if ( is_a<cycle_data>(it) || is_a<cycle>(it))
				cycles.append(cycle_data(it));
			else
				throw(std::invalid_argument("cycle_node::cycle_node(): "
											"the parameter is list of something which is not"
											" cycle_data"));
	} else if (is_a<cycle_data>(C)) {
		cycles = lst{C};
	} else if (is_a<cycle>(C)) {
		cycles=lst{cycle_data(ex_to<cycle>(C).get_k(), ex_to<cycle>(C).get_l(),
							  ex_to<cycle>(C).get_m())};
	} else
		throw(std::invalid_argument("cycle_node::cycle_node(): "
									"the first parameters must be either cycle, cycle_data,"
									" cycle_node or list of cycle_data"));

@
<<check parents are valid>>=
	GINAC_ASSERT(is_a<lst>(par));
	parents = ex_to<lst>(par);

@
<<cycle node class>>=
cycle_node::cycle_node(const ex & C, int g, const lst & par, const lst & ch)
{
	generation=g;
	children=ch;
	custom_asy="";
	<<check cycles are valid>>
	<<check parents are valid>>
}

@
<<cycle node class>>=
cycle_node::cycle_node(const ex & C, int g, const lst & par, const lst & ch, string ca)
{
	generation=g;
	children=ch;
	custom_asy=ca;
	<<check cycles are valid>>
	<<check parents are valid>>
}

@
<<cycle node class>>=
return_type_t cycle_node::return_type_tinfo() const
{
	return make_return_type_t<cycle_node>();
}

@
<<cycle node class>>=
ex cycle_node::op(size_t i) const
{
	GINAC_ASSERT(i<nops());
	size_t ncyc=cycles.nops(), nchil=children.nops(), npar=parents.nops();
	if ( i < ncyc)
		return cycles.op(i);
	else if ( i < ncyc + nchil)
		return children.op(i-ncyc);
	else if ( i < ncyc + nchil + npar)
		return parents.op(i-ncyc-nchil);
	else
		throw(std::invalid_argument("cycle_node::op(): requested operand out of the range"));
}

@
<<cycle node class>>=
ex & cycle_node::let_op(size_t i)
{
	ensure_if_modifiable();
	GINAC_ASSERT(i<nops());
	size_t ncyc=cycles.nops(), nchil=children.nops(), npar=parents.nops();
	if ( i < ncyc)
		return cycles.let_op(i);
	else if ( i < ncyc + nchil)
		return children.let_op(i-ncyc);
	else if ( i < ncyc + nchil + npar)
		return parents.let_op(i-ncyc-nchil);
	else
		throw(std::invalid_argument("cycle_node::let_op(): requested operand out of the range"));
}

@
<<cycle node class>>=
int cycle_node::compare_same_type(const basic &other) const
{
       GINAC_ASSERT(is_a<cycle_node>(other));
	   return inherited::compare_same_type(other);
}

@ If neither of parameters has multiply values we return a cycle.
<<cycle node class>>=
ex cycle_node::make_cycles(const ex & metr) const
{
	lst res;
	for (const auto&  it : cycles)
		res.append(ex_to<cycle_data>(it).make_cycle(metr));
	return res;
}

@
<<cycle node class>>=
void cycle_node::set_cycles(const ex & C)
{
	cycles.remove_all();
	<<check cycles are valid>>
}

@
<<cycle node class>>=
void cycle_node::append_cycle(const ex & k, const ex & l, const ex & m)
{
	cycles.append(cycle_data(k,l,m));
}

@
<<cycle node class>>=
void cycle_node::append_cycle(const ex & C)
{
	if (is_a<cycle>(C))
		cycles.append(cycle_data(ex_to<cycle>(C).get_k(), ex_to<cycle>(C).get_l(),
								   ex_to<cycle>(C).get_m()));
	else 	if (is_a<cycle_data>(C))
		cycles.append(ex_to<cycle_data>(C));
	else
		throw(std::invalid_argument("cycle_node::append_cycle(const ex &): the parameter must be"
									" either cycle or cycle_data"));
}

@ Return the list of parents---either [[cycle_relations]] or [[subfigure]]
<<cycle node class>>=
lst cycle_node::get_parents() const
{
	return parents;
}

@ The method returns the list of all keys to parant cycles.
<<cycle node class>>=
lst cycle_node::get_parent_keys() const
{
	lst pkeys;
	if ( (parents.nops() == 1) && (is_a<subfigure>(parents.op(0)))) {
		pkeys=ex_to<lst>(ex_to<subfigure>(parents.op(0)).get_parlist());
	} else {
		for (const auto& it : parents)
			pkeys.append(ex_to<cycle_relation>(it).get_parkey());
	}
	return pkeys;
}

@ Printing of a [[cycle_node]] has two almost identical form: accurate
and float.
<<cycle node class>>=
void cycle_node::do_print(const print_dflt & con, unsigned level) const
{
	<<start to print cycle node>>
		ex_to<cycle_data>(it).do_print(con, level);
		<<end to print cycle node>>
}

@ And a similar one for the float printing
<<cycle node class>>=
void cycle_node::do_print_double(const print_dflt & con, unsigned level) const
{
	<<start to print cycle node>>
		ex_to<cycle_data>(it).do_print_double(con, level);
		<<end to print cycle node>>
}

@ We output generation and all children, \ldots
<<start to print cycle node>>=
	con.s << '{';
	for (const auto& it : cycles) {

@
<<end to print cycle node>>=
		con.s << ", ";
	}
	con.s << generation << '}' << " --> (";
	// list all children
	for (lst::const_iterator it = children.begin(); it != children.end();) {
		con.s << (*it);
		++it;
		if (it != children.end())
			con.s <<",";
	}

@ \ldots then all parents.
<<end to print cycle node>>=
	con.s << ");  <-- (";
	if (generation > 0 || FIGURE_DEBUG)
		for (lst::const_iterator it = parents.begin(); it != parents.end();) {
			if (is_a<cycle_relation>(*it))
				ex_to<cycle_relation>(*it).do_print(con,level);
			else if (is_a<subfigure>(*it))
				ex_to<subfigure>(*it).do_print(con,level);
			++it;
			if (it != parents.end())
				con.s <<",";
		}
	con.s << ")";

@ Finally if the custom \Asymptote\ style is not empty we print it as well.
<<end to print cycle node>>=
	if (custom_asy != "")
		con.s<< " /" << custom_asy << "/";
	con.s << endl;

@
<<cycle node class>>=
void cycle_node::do_print_tree(const print_tree & con, unsigned level) const
{
	for (const auto& it : cycles)
		it.print(con, level);
	con.s << std::string(level+con.delta_indent, ' ') << "generation: "<< generation << endl;
	con.s << std::string(level+con.delta_indent, ' ') << "children" <<endl;
	children.print(con,level+2*con.delta_indent);
	con.s << std::string(level+con.delta_indent, ' ') << "parents" <<endl;
	parents.print(con,level+2*con.delta_indent);
	con.s << std::string(level+con.delta_indent, ' ') << "custom_asy: " << custom_asy <<endl;
}

@
<<cycle node class>>=
void cycle_node::remove_child(const ex & other)
{
	lst nchildren;
	for (const auto& it : children)
	    if (it != other)
			nchildren.append(it);
	children=nchildren;
}

@
<<cycle node class>>=
cycle_node cycle_node::subs(const ex & e, unsigned options) const
{
	exmap em;
	if (e.info(info_flags::list)) {
		lst l = ex_to<lst>(e);
		for (const auto& i : l)
			em.insert(std::make_pair(i.op(0), i.op(1)));
	} else if (is_a<relational>(e)) {
		em.insert(std::make_pair(e.op(0), e.op(1)));
	} else
		throw(std::invalid_argument("cycle::subs(): the parameter should be a relational or a lst"));

	return ex_to<cycle_node>(subs(em, options));
}

@
<<cycle node class>>=
ex cycle_node::subs(const exmap & em, unsigned options) const
{
	return cycle_node(cycles.subs(em, options), generation, ex_to<lst>(parents.subs(em, options)), children, custom_asy);
}

@
<<cycle node class>>=
void cycle_node::archive(archive_node &n) const
{
	inherited::archive(n);
	n.add_ex("cycles", cycles);
	n.add_unsigned("children_size", children.nops());
	if (children.nops()>0)
		for (const auto& it : children)
			n.add_ex("chil", it);

	n.add_unsigned("parent_size", parents.nops());
	if (parents.nops()>0) {
		n.add_bool("has_subfigure", false);
		for (const auto& it : parents)
			n.add_ex("par", ex_to<cycle_relation>(it));
	}

@ storing the generation with its sign.
<<cycle node class>>=
	bool neg_generation=(generation<0);
	n.add_bool("neg_generation", neg_generation);
	if (neg_generation)
		n.add_unsigned("abs_generation", -generation);
	else
		n.add_unsigned("abs_generation", generation);

@ saving the asymptote options
<<cycle node class>>=
	n.add_string("custom_asy", custom_asy);
}

@
<<cycle node class>>=
void cycle_node::read_archive(const archive_node &n, lst &sym_lst)
{
	inherited::read_archive(n, sym_lst);
	ex e;
	n.find_ex("cycles", e, sym_lst);
	cycles=ex_to<lst>(e);
	ex ch, par;
	unsigned int c_size;
	n.find_unsigned("children_size", c_size);

	if (c_size>0) {
		archive_node::archive_node_cit first = n.find_first("chil");
		archive_node::archive_node_cit last = n.find_last("chil");
		++last;
		for (archive_node::archive_node_cit i=first; i != last; ++i) {
			ex e;
			n.find_ex_by_loc(i, e, sym_lst);
			children.append(e);
		}
	}

	unsigned int p_size;
	n.find_unsigned("parent_size", p_size);

	if (p_size>0) {
		archive_node::archive_node_cit first = n.find_first("par");
		archive_node::archive_node_cit last = n.find_last("par");
		++last;
		for (archive_node::archive_node_cit i=first; i != last; ++i) {
			ex e;
			n.find_ex_by_loc(i, e, sym_lst);
			parents.append(e);
		}
	}

@ restoring the generation with its sign
<<cycle node class>>=
	bool neg_generation;
	n.find_bool("neg_generation", neg_generation);
	unsigned int abs_generation;
	n.find_unsigned("abs_generation", abs_generation);
	if (neg_generation)
		generation = -abs_generation;
	else
		generation = abs_generation;

@ restoring the asymptote options
<<cycle node class>>=
	n.find_string("custom_asy", custom_asy);
}

@
<<cycle node class>>=
GINAC_BIND_UNARCHIVER(cycle_node);

@
\subsection{Implementation of [[figure]] class}
\label{sec:implem-figure-class}

Since this is the main class of the library, its implementation is
most evolved.

@
\subsubsection{[[figure]] conctructors}
\label{sec:figure-conctructors}

@ We create a figure with two initial objects: the cycle at infinity
and the real line.
<<figure class>>=
figure::figure() : inherited(), k(realsymbol("k")), m(realsymbol("m")), l()
{
	l.append(realsymbol("l0"));
	l.append(realsymbol("l1"));
	infinity=symbol("infty","\\infty");
	real_line=symbol("R","\\mathbf{R}");
	point_metric = clifford_unit(varidx(real_line, 2), indexed(-(new tensdelta)->setflag(status_flags::dynallocated),
															   sy_symm(), varidx(symbol("i"), 2), varidx(symbol("j"), 2)));
	cycle_metric = clifford_unit(varidx(real_line, 2), indexed(-(new tensdelta)->setflag(status_flags::dynallocated),
															   sy_symm(), varidx(symbol("ic"), 2), varidx(symbol("jc"), 2)));
	<<set the infinity>>
	<<set the real line>>
}
@ %def figure

@ Dimension of the fiigure is taken and the respective vector is created.
<<initialise the dimension and vector>>=
   unsigned int dim=ex_to<numeric>(get_dim()).to_int();
   lst l0;
   for(unsigned int i=0; i<dim; ++i)
	   l0.append(0);

@
<<set the infinity>>=
   <<initialise the dimension and vector>>
   nodes[infinity] = cycle_node(cycle_data(numeric(0),indexed(matrix(1, dim, l0),
															  varidx(infinity, dim)),numeric(1)),INFINITY_GEN);

@
<<set the real line>>=
	l0.remove_last();
	l0.append(1);
	nodes[real_line] = cycle_node(cycle_data(numeric(0),indexed(matrix(1, dim, l0),
																	varidx(real_line, dim)),numeric(0)),REAL_LINE_GEN);

@ This constructor may be called with several different inputs.
<<figure class>>=
figure::figure(const ex & Mp, const ex & Mc) : inherited(), k(realsymbol("k")), m(realsymbol("m")), l()
{
	infinity=symbol("infty","\\infty");
	real_line=symbol("R","\\mathbf{R}");
	bool inf_missing=true, R_missing=true;
	<<set point metric in figure>>

@ Below are various parameters which can define a metric in the same
way as it used to create a [[cliffordunit]] object in \GiNaC. The
point metric is indexed by the key of the real line and the cycle
metric---by the key of the zero-radius cycle at infinity.
<<set point metric in figure>>=
if (is_a<clifford>(Mp)) {
	point_metric = clifford_unit(varidx(real_line,
										ex_to<idx>(ex_to<clifford>(Mp).get_metric().op(1)).get_dim()),
								 ex_to<clifford>(Mp).get_metric());
 } else if (is_a<matrix>(Mp)) {
	ex D;
	if (ex_to<matrix>(Mp).rows() == ex_to<matrix>(Mp).cols())
		D=ex_to<matrix>(Mp).rows();
	else
		throw(std::invalid_argument("figure::figure(const ex &, const ex &):"
									" only square matrices are admitted as point metric"));
	point_metric = clifford_unit(varidx(real_line, D), indexed(Mp, sy_symm(), varidx(symbol("i"), D), varidx(symbol("j"), D)));
 } else if (is_a<indexed>(Mp)) {
	point_metric = clifford_unit(varidx(real_line, ex_to<idx>(Mp.op(1)).get_dim()), Mp);

@ If a [[lst]] is supplied we use as the signature of
metric, entries [[Mp]] as the diagonal elements of the matrix.
<<set point metric in figure>>=
	} else if (is_a<lst>(Mp)) {
		point_metric=clifford_unit(varidx(real_line, Mp.nops()), indexed(diag_matrix(ex_to<lst>(Mp)), sy_symm(),
																		 varidx(symbol("i"), Mp.nops()), varidx(symbol("j"), Mp.nops())));
	}

@ If [[Mp]] is a figure we effectively copy it.
<<figure class>>=
	else if (is_a<figure>(Mp)) {
		point_metric = ex_to<figure>(Mp).get_point_metric();
		cycle_metric = ex_to<figure>(Mp).get_cycle_metric();
		exhashmap<cycle_node> nnodes = ex_to<figure>(Mp).get_nodes();
		for (const auto& x: nnodes) {
			nodes[x.first]=x.second;
			<<identify infinity and real line>>
			}

@ We need to set [[real_line]] and [[infinity]] accordingly.
<<identify infinity and real line>>=
			if (x.second.get_generation() == REAL_LINE_GEN) {
				real_line = x.first;
				R_missing=false;
			}
			else if (x.second.get_generation() == INFINITY_GEN) {
				infinity = x.first;
				inf_missing=false;
			}

@ For an unknown type parameter we throw an exception.
<<figure class>>=
	} else
			throw(std::invalid_argument("figure::figure(const ex &, const ex &):"
										" the first parameter shall be a figure, a lst, "
										" a metric (can be either tensor, matrix,"
										" Clifford unit or indexed by two indices) "));
	<<set cycle metric in figure>>

@ If a metric is not supplied or is zero then we clone the point space
metric by the rule defined in
equation~\eqref{eq:int-heaviside-function}. The cycle metric is
indexed by the key of the zero-radius cycle at infinity. If the same
index as for the point metric is used, then we have an issue with
[[figure::read_archive()]]: for some mysterious reasons cycle metric
is always a copy of the point metric.
<<set cycle metric in figure>>=
	if (Mc.is_zero()) {
		ex D=get_dim();
		if (is_a<numeric>(D)) {
			lst l0;
			for(int i=0; i< ex_to<numeric>(D).to_int(); ++i)
				l0.append(-jump_fnct(-ex_to<clifford>(point_metric).get_metric(idx(i,D),idx(i,D))));
			cycle_metric = clifford_unit(varidx(infinity, D), indexed(diag_matrix(l0), sy_symm(),
																	   varidx(symbol("ic"), D), varidx(symbol("jc"), D)));

@ If dimensionality is not integer, then the point metric is copied.
<<set cycle metric in figure>>=
		} else
			cycle_metric = clifford_unit(varidx(infinity, D), indexed(point_metric.op(0), sy_symm(),
																	   varidx(symbol("ic"), D), varidx(symbol("jc"), D)));

@ If the metric is supplied, we repeat the same procedure to set-up
the metric of the cycle space as was done for point space.
<<set cycle metric in figure>>=
	} else if (is_a<clifford>(Mc)) {
		cycle_metric = clifford_unit(varidx(infinity,
											ex_to<idx>(ex_to<clifford>(Mc).get_metric().op(1)).get_dim()),
									 ex_to<clifford>(Mc).get_metric());
	} else if (is_a<matrix>(Mc)) {
		if (ex_to<matrix>(Mp).rows() != ex_to<matrix>(Mp).cols())
			throw(std::invalid_argument("figure::figure(const ex &, const ex &):"
										" only square matrices are admitted as cycle metric"));

		cycle_metric = clifford_unit(varidx(infinity, get_dim()), indexed(Mc, sy_symm(), varidx(symbol("ic"),
																								 get_dim()), varidx(symbol("jc"), get_dim())));

@ Other types of metric.
<<set cycle metric in figure>>=
	} else if (is_a<indexed>(Mc)) {
		cycle_metric = clifford_unit(varidx(infinity, ex_to<idx>(Mc.op(1)).get_dim()), Mc);
	} else if (is_a<lst>(Mc)) {
		cycle_metric=clifford_unit(varidx(infinity, Mc.nops()), indexed(diag_matrix(ex_to<lst>(Mc)), sy_symm(),
							varidx(symbol("ic"), Mc.nops()), varidx(symbol("jc"), Mc.nops())));
	}

@ The error message
<<figure class>>=
	else
		throw(std::invalid_argument("figure::figure(const ex &, const ex &):"
									" the second parameter"
									" shall be omitted, equal to zero "
									" or be a lst, a metric (can be either tensor, matrix,"
									" Clifford unit or indexed by two indices)"));

@ Finally we check that point and cycle metrics have the same dimensionality.
<<figure class>>=
	if (! (get_dim()-ex_to<idx>(cycle_metric.op(1)).get_dim()).is_zero())
		throw(std::invalid_argument("figure::figure(const ex &, const ex &):"
									"the point and cycle metrics shall have "
									"the same dimensions"));

@ We also check that [[point_metric]] and [[cycle_metric]] has the
same dimensionality.
<<figure class>>=
	<<check dimensionalities point and cycle metrics>>
	<<add symbols to match dimensionality>>

@
<<check dimensionalities point and cycle metrics>>=
	if (!(get_dim()-ex_to<varidx>(cycle_metric.op(1)).get_dim()).is_zero())
		throw(std::invalid_argument("Metrics for point and cycle spaces have"
									" different dimensionalities!"));

@ We produce enough symbols to match dimensionality.
<<add symbols to match dimensionality>>=
	int D;
	if (is_a<numeric>(get_dim())) {
		D=ex_to<numeric>(get_dim()).to_int();
		char name[6];
		for(int i=0; i<D; ++i) {
			sprintf(name, "l%d", i);
			l.append(realsymbol(name));
		}
	}

@ Finally, we set-up two elements which present at any figure: the
real line and infinity.
<<figure class>>=
	<<setup real line and infinity>>
}

@ Finally, we supply nodes for the real line and the cycle at infinity.
<<setup real line and infinity>>=
	if (inf_missing) {
		<<set the infinity>>
	}
	if (R_missing) {
		<<initialise the dimension and vector>>
		<<set the real line>>
	}

@
<<figure class>>=
figure::figure(const ex & Mp, const ex & Mc, const exhashmap<cycle_node> & N):
			  inherited(), k(realsymbol("k")), m(realsymbol("m")), l()
{
	infinity=symbol("infty","\\infty");
	real_line=symbol("R","\\mathbf{R}");
	bool inf_missing=true, R_missing=true;
	if (is_a<clifford>(Mp) && is_a<clifford>(Mc)) {
		point_metric = Mp;
		cycle_metric = Mc;
	} else
		throw(std::invalid_argument("figure::figure(const ex &, const ex &, exhashmap<cycle_node>):"
									" the point_metric and cycle_metric should be clifford_unit. "));

@ We coming nodes of cycle to the new figure.
<<figure class>>=
	for (const auto& x: N) {
		nodes[x.first]=x.second;
		<<identify infinity and real line>>
	}
	<<add symbols to match dimensionality>>
	<<setup real line and infinity>>
}

@ This constructor reads a figure from a file given by name.
<<figure class>>=
figure::figure(const char* file_name, string fig_name) : inherited(), k(realsymbol("k")), m(realsymbol("m")), l()
{
	infinity=symbol("infty","\\infty");
	real_line=symbol("R","\\mathbf{R}");
	<<add gar extension>>
	GiNaC::archive A;
	std::ifstream ifs(fn.c_str(),  std::ifstream::in);

	ifs >> A;
	*this=ex_to<figure>(A.unarchive_ex(lst{infinity, real_line}, fig_name));
	string operation_name="read";
	<<write raw archive printout>>
}

@ We use [[c++17]] features to process file names.
<<write raw archive printout>>=        
#if __cplusplus >= 201703L
	if (FIGURE_DEBUG) {
		std::filesystem::path file_path=std::filesystem::path(fn.c_str()),
			file_name=std::filesystem::path("raw-"+operation_name+"-");
		file_name+=file_path.filename();
		ofstream out1(file_path.replace_filename(file_name));
		A.printraw(out1);
		out1.close();
		out1.flush();
	}
#endif

@ \texttt{.gar} is the standard extension for \GiNaC\ archive files.
<<add gar extension>>=
	string fn=file_name;
	size_t found = fn.find(".gar");
	if (found == std::string::npos)
		fn=fn+".gar";

	if (FIGURE_DEBUG)
		cerr << "use filename: " << fn << endl;

@ This method saves the figure to a file, which can be read by the
above constructor.
<<figure class>>=
void figure::save(const char* file_name, const char * fig_name) const
{
	<<add gar extension>>
	GiNaC::archive A;
	A.archive_ex(*this, fig_name);
	ofstream out(fn.c_str());
	out << A;
	out.flush();
	out.close();
	string operation_name="save";
	<<write raw archive printout>>
}

@
\subsubsection{Addition of new cycles}
\label{sec:addition-new-cycles}

@ This method is merely a wrapper for the second form below.
<<figure class>>=
ex figure::add_point(const ex & x, string name, string TeXname)
{
	<<auto TeX name>>
	symbol key(name, TeXname_new);
	return add_point(x, key);
}
@ %def add_point

@ We start from check of parameters.
<<figure class>>=
ex figure::add_point(const ex & x, const ex & key)
{
	if (not (is_a<lst>(x) and (x.nops() == get_dim())))
		throw(std::invalid_argument("figure::add_point(const ex &, const ex &): "
									"coordinates of a point shall be a lst of the right lenght"));

	if (not is_a<symbol>(key))
		throw(std::invalid_argument("figure::add_point(const ex &, const ex &): the third"
									" argument need to be a point"));
<<adding point with its parents>>
@ %def add_point

@ This part of the code is shared with [[move_point()]]. We create two
ghost parents for a point, since the parameters of the cycle
representing depend from the metric, thus it shall not be hard-coded
into the node, see also Section~\ref{sec:figures-as-families}.
<<adding point with its parents>>=
	int dim=x.nops();
	lst l0, rels;
	rels.append(cycle_relation(key,cycle_orthogonal,false));
	rels.append(cycle_relation(infinity,cycle_different));

	for(int i=0; i < dim; ++i)
		l0.append(numeric(0));

	for(int i=0; i < dim; ++i) {
		l0[i]=numeric(1);
		char name[8];
		sprintf(name, "-(%d)", i);
		symbol mother(ex_to<symbol>(key).get_name()+name);
		nodes[mother]=cycle_node(cycle_data(numeric(0),indexed(matrix(1, dim, l0),
															   varidx(mother, get_dim())),numeric(2)*x.op(i)),
								 GHOST_GEN, lst{}, lst{key});
		l0[i]=numeric(0);
		rels.append(cycle_relation(mother,cycle_orthogonal));
	}

@ We add relations to parents which define this point. All relations
are given in [[cycle_metric]], only self-orthogonality is given in
terms of [[point_metric]]. This is done in sake of the parabolic point
space.
<<adding point with its parents>>=
	nodes[key]=cycle_node(cycle_data(), 0, rels);

@ Now, cycle date shall be generated.
<<figure class>>=
	if (! info(status_flags::expanded))
		nodes[key].set_cycles(ex_to<lst>(update_cycle_node(key)));
	if (FIGURE_DEBUG)
		cerr << "Add the point: " << x << " as the cycle: " << nodes[key] << endl;
	return key;
}

@ Add a cycle at zero level with a prescribed data.
<<figure class>>=
ex figure::add_cycle(const ex & C, const ex & key)
{
	ex lC=ex_to<cycle>(C).get_l();
	if (is_a<indexed>(lC))
		nodes[key]=cycle_node(C.subs(lC.op(1)==key));
	else
		nodes[key]=cycle_node(C);
	if (FIGURE_DEBUG)
		cerr << "Add the cycle: " << nodes[key] << endl;
	return key;
}
@ %def add_cycle

@ Add a cycle at zero level with a prescribed data.
<<figure class>>=
ex figure::add_cycle(const ex & C, string name, string TeXname)
{
	<<auto TeX name>>
	symbol key(name, TeXname_new);
	return add_cycle(C, key);
 }

@
<<figure class>>=
void figure::set_cycle(const ex & key, const ex & C)
{
    if (nodes.find(key) == nodes.end())
        throw(std::invalid_argument("figure::set_cycle(): there is no node wi\
th the key given"));

    if (nodes[key].get_parents().nops() > 0)
        throw(std::invalid_argument("figure::set_cycle(): cannot modify data \
of a cycle with parents"));

    nodes[key].set_cycles(C);

    if (FIGURE_DEBUG)
        cerr << "Replace the cycle: " << nodes[key] << endl;
}
@ %def set_cycle

@
<<figure class>>=
void figure::move_cycle(const ex & key, const ex & C)
{
	if (nodes.find(key) == nodes.end())
		throw(std::invalid_argument("figure::set_cycle(): there is no node with the key given"));

	if (nodes[key].get_generation() != 0)
		throw(std::invalid_argument("figure::set_cycle(): cannot modify data of a cycle in"
									" non-zero generation"));
@ %def move_cycle

@ If we have at zero generation with parents, then they are ghost
parents of the point, so shall be deleted. We cannot do this by
[[remove_cycle_node]] since we do not want to remove all its grand childrens.
<<figure class>>=
	if (nodes[key].get_parents().nops() > 0) {
		lst par=nodes[key].get_parent_keys();
		for(const auto& it : par)
			if (nodes[it].get_generation() == GHOST_GEN)
				nodes.erase(it);
			else
				nodes[it].remove_child(key);
	}
	nodes[key].parents=lst{};

@ Now, the cycle may be set.
<<figure class>>=
	nodes[key].set_cycles(C);
	update_node_lst(nodes[key].get_children());

	if (FIGURE_DEBUG)
		cerr << "Replace the cycle: " << nodes[key] << endl;
}

@ A cycle can be added by a single  [[cycle_relation]] or a [[lst]] of
[[cycle_relation]], but this is just a wrapper for a more general case
below.
<<figure class>>=
ex figure::add_cycle_rel(const ex & rel, const ex & key) {
	if (is_a<cycle_relation>(rel))
		return add_cycle_rel(lst{rel}, key);
	else
		throw(std::invalid_argument("figure::add_cycle_rel: a cycle shall be added "
									"by a single expression, which is a cycle_relation"));
}
@ %def add_cycle_rel

@ And now we add a cycle defined the list of relations. The generation
of the new cycle is calculated by the rules described in
Sec.~\ref{sec:figures-as-families}.
<<figure class>>=
ex figure::add_cycle_rel(const lst & rel, const ex & key)
{
	lst cond;
	int gen=0;

	for(const auto& it : rel) {
		if (ex_to<cycle_relation>(it).get_parkey() != key)
			gen=max(gen, nodes[ex_to<cycle_relation>(it).get_parkey()].get_generation());
		nodes[ex_to<cycle_relation>(it).get_parkey()].add_child(key);
	}

	nodes[key]=cycle_node(cycle_data(),gen+1,rel);

@
<<figure class>>=
	if (! info(status_flags::expanded))
		nodes[key].set_cycles(ex_to<lst>(update_cycle_node(key)));

	if (FIGURE_DEBUG)
		cerr << "Add the cycle: " << nodes[key] << endl;

	return key;
}

@ This version automatically supply \TeX\ label like \(c_{23}\) to
symbols with names [[c23]].
<<figure class>>=
ex figure::add_cycle_rel(const lst & rel, string name, string TeXname)
{
	<<auto TeX name>>
	return add_cycle_rel(rel, symbol(name, TeXname_new));
}

@ A similar method to add a cycle by a single relation.
<<figure class>>=
ex figure::add_cycle_rel(const ex & rel, string name, string TeXname)
{
	if (is_a<cycle_relation>(rel)) {
		<<auto TeX name>>
		return add_cycle_rel(lst{rel}, symbol(name, TeXname_new));
	} else
		throw(std::invalid_argument("figure::add_cycle_rel: a cycle shall be added "
									"by a single expression, which is a cycle_relation"));
}

@ This method adds a [[subfigure ]] as a single node. The generation
of the new node is again calculated by the rules described in
Sec.~\ref{sec:figures-as-families}.
<<figure class>>=
ex figure::add_subfigure(const ex & F, const lst & L, const ex & key)
{
	GINAC_ASSERT(is_a<figure>(F));
	int gen=0;

	for(const auto& it : L) {
		if (! it.is_equal(key))
			gen=max(gen, nodes[it].get_generation());
		nodes[it].add_child(key);
	}
	nodes[key]=cycle_node(cycle_data(),gen+1,lst{subfigure(F,L)});
	if (! info(status_flags::expanded))
		nodes[key].set_cycles(ex_to<lst>(update_cycle_node(key)));

	return key;
}
@ %def add_subfigure

@ This is again a wrapper for the previous method with the newly
defined symbol.
<<figure class>>=
ex figure::add_subfigure(const ex & F, const lst & l, string name, string TeXname)
{
	<<auto TeX name>>
		return add_subfigure(F, l, symbol(name, TeXname_new));
}

@
<<auto TeX name>>=
	string TeXname_new;
	std::regex e ("([[:alpha:]]+)([[:digit:]]+)");
	std::regex e1 ("([[:alnum:]]+)_([[:alnum:]]+)");
	if (TeXname == "") {
		if (std::regex_match(name, e))
			TeXname_new=std::regex_replace (name,e,"$1_{$2}");
		else if (std::regex_match(name, e1))
			TeXname_new=std::regex_replace (name,e1,"$1_{$2}");
	} else
		TeXname_new=TeXname;

@
\subsubsection{Moving and removing cycles}
\label{sec:moving-remov-cycl}

@ The method to change a zero-generation cycle to a point with given coordinates.
<<figure class>>=
void figure::move_point(const ex & key, const ex & x)
{
	if (not (is_a<lst>(x) and (x.nops() == get_dim())))
		throw(std::invalid_argument("figure::move_point(const ex &, const ex &): "
									"coordinates of a point shall be a lst of the right lenght"));

	if (nodes.find(key) == nodes.end())
		throw(std::invalid_argument("figure::move_point(): there is no node with the key given"));

	if (nodes[key].get_generation() != 0)
		throw(std::invalid_argument("figure::move_point(): cannot modify data of a cycle in"
									" non-zero generation"));

	if (FIGURE_DEBUG)
		cerr << "A cycle is moved : " << nodes[key] << endl;
@ %def move_point

@ If number of parents was ``dimension plus 2'', so it was a proper point, we simply need to
replace the ghost parents.
<<figure class>>=
	lst par=nodes[key].get_parent_keys();
	unsigned int dim=x.nops();
	lst l0;
	for(unsigned int i=0; i<dim; ++i)
		l0.append(numeric(0));

@ We scan the name of parents to get number of components and
substitute their new values.
<<figure class>>=
	char label[40];
	sprintf(label, "%s-(%%d)",ex_to<symbol>(key).get_name().c_str());
	if (par.nops() == dim+2 ) {
		for(const auto& it : par) {
			unsigned int i=dim;
			int res=sscanf(ex_to<symbol>(it).get_name().c_str(), label, &i);
			if (res>0 and i<dim) {
				l0[i]=numeric(1);
				nodes[it].set_cycles(cycle_data(numeric(0),indexed(matrix(1, dim, l0),
																	varidx(it, dim)), numeric(2)*x.op(i)));
				l0[i]=numeric(0);
			}
		}

@ If the number of parents is zero, so it was a pre-defined cycle and
we need to create ghost parents for it.
<<figure class>>=
	} else if  (par.nops() == 0) {
		lst chil=nodes[key].get_children();
		<<adding point with its parents>>
		nodes[key].children=chil;
	} else
		throw(std::invalid_argument("figure::move_point(): strange number (neither 0 nor dim+2) of "
									"parents, which zero-generation node shall have!"));

	if (info(status_flags::expanded))
		return;

	nodes[key].set_cycles(ex_to<lst>(update_cycle_node(key)));
	update_node_lst(nodes[key].get_children());

@ Then, to update all its children and grandchildren in all generations
excluding this node itself.
<<figure class>>=
	 update_node_lst(nodes[key].get_children());
	 if (FIGURE_DEBUG)
		cerr << "Moved to: " << x << endl;
}

@ Afterwards, to remove all children (includes grand children, grand grand
children\ldots) of the [[cycle_node]].
<<figure class>>=
void figure::remove_cycle_node(const ex & key)
{
	lst  branches=nodes[key].get_children();
	for (const auto& it : branches)
		remove_cycle_node(it);
@ %def remove_cycle_node

@ Furthermore, to remove the [[cycle_node]] c from all its parents children lists.
<<figure class>>=
	lst  par = nodes[key].get_parent_keys();
	for (const auto& it : par) {

@ Parents of a point at gen-0 can be simply deleted as no other cycle
need them and they are not of interest. For other parents we modify
their [[cildren]] list.
<<figure class>>=
		if (nodes[it].get_generation() == GHOST_GEN)
			nodes.erase(it);
		else
			nodes[it].remove_child(key);
	}

@ Finally, remove the [[cycle_node]] from the figure.
<<figure class>>=
	nodes.erase(key);
	if (FIGURE_DEBUG)
		cerr << "The cycle is removed: " << key << endl ;
}

@
\subsubsection{Evaluattion of cycles and figure updates}
\label{sec:eval-cycl-from}

@ This procedure can solve a system of linear conditions or a system
with one quadratic equation. It was already observed
in~\citelist{\cite{FillmoreSpringer00a} \cite{Kisil12a}*{\S~5.5}}, see
Sec.~\ref{sec:conn-quadr-cycl}, that \(n\) tangency-type conditions
(each of them is quadratic) can be reduced to the single quadratic
condition \(\scalar{\cycle{}{}}{\cycle{}{}}=1\) and \(n\) linear
conditions like \(\scalar{\cycle{}{}}{\cycle{i}{}}=\lambda_i\).
<<figure class>>=
ex figure::evaluate_cycle(const ex & symbolic, const lst & cond) const
{
	//cerr << boolalpha << "symbolic: "; symbolic.dbgprint();
	//cerr << "condit: "; cond.dbgprint();
	bool first_solution=true, // whetehr the first solution is suitable
		second_solution=false, // whetehr the second solution is suitable
		is_homogeneous=true; // indicates whether all conditions are linear
@ %def evaluate_cycle

@ This method can be applied to cycles with numerical dimensions.
<<figure class>>=
	int D;
	if (is_a<numeric>(get_dim()))
		D=ex_to<numeric>(get_dim()).to_int();
	else
		throw logic_error("Could not resolve cycle relations if dimensionality is not numeric!");

@ Create the list of used symbols. The code is stolen from  \texttt{cycle.nw}
<<figure class>>=
	lst symbols, lin_cond, nonlin_cond;
	if (is_a<symbol>(ex_to<cycle_data>(symbolic).get_m()))
		symbols.append(ex_to<cycle_data>(symbolic).get_m());
	for (int i = 0; i < D; i++)
		if (is_a<symbol>(ex_to<cycle_data>(symbolic).get_l(i)))
			symbols.append(ex_to<cycle_data>(symbolic).get_l(i));
	if (is_a<symbol>(ex_to<cycle_data>(symbolic).get_k()))
		symbols.append(ex_to<cycle_data>(symbolic).get_k());

@ If no symbols are found we assume that the cycle is uniquely defined
<<figure class>>=
	if (symbols.nops() == 0)
		throw(std::invalid_argument("figure::evaluate_cycle(): could not construct the default list of "
								 "parameters"));
	//cerr << "symbols: "; symbols.dbgprint();

@ Build matrix representation from equation system. The code is stolen
from  \texttt{ginac/inifcns.cpp}.
<<figure class>>=
	lst rhs;
	for (size_t r=0; r<cond.nops(); r++) {
		lst sys;
		ex eq = (cond.op(r).op(0)-cond.op(r).op(1)).expand(); // lhs-rhs==0
		if (float_evaluation)
			eq=eq.evalf();
		//cerr << "eq: "; eq.dbgprint();
		ex linpart = eq;
		for (size_t c=0; c<symbols.nops(); c++) {
			const ex co = eq.coeff(ex_to<symbol>(symbols.op(c)),1);
			linpart -= co*symbols.op(c);
			sys.append(co);
		}
		linpart = linpart.expand();
		//cerr << "sys: "; sys.dbgprint();
		//cerr << "linpart: "; linpart.dbgprint();

@ test if system is linear and fill vars matrix
<<figure class>>=
		bool is_linear=true;
		for (size_t i=0; i<symbols.nops(); i++)
			if (sys.has(symbols.op(i)) || linpart.has(symbols.op(i)))
				is_linear = false;
		//cerr << "this equation linear? " << is_linear << endl;

@ To avoid an expensive expansion we use the previous calculations to
re-build the equation.
<<figure class>>=
		if (is_linear) {
			lin_cond.append(sys);
			rhs.append(linpart);
			is_homogeneous &= linpart.normal().is_zero();
		} else
			nonlin_cond.append(cond.op(r));
	}
	//cerr << "lin_cond: "; lin_cond.dbgprint();
	//cerr << "nonlin_cond: "; nonlin_cond.dbgprint();


@ Solving the linear part, the code is again stolen from  \texttt{ginac/inifcns.cpp}
<<figure class>>=
	lst subs_lst1, // The main list of substitutions of found solutions
		subs_lst2, // The second solution lists for quadratic equations
		free_vars; // List of free variables being parameters of the solution
 	if (lin_cond.nops()>0) {
		matrix solution;
		try {
			solution=ex_to<matrix>(lst_to_matrix(lin_cond)).solve(matrix(symbols.nops(),1,symbols),
																  matrix(rhs.nops(),1,rhs));

@ If the system is incompatible no cycle data is returned (probably
singular matrix or otherwise overdetermined system, it is consistent to return an empty list)
<<figure class>>=
        } catch (const std::runtime_error & e) {
			return lst{};
        }
        GINAC_ASSERT(solution.cols()==1);
        GINAC_ASSERT(solution.rows()==symbols.nops());

@ Now we sort out the result: free variables will be used for
non-linear equation, resolved variables---for substitution.
<<figure class>>=
        for (size_t i=0; i<symbols.nops(); i++)
			if (symbols.op(i)==solution(i,0))
				free_vars.append(symbols.op(i));
			else
				subs_lst1.append(symbols.op(i)==solution(i,0));
	}
	//cerr << "Lin system is homogeneous: " << is_homogeneous << endl;

@ It is easy to solve a linear system, thus we immediate substitute
the result.
<<figure class>>=
	cycle_data C_new, C1_new;
	if (nonlin_cond.nops() == 0) {
		C_new = ex_to<cycle_data>(symbolic.subs(subs_lst1)).normalize();
		//cerr << "C_new: "; C_new.dbgprint();

@ We check that the solution is not identical zero, which may happen
for homogeneous conditions, for example. For this we
prepare the respective norm of the cycle.
<<figure class>>=
	ex norm=pow(ex_to<cycle_data>(symbolic).get_k(),2)+pow(ex_to<cycle_data>(symbolic).get_m(),2);
	for (int i = 0; i < D; i++)
		norm+=pow(ex_to<cycle_data>(symbolic).get_l(i),2);
	first_solution &= ! is_less_than_epsilon(norm.subs(subs_lst1,
													   subs_options::algebraic | subs_options::no_pattern));

@ If some non-linear equations present and there are free variables,
we sort out free and non-free variables.
<<figure class>>=
	} else if (free_vars.nops() > 0) {
		lst nonlin_cond_new;
		//cerr << "free_vars: "; free_vars.dbgprint();
		//cerr << "subs_lst1: "; subs_lst1.dbgprint();

@ Only one non-linear (quadratic) equation can be treated by this method, so we
pick up the first from the list (hopefully other will be satisfied afterwards).
<<figure class>>=
		ex quadratic_eq=nonlin_cond.op(0).subs(subs_lst1, subs_options::algebraic
											   | subs_options::no_pattern);
		ex quadratic=(quadratic_eq.op(0)-quadratic_eq.op(1)).expand().normal()
			.subs(evaluation_assist,subs_options::algebraic).normal();
		if (float_evaluation)
			quadratic=quadratic.evalf();
		//cerr << "quadratic: "; quadratic.dbgprint();

@ We reduce the list of free variables to only present in the quadratic.
<<figure class>>=
		lst quadratic_list;
		for (size_t i=0; i < free_vars.nops(); ++i)
			if (quadratic.has(free_vars.op(i)))
				quadratic_list.append(free_vars.op(i));
		free_vars=ex_to<lst>(quadratic_list);
		//cerr << "free_vars which are present: "; free_vars.dbgprint();

@ We check homogeneity of the quadratic equation.
<<figure class>>=
		if (is_homogeneous) {
			ex Q=quadratic;
			for (size_t i=1; i < free_vars.nops(); ++i)
				Q=Q.subs(free_vars.op(i)==free_vars.op(0));
			is_homogeneous &= (Q.degree(free_vars.op(0))==Q.ldegree(free_vars.op(0)));
		}
		//cerr << "Quadratic part is homogeneous: " << is_homogeneous << endl;

@ The equation may be linear for a particular free variable, we will
search if it is.
<<figure class>>=
		bool is_quadratic=true;
		exmap flat_var_em, var1_em, var2_em;
		ex flat_var, var1, var2;

@ We now search if for some free variable the equation is linear
<<figure class>>=
		size_t i=0;
		for (; i < free_vars.nops(); ++i) {
			//cerr << "degree: " << quadratic.degree(free_vars.op(i)) << endl;
			if (quadratic.degree(free_vars.op(i)) < 2) {
				is_quadratic=false;
				//cerr << "Equation is linear in "; free_vars.op(i).dbgprint();
				break;
			}
		}

@ If all equations are quadratic in any variable, we use homogenuity
to reduce the last free variable.
<<figure class>>=
		if (is_quadratic) {
			if (is_homogeneous && free_vars.nops() > 1) {
				exmap erase_var;
				erase_var.insert(std::make_pair(free_vars.op(free_vars.nops()-1), numeric(1)));
				subs_lst1=ex_to<lst>(subs_lst1.subs(erase_var,
													subs_options::algebraic | subs_options::no_pattern));
				subs_lst1.append(free_vars.op(free_vars.nops()-1) == numeric(1));
				quadratic=quadratic.subs(free_vars.op(free_vars.nops()-1) == numeric(1));
				free_vars.remove_last();
				//cerr << "Quadratic reduced by homogenuity: "; quadratic.dbgprint();
			}

@ and then proceed with solving of quadratic equation for each free
variable attempting to find root-free presentation.
<<figure class>>=
			ex A, B, C, D, sqrtD;
			for(i=0; i < free_vars.nops(); ++i) {
				A=quadratic.coeff(free_vars.op(i),2).normal();
				//cerr << "A: "; A.dbgprint();
				B=quadratic.coeff(free_vars.op(i),1);
				C=quadratic.coeff(free_vars.op(i),0);
				D=(pow(B,2)-numeric(4)*A*C).normal();
				sqrtD=sqrt(D);
				//cerr << "D: "; D.dbgprint();

@ For the condition of real coefficients, we are checking whether
another free variable survived in the discriminant of the quadratic equation.\\
TODO: this process need to be recursive for all free variables, not
just for one as it is now.
<<figure class>>=
				if (//need_reals &&
					free_vars.nops()>1) {
					int another=0;
					if (i==0)
						another=1;

@ If another free variable, denoted \(x\) here, presents in the
discriminant \(D=A_1 x^2+B_1 x+C_1\), we try some hyperbolic or
trigonometric substitutions.
<<figure class>>=
					if (not is_less_than_epsilon(D) && D.has(free_vars.op(another))) {
						ex A1=D.coeff(free_vars.op(another),2)
						.subs(evaluation_assist,subs_options::algebraic).normal(),
						B1=D.coeff(free_vars.op(another),1)
						.subs(evaluation_assist,subs_options::algebraic).normal(),
						C1=D.coeff(free_vars.op(another),0)
						.subs(evaluation_assist,subs_options::algebraic).normal(),
						D1=(pow(B1,2)-4*A1*C1).normal();
						//cerr << "Atempt to resolve square root for A1=" << A1;
						//cerr << ", B1=" << B1 << ", C1=" << C1 << ", D1=" << D1 << endl;

@ If the expression is linear, we make a substitution \(D=B_1
x+C_1=y^2\), thus \(x=(y^2-C_1)/B_1\).
<<figure class>>=
						if (is_less_than_epsilon(A1) && not is_less_than_epsilon(B1)) {
							ex y=realsymbol(),
							x=(pow(y,2)-C1)/B1;
							sqrtD=y;
							flat_var_em.insert(std::make_pair(free_vars.op(another), x));
							flat_var=(free_vars.op(another)==x);

@ If \(A_1\) is positive, then the substitution depends on sign of the
second discriminant \(D_1=B_1^2-4A_1C_1\)
<<figure class>>=
						} else if (A1.evalf().info(info_flags::positive)) {

@ Depending on the sign of \(D_1\) and thus \(C_1-B_1^2/(4A_1)\) we are using either
hyperbolic sine or cosine.
<<figure class>>=
							if (D1.info(info_flags::negative)) {
								ex y=realsymbol(),
								x=(sinh(y)*sqrt(-D1)-B1)/2/A1;
								sqrtD=sqrt(C1-pow(B1,2)/4/A1)*cosh(y);
								flat_var_em.insert(std::make_pair(free_vars.op(another), x));
								flat_var=(free_vars.op(another)==x);
							} else if (D1.info(info_flags::positive)) {
								ex y=realsymbol(),
								x=(cosh(y)*sqrt(D1)-B1)/2/A1;
								sqrtD=sqrt(pow(B1,2)/4/A1-C1)*sinh(y);
								flat_var_em.insert(std::make_pair(free_vars.op(another), x));
								flat_var=(free_vars.op(another)==x);
							}

@ If \(A_1\) is negative and \(C_1-B_1^2/(4A_1)>0\) we use the
trigonometric substitution \((2A_1 x+B_1)/\sqrt{4A_1C_1-B_1^2}=\cos y\).
<<figure class>>=
						} else if (A1.evalf().info(info_flags::negative)) {
							if (D1.info(info_flags::negative)) {
								ex y=realsymbol(),
								x=(sin(y)*sqrt(-D1)-B1)/2/A1;
								sqrtD=sqrt(-C1+pow(B1,2)/4/A1)*cos(y);
								flat_var_em.insert(std::make_pair(free_vars.op(another), x));
								flat_var=(free_vars.op(another)==x);

@ If both are negative, we explicitly take out the imaginary part and
use the above hyperbolic substitution with \(\sinh\).
<<figure class>>=
							} else if (D1.info(info_flags::positive)) {
								ex y=realsymbol(),
								x=(sinh(y)*I*sqrt(D1)-B1)/2/A1;
								sqrtD=I*sqrt(C1-pow(B1,2)/4/A1)*cosh(y);
								flat_var_em.insert(std::make_pair(free_vars.op(another), x));
								flat_var=(free_vars.op(another)==x);
							}
						}

@ If a substitution was found we are staying with this solution.
<<figure class>>=
					//cerr << "real_only sqrt(D): "; sqrtD.dbgprint();
					if (not (sqrtD-sqrt(D)).is_zero())
						break;
				}
			}
		}

@ Put index back to the range if needed.
<<figure class>>=
		if (i == free_vars.nops())
			--i;

@ Small perturbations of the zero determinant can create the unwanted
imaginary entries, thus we treat  it as exactly zero. Also negligibly
small [[A]] corresponds to an effectively linear equation.
<<figure class>>=
			if (is_less_than_epsilon(D) || ((! is_less_than_epsilon(B)) && is_less_than_epsilon(A/B))) {
				if (is_less_than_epsilon(D)) {
					//cerr << "zero determinant" << endl;
					var1=(-B/numeric(2)/A).subs(flat_var_em,subs_options::algebraic
												| subs_options::no_pattern).normal();
				} else {
					//cerr << "almost linear equation" << endl;
					var1=(-C/B).subs(flat_var_em,subs_options::algebraic
									 | subs_options::no_pattern).normal();
				}
				var1_em.insert(std::make_pair(free_vars.op(i), var1));
				subs_lst1=ex_to<lst>(subs_lst1
									 .subs(var1_em,subs_options::algebraic | subs_options::no_pattern));
				subs_lst1=ex_to<lst>(subs_lst1.append(free_vars.op(i) == var1)
									 .subs(flat_var_em,subs_options::algebraic | subs_options::no_pattern));
				if (flat_var.nops()>0)
					subs_lst1.append(flat_var);
				//cerr << "subs_lst1a: "; subs_lst1.dbgprint();

@  For a non-zero discriminant we generate two solutions of the
quadratic equation.
<<figure class>>=
			} else {
				second_solution=true;
				subs_lst2=subs_lst1;
				var1=((-B+sqrtD)/numeric(2)/A).subs(flat_var_em,subs_options::algebraic
													| subs_options::no_pattern).normal();
				var1_em.insert(std::make_pair(free_vars.op(i), var1));
				var2=((-B-sqrtD)/numeric(2)/A).subs(flat_var_em,subs_options::algebraic
													| subs_options::no_pattern).normal();
				var2_em.insert(std::make_pair(free_vars.op(i), var2));
				subs_lst1=ex_to<lst>(subs_lst1
									 .subs(var1_em,subs_options::algebraic | subs_options::no_pattern));
				subs_lst1=ex_to<lst>(subs_lst1.append(free_vars.op(i) == var1)
									 .subs(flat_var_em,subs_options::algebraic | subs_options::no_pattern));

@ Then we modify the second substitution list accordingly.
<<figure class>>=
				subs_lst2=ex_to<lst>(subs_lst2
									 .subs(var2_em,subs_options::algebraic | subs_options::no_pattern));
				subs_lst2=ex_to<lst>(subs_lst2.append(free_vars.op(i) == var2)
									 .subs(flat_var_em,subs_options::algebraic | subs_options::no_pattern));

@ We need to add the values of [[flat_var]] which were assigned the
numeric value.
<<figure class>>=
				if (flat_var.nops()>0) {
					subs_lst1.append(flat_var);
					subs_lst2.append(flat_var);
				}
				//cerr << "subs_lst1b: "; subs_lst1.dbgprint();
				//cerr << "subs_lst2b: "; subs_lst2.dbgprint();
			}
			// end of the quadratic case

@ The non-linear equation is not quadratic in some variable,
e.g. is  \(mk+1=0\) then we are solving it as linear.
<<figure class>>=
		} else {
			//cerr << "The equation is not quadratic in a single variable"<<endl;
			//cerr << "free_vars: "; free_vars.dbgprint();
			var1=-(quadratic.coeff(free_vars.op(i),0)/quadratic.coeff(free_vars.op(i),1)).normal();
			var1_em.insert(std::make_pair(free_vars.op(i), var1));
			subs_lst1=ex_to<lst>(subs_lst1
								 .subs(var1_em,subs_options::algebraic | subs_options::no_pattern));
			subs_lst1.append(free_vars.op(i) == var1);
			//cerr << "non-quadratic subs_lst1: "; subs_lst1.dbgprint();
		}

@ Now we check that other non-linear conditions are satisfied by the
found solutions.
<<figure class>>=
			lst::const_iterator it1= nonlin_cond.begin();
			++it1;
			//cerr << "Subs list: "; subs_lst1.dbgprint();
			lst subs_f1=ex_to<lst>(subs_lst1.evalf()), subs_f2;
			//cerr << "Subs list float: "; subs_f1.dbgprint();
			if(second_solution)
				subs_f2=ex_to<lst>(subs_lst2.evalf());

@ Since CAS is not as perfect as one may wish, we checked obtained
solutions in two ways: through float approximations and exact
calculations. If either works then the solution is accepted.
<<figure class>>=
			for (; it1 != nonlin_cond.end(); ++it1) {
				first_solution &= (is_less_than_epsilon((it1->op(0)-it1->op(1)).subs(subs_f1,
																		   subs_options::algebraic | subs_options::no_pattern))
						 || ((it1->op(0)-it1->op(1)).subs(subs_lst1,
														  subs_options::algebraic | subs_options::no_pattern)).normal().is_zero());

@ The same check for the second solution.
<<figure class>>=
				if(second_solution)
					second_solution &= (is_less_than_epsilon((it1->op(0)-it1->op(1)).subs(subs_f2,
																			   subs_options::algebraic | subs_options::no_pattern))
							 || ((it1->op(0)-it1->op(1)).subs(subs_lst2,
															  subs_options::algebraic | subs_options::no_pattern)).normal().is_zero());
			}

@ If a solution is good, then we use it to generate the respective cycle.
<<figure class>>=
			if (first_solution)
				C_new=symbolic.subs(subs_lst1, subs_options::algebraic
													| subs_options::no_pattern);

			//cerr << "C_new: "; C_new.dbgprint();
			if (second_solution)
				C1_new=symbolic.subs(subs_lst2, subs_options::algebraic
													 | subs_options::no_pattern);
			//cerr << "C1_new: "; C1_new.dbgprint();
		}

@ We check if any symbols survived after calculations\ldots
<<figure class>>=
	lst repl;
	if (ex_to<cycle_data>(C_new).has(ex_to<cycle_data>(symbolic).get_k()))
		repl.append(ex_to<cycle_data>(symbolic).get_k()==realsymbol());
	if (ex_to<cycle_data>(C_new).has(ex_to<cycle_data>(symbolic).get_m()))
		repl.append(ex_to<cycle_data>(symbolic).get_m()==realsymbol());
	if (ex_to<cycle_data>(C_new).has(ex_to<cycle_data>(symbolic).get_l().op(0).op(0)))
		repl.append(ex_to<cycle_data>(symbolic).get_l().op(0).op(0)==realsymbol());
	if (ex_to<cycle_data>(C_new).has(ex_to<cycle_data>(symbolic).get_l().op(0).op(1)))
		repl.append(ex_to<cycle_data>(symbolic).get_l().op(0).op(1)==realsymbol());

@ \ldots and if they are, then we replace them for new one
<<figure class>>=
	if (repl.nops()>0) {
		if (first_solution)
			C_new=C_new.subs(repl);
		if (second_solution)
			C1_new=C1_new.subs(repl);
	}

	//cerr << endl;

@ Finally, every constructed cycle is added to the result.
<<figure class>>=
	lst res;
	if (first_solution)
		res.append(float_evaluation?C_new.num_normalize().evalf():C_new.num_normalize());
	if (second_solution)
		res.append(float_evaluation?C1_new.num_normalize().evalf():C1_new.num_normalize());

	return res;
}

@ This method runs recursively because we do not know in advance the
number of conditions glued by and/or. Also, some relations
(e.g. [[moebius_trans]] or [[subfigure]]) directly define the cycles,
and for others we need to solve some equations.
<<figure class>>=
ex figure::update_cycle_node(const ex & key, const lst & eq_cond, const lst & neq_cond, lst res, size_t level)
{
	//cerr << endl << "level: " << level << "; cycle: "; nodes[key].dbgprint();
	if (level == 0) {// set the iniail symbolic cycle for calculations
		<<update node zero level>>
	}
@ %def update_cycle_node

@ If we get here, then some equations need to be solved. We advance
through the parents list to match the [[level]].
<<figure class>>=
	lst par = nodes[key].get_parents();
	lst::const_iterator it = par.begin();
	std::advance(it,level);

	lst new_cond=ex_to<lst>(ex_to<cycle_relation>(*it).rel_to_parent(nodes[key].get_cycles_data().op(0),
																	 point_metric, cycle_metric, nodes));

@ We need to go through the cycle at least once at every [[level]] and
separate equations, which are used to calculate solutions, from
inequalities, which will be only checked on the obtained solution.
<<figure class>>=
	for (const auto& it1 : new_cond) {
		lst store_cond=neq_cond;
		lst use_cond=eq_cond;
		lst step_cond=ex_to<lst>(it1);

@ Iteration over the list of conditions
<<figure class>>=
		for (const auto& it2 : step_cond)
			if ((is_a<relational>(it2) && ex_to<relational>(it2).info(info_flags::relation_equal)))
				use_cond.append(it2);	// append the equation
			else if (is_a<cycle>(it2)) { // append a solution
				cycle Cnew=ex_to<cycle>(it2);
				res.append(cycle_data(Cnew.get_k(), Cnew.get_l().subs(Cnew.get_l().op(1)==key),
									  Cnew.get_m()));
			} else
				store_cond.append(*it); // store the pointer to parents producing inequality
		//cerr << "use_cond: "; use_cond.dbgprint();
		//cerr << "store_cond: "; store_cond.dbgprint();

@ When all conditions are unwrapped and there are equations to solve,
we call a solver. Solutions from [[res]] are copied there as well,
then [[res]] is cleared.
<<figure class>>=
		if(level == par.nops()-1) { //if the last one in the parents list
			lst cnew;
			if (use_cond.nops()>0)
				cnew=ex_to<lst>(evaluate_cycle(nodes[key].get_cycle_data(0), use_cond));
			for (const auto& sol : res)
				cnew.append(sol);
			res=lst{};

@ Now we check which of the obtained solutions satisfy to the
restrictions in [[store_cond]]
<<figure class>>=
			//cerr<< "Store cond: "; store_cond.dbgprint();
			//cerr<< "Use cond: "; use_cond.dbgprint();
			for (const auto& inew: cnew) {
				bool to_add=true;
				for (const auto& icon: store_cond) {
					lst suits=ex_to<lst>(ex_to<cycle_relation>(icon).rel_to_parent(inew,
																				   point_metric, cycle_metric, nodes));
					//cerr<< "Suit: "; suits.dbgprint();
					for (const auto& is : suits)
						for (const auto& ic : is) {

@ Two possibilities to check: either a [[false]] relational or a number
close to zero.
<<figure class>>=
							if  (is_a<relational>(ic)) {
								if (!(bool)ex_to<relational>(ic))
									to_add=false;
							} else if (is_less_than_epsilon(ic))
								to_add=false;
						}
					if (! to_add)
						break;
				}
				if (to_add)
					res.append(inew);
			}
		//cerr<< "Result: "; res.dbgprint();
		} else
			res=ex_to<lst>(update_cycle_node(key, use_cond, store_cond, res, level+1));
	}
	if (level ==0)
		return unique_cycle(res);
	else
		return res;
}

@ If the cycle is defined by by a [[subfigure]] all calculations are done
within it.
<<update node zero level>>=
	if ( nodes[key].get_parents().nops() == 1 && is_a<subfigure>(nodes[key].get_parents().op(0))) {
		figure F=ex_to<figure>(ex_to<basic>(ex_to<subfigure>(nodes[key].get_parents().op(0)).get_subf())
							   .clearflag(status_flags::expanded));
		F=float_evaluation? F.set_float_eval(): F.set_exact_eval();

@ We replace parameters of the [[subfigure]] by current parents and
evaluate the result.
<<update node zero level>>=
		lst parkeys=ex_to<lst>(ex_to<subfigure>(nodes[key].get_parents().op(0)).get_parlist());
		unsigned int var=0;
		char name[12];
		for (const auto& it : parkeys) {
			sprintf(name, "variable%03d", var);
			F.set_cycle(F.get_cycle_key(name), nodes[it].get_cycles_data());
			++var;
		}
		F.set_metric(point_metric,cycle_metric); // this calls automatic figure re-calculation
		return F.get_cycles(F.get_cycle_key("result"));

@ For a list of relations we simply set up a symbolic cycle and
proceed with calculations in recursion.
<<update node zero level>>=
	} else
		nodes[key].set_cycles(cycle_data(k, indexed(matrix(1, ex_to<numeric>(get_dim()).to_int(), l), varidx(key, ex_to<numeric>(get_dim()).to_int())), m, false));


@ The figure is updated.
<<figure class>>=
figure figure::update_cycles()
{
	if (info(status_flags::expanded))
		return *this;
	lst all_child;
	for (auto& x: nodes)
		if (ex_to<cycle_node>(x.second).get_generation() == 0) {
			if (ex_to<cycle_node>(x.second).get_parents().nops() > 0)
				nodes[x.first].set_cycles(ex_to<lst>(update_cycle_node(x.first)));
@ %def update_cycles

@ We collect all children of the zero-generation cycles for subsequent update.
<<figure class>>=
			lst ch=ex_to<cycle_node>(x.second).get_children();
			for (const auto& it1 : ch)
				all_child.append(it1);
		}
	all_child.sort();
	all_child.unique();
	update_node_lst(all_child);
	return *this;
}

@
\subsubsection{Additional methods}
\label{sec:additional-methods}

@ Set the new metric for the figure, repeating the previous code from
the constructor.
<<figure class>>=
void figure::set_metric(const ex & Mp, const ex & Mc)
{
	ex D=get_dim();
	<<set point metric in figure>>
	<<set cycle metric in figure>>
	<<check dimensionalities point and cycle metrics>>
@ %def set_metric

@ We check that the dimensionality of the new metric matches the old one.
<<figure class>>=
	if (! (D-get_dim()).is_zero())
		throw(std::invalid_argument("New metric has a different dimensionality!"));
	update_cycles();
}

@ The method collects all key for nodes with generations in the range
{[}[[intgen]],[[maxgen]]{]} inclusively.
<<figure class>>=
ex figure::get_all_keys(const int mingen, const int maxgen) const {
	lst keys;
	for (const auto& x: nodes) {
		if (x.second.get_generation() >= mingen &&
			(maxgen == GHOST_GEN || x.second.get_generation() <= maxgen))
			keys.append(x.first);
	}
	return keys;
}
@ %def get_all_keys

@  The method also collects all key for nodes with generations in the range
{[}[[intgen]],[[maxgen]]{]} inclusively and sort them according to
their generations from smaller to larger.
<<figure class>>=
ex figure::get_all_keys_sorted(const int mingen, const int maxgen) const {
	lst keys;
	int mg=get_max_generation();
	if (maxgen != GHOST_GEN && maxgen < mg)
			mg =maxgen;
	for (int i=mingen; i <= mg; ++i)
		for (const auto& x: nodes) {
			if (x.second.get_generation() == i)
				keys.append(x.first);
	}
	return keys;
}
@ %def get_all_keys_sorted

@ Scanning for the biggest number generation.
<<figure class>>=
int figure::get_max_generation() const {
	int max_gen = REAL_LINE_GEN;
	for (const auto& x: nodes)
        if (x.second.get_generation() > max_gen)
			max_gen = x.second.get_generation();
	return max_gen;
}
@ %def get_max_generation


@ Return the list of cycles stored in the node with [[key]].
<<figure class>>=
ex figure::get_cycles(const ex & key, const ex & metric) const
{
	exhashmap<cycle_node>::const_iterator  cnode=nodes.find(key);
	if (cnode == nodes.end()) {
		if (FIGURE_DEBUG)
			cerr << "There is no key " << key << " in the figure." << endl;
		return lst{};
	} else
		return cnode->second.make_cycles(metric);
}
@ %def get_cycle

@ Full reset of figure to the initial empty state.
<<figure class>>=
void figure::reset_figure()
{
	nodes.clear();
	<<set the infinity>>
	<<set the real line>>
}
@ %def reset_figure

@ Update nodes in the list and all their (grand)children subsequently.
<<figure class>>=
void figure::update_node_lst(const ex & inlist)
{
	if (info(status_flags::expanded))
		return;

	lst intake=ex_to<lst>(inlist);
	while (intake.nops() !=0) {
		int mingen=nodes[*intake.begin()].get_generation();
		for (const auto& it : intake)
			mingen=min(mingen, nodes[it].get_generation());
		lst current, future;
		for (const auto& it : intake)
			if (nodes[it].get_generation() == mingen)
				current.append(it);
			else
				future.append(it);
@ %def update_node_lst

@ All nodes at the current list are updated.
<<figure class>>=
	for (const auto& it : current) {
		nodes[it].set_cycles(ex_to<lst>(update_cycle_node(it)));
		lst nchild=nodes[it].get_children();
		for (const auto& it1 : nchild)
			future.append(it1);
	}

@ Future list becomes new intake.
<<figure class>>=
		intake=future;
		intake.sort();
		intake.unique();
	}
}

@ Find a symbolic key for a cycle labelled by a [[name]].
<<figure class>>=
ex figure::get_cycle_key(string name) const
{
	for (const auto& x: nodes)
		if (ex_to<symbol>(x.first).get_name() == name)
			return x.first;

	return 0;
}
@ %def get_cycle_key

@
\subsubsection{Drawing methods}
\label{sec:drawing-methods}

@ Drawing the figure is possible only in two dimensions, thus we check
this at the start.
<<figure class>>=
void figure::asy_draw(ostream & ost, ostream & err, const string picture,
					  const ex & xmin, const ex & xmax, const ex & ymin, const ex & ymax,
					  asy_style style, label_string lstring, bool with_realline,
					  bool with_header, int points_per_arc, const string imaginary_options,
					  bool with_labels) const
{
	<<check that dimensionality is 2>>
@ %def asy_draw

@
<<check that dimensionality is 2>>=
	if (! (get_dim()-2).is_zero())
		throw logic_error("Drawing is possible for two-dimensional figures only!");

@ We will need to place different types of cycle into the different
places of the \Asymptote\ file.
<<figure class>>=
	stringstream preamble_stream, main_stream, labels_stream;
	string dots;
	std::regex re("dot\\(");

@ Some bits will depend on the metric in the point space.
<<figure class>>=
        int point_metric_signature=ex_to<numeric>(ex_to<clifford>(point_metric).get_metric(idx(0,2),idx(0,2))
												  *ex_to<clifford>(point_metric).get_metric(idx(1,2),idx(1,2)).eval()).to_int();

	for (const auto& x: nodes) {
		lst cycles=ex_to<lst>(x.second.make_cycles(point_metric));
		bool first_dot=true;

		for (const auto& it1 : cycles)
			try {
				if ( (x.second.get_generation() > REAL_LINE_GEN) ||
					 ((x.second.get_generation() == REAL_LINE_GEN) && with_realline)) {
					stringstream sstr;
					if (with_header)
						sstr << "// label: " << (x.first) << endl;

@ Produce the coulour and style for the cycle.
<<figure class>>=
				lst colours=lst{0,0,0};
				string asy_opt;
				if (x.second.custom_asy=="") {
					asy_opt=style(x.first, (it1), colours);
				} else
					asy_opt=x.second.custom_asy;

@ Zero-radius cycles are treated specially, its centre become known to
Asymptote as a [[pair]].
<<figure class>>=
			if (is_less_than_epsilon(ex_to<cycle>(it1).det())) {
				double x1=ex_to<numeric>(ex_to<cycle>(it1).center(cycle_metric).op(0)
										.evalf()).to_double(),
					y1=ex_to<numeric>(ex_to<cycle>(it1).center(cycle_metric).op(1)
										.evalf()).to_double();
				string var_name=regex_replace(ex_to<symbol>(x.first).get_name(), regex("[[:space:]]+"), "_");
				if (first_dot) {
					preamble_stream << "// label: " << (x.first) << endl
									<< "pair[] " << var_name << "={";
					first_dot = false;
				} else
					preamble_stream  << ", ";

				preamble_stream  << "(" << x1 << "," << y1 << ")";

@ In the elliptic case we place the dot explicitly\ldots
<<figure class>>=
				if (point_metric_signature > 0
					&& xmin <= x1 && x1<=xmax && ymin <= y1 && y1<=ymax) {
						sstr << "dot(" << var_name
							 << (asy_opt==""? "": ", ") << asy_opt
							 << ");" << endl;

@ \ldots , otherwise output is handled by the [[cycle2D::draw_asy]] method
<<figure class>>=
				} else {
					ex_to<cycle2D>(it1).asy_draw(sstr, picture, xmin, xmax,
											 ymin, ymax, colours, asy_opt, with_header, points_per_arc, imaginary_options);

@  Since in parabolic spaces zero-radius cycles are detached from the
their centres, which they denote we wish to have a hint on centres positions.
<<figure class>>=
					if (FIGURE_DEBUG && point_metric_signature==0
						&& xmin <= x1 && x1<=xmax && ymin <= y1 && y1<=ymax)
						sstr << "dot(" << var_name << ", black+3pt);" << endl;
				}

@ Drawing a generic cycle through [[cycle2D::draw_asy]] method
<<figure class>>=
			} else
				ex_to<cycle2D>(it1).asy_draw(sstr, picture, xmin, xmax,
											 ymin, ymax, colours, asy_opt, with_header, points_per_arc, imaginary_options);


@  Dots and label will be drawn last to avoid over-painting.
<<figure class>>=
				if (std::regex_search(sstr.str(), re))
					dots+=sstr.str();
				else
					main_stream << sstr.str();

@ Find the label position
<<figure class>>=
				if (with_labels)
					labels_stream << lstring(x.first, (it1), sstr.str());
				}
			} catch (exception &p) {
				if (FIGURE_DEBUG)
					err << "Failed to draw " << x.first <<": " << x.second;
			}

@ We do not forget to close the array of dots if any were printed.
<<figure class>>=
		if (! first_dot)
			preamble_stream << "};" << endl;
	}
	//cerr << "Dots: " << dots;

@ We record [[info_text]] as a comment to start the \Asymptote\
file. We try to replace possible end-of-comment symbols.
<<figure class>>=
	ost  << "/*" << endl
		<< std::regex_replace(info_text, std::regex("\\*/"), "* /") << endl
		<< "*/" << endl;

@  If dots were output, we produce an auxiliary function, which labels
an array of points.
<<figure class>>=
	if (preamble_stream.str() != "")
		ost << "// An auxiliary function" << endl
			<< "void label(string L, pair[] P, pair D) {" << endl
			<< "  for(pair k : P)" << endl
			<< "    label(L, k, D);" << endl
			<< "}" << endl
			<< preamble_stream.str();

@ Finally, we output the rest of drawings.
<<figure class>>=
	ost << main_stream.str()
		<< dots
		<< labels_stream.str();
}

@
<<figure class>>=
void figure::asy_write(int size, const ex & xmin, const ex & xmax, const ex & ymin, const ex & ymax,
					  string name, string format,
					  asy_style style, label_string lstring, bool with_realline,
					  bool with_header, int points_per_arc, const string imaginary_options,
					  bool rm_asy_file, bool with_labels) const
{
	<<check that dimensionality is 2>>
@ %def asy_write

@ Open the file.
<<figure class>>=
	string filename=name+".asy";
	ofstream out(filename);
	out << "size(" << size << ");" << endl;
	asy_draw(out, cerr, "", xmin, xmax, ymin, ymax,
			 style, lstring, with_realline, with_header, points_per_arc, imaginary_options, with_labels);
	if (name == "")
		out << "shipout();" << endl;
	else
		out << "shipout(\"" << name << "\");" << endl;
	out.flush();
	out.close();

@ Preparation of \Asymptote\ call.
<<figure class>>=
	char command[256];
	strcpy(command, show_asy_graphics? "asy -V" : "asy");
	if (format != "") {
		strcat(command, " -f ");
		strcat(command, format.c_str());
	}
	strcat(command, " ");
	strcat(command, name.c_str());
	char * pcommand=command;
	system(pcommand);
	if (rm_asy_file)
		remove(filename.c_str());
}

@ This method animates figures with parameters.
<<figure class>>=
void figure::asy_animate(const ex &val,
						 int size, const ex & xmin, const ex & xmax, const ex & ymin, const ex & ymax,
						 string name, string format, asy_style style, label_string lstring, bool with_realline,
						 bool with_header, int points_per_arc, const string imaginary_options,
						 const string values_position, bool rm_asy_file, bool with_labels) const
{
	<<check that dimensionality is 2>>
	string filename=name+".asy";
	ofstream out(filename);
@ %def asy_animate

@ Header of the file depends from format.
<<figure class>>=
	if (format == "pdf")
		out << "settings.tex=\"pdflatex\";" << endl
			<< "settings.embed=true;" << endl
			<< "import animate;" << endl
			<< "size(" << size << ");" << endl
			<< "animation a=animation(\"" << name << "\");" << endl;
	else
		out << "import animate;" << endl
			<< "size(" << size << ");" << endl
			<< "animation a;" << endl;

@ For every element of [[val]] we perform the substitution and draw
the corresponding picture.
<<figure class>>=
	for (const auto& it : ex_to<lst>(val)) {
		out << "save();" << endl;
		unfreeze().subs(it).asy_draw(out, cerr, "", xmin, xmax, ymin, ymax,
									 style, lstring, with_realline, with_header, points_per_arc, imaginary_options, with_labels);

@ We prepare the value string for output.
<<figure class>>=
		std::regex deq ("==");
		stringstream sstr;
		sstr <<  (ex)it;
		string val_str=std::regex_replace(sstr.str(),deq,"=");

@ We put the value of parameters to the figure in accordance with [[values_position]].
<<figure class>>=
		if (values_position=="bl")
			out << "label(\"\\texttt{" << val_str << "}\",(" << xmin << "," << ymin << "), SE);";
		else if (values_position=="br")
			out << "label(\"\\texttt{" << val_str << "}\",(" << xmax << "," << ymin << "), SW);";
		else if (values_position=="tl")
			out << "label(\"\\texttt{" << val_str << "}\",(" << xmin << "," << ymax << "), NE);";
		else if (values_position=="tr")
			out << "label(\"\\texttt{" << val_str << "}\",(" << xmax << "," << ymax << "), NW);";

		out << "a.add();" << endl
			<< "restore();" << endl;
	}

@ For output in PDF, GIF, MNG or MP4 format we supply default
commands. User may do a custom command using [[format]] parameter.
<<figure class>>=
	if (format == "pdf")
		out << "label(a.pdf(\"controls\",delay=250,keep=!settings.inlinetex));" << endl;
	else if ((format == "gif") ||  (format == "mp4") || (format == "mng"))
		out << "a.movie(loops=10,delay=250);" << endl;
	else
		out << format << endl;
	out.flush();
	out.close();

@ Finally we run \Asymptote\ to produce an animation.
<<figure class>>=
	char command[256];
	strcpy(command, show_asy_graphics? "asy -V " : "asy ");
	if ((format == "gif") || (format == "mp4") || (format == "mng")) {
		strcat(command, " -f ");
		strcat(command, format.c_str());
		strcat(command, " ");
	}
	strcat(command, name.c_str());
	char * pcommand=command;
	system(pcommand);
	if (rm_asy_file)
		remove(filename.c_str());
}

@ All cycles in generations starting from [[first_gen]] (default value is
\(0\)) are dumped to a text file [[name.txt]]. Firstly, we check that the
figure is three dimensional and then open the file.
<<figure class>>=
void figure::arrangement_write(string name, int first_gen) const
{
	if (! (get_dim()-3).is_zero())
		throw(std::invalid_argument("figure::arrangement_write(): the figure is not in 3D!"));

	string filename=name+".txt";
	ofstream out(filename);
@ %def arrangement_write

@ We produce the iterator over all keys. This is a \GiNaC\ [[lst]]
thus we need iterations through its components.
<<figure class>>=
	lst keys=ex_to<lst>(get_all_keys_sorted(first_gen));
	for (const auto& itk : keys) {
		ex gen=get_generation(itk);
		lst L=ex_to<lst>(get_cycles(itk));

@  This is again a \GiNaC\ [[lst]], thus we need iterations through
its components again.
<<figure class>>=
	for (const auto& it : L) {
		cycle C=ex_to<cycle>(it);
		ex center = C.center();

@ A line of text represents a cycle by three coordinates of its
centre, radius, generation and label.
<<figure class>>=
		out <<  center.op(0).evalf() << " " << center.op(1).evalf() << " " << center.op(2).evalf()
			<< " " << sqrt(C.radius_sq()).evalf()
			<< " " << gen
			<< " " << itk
			<< endl;
		}
	}
	out.flush();
	out.close();
}

@
\subsubsection{Service utilities}
\label{sec:service-utilities}

@ Here is the minimal set of service procedures which is reuired by
\GiNaC\ for derived classes.
<<figure class>>=
return_type_t figure::return_type_tinfo() const
{
	return make_return_type_t<figure>();
}

@
<<figure class>>=
int figure::compare_same_type(const basic &other) const
{
       GINAC_ASSERT(is_a<figure>(other));
	   return inherited::compare_same_type(other);
}

@ To print the figure means to print all its nodes.
<<figure class>>=
void figure::do_print(const print_dflt & con, unsigned level) const {
	lst keys=ex_to<lst>(get_all_keys_sorted(FIGURE_DEBUG?GHOST_GEN:INFINITY_GEN));
	int N_cycle=0;

	for (const auto& ck: keys) {
		N_cycle += get_cycles(ck).nops();
		con.s << ck <<": " << get_cycle_node(ck);
	}

	con.s << "Altogether " << N_cycle << " cycles in "
		  << keys.nops() << " cycle_nodes." << endl;
}

@ This is a variation of printing in the float form.
<<figure class>>=
void figure::do_print_double(const print_dflt & con, unsigned level) const {
	for (const auto& x: nodes) {
		if (x.second.get_generation() > GHOST_GEN  || FIGURE_DEBUG) {
			con.s << x.first <<": ";
			ex_to<cycle_node>(x.second).do_print_double(con, level);
		}
	}
}

@
<<figure class>>=
ex figure::op(size_t i) const
{
 GINAC_ASSERT(i<nops());
	switch(i) {
	case 0:
		return real_line;
	case 1:
		return infinity;
	case 2:
		return point_metric;
	case 3:
		return cycle_metric;
	default:
		exhashmap<cycle_node>::const_iterator it=nodes.begin();
		for (size_t n=4; n<i;++n)
			++it;
		return it->second;
	}
}

@
<<figure class>>=
/*ex & figure::let_op(size_t i)
{
	ensure_if_modifiable();
	GINAC_ASSERT(i<nops());
	switch(i) {
	case 0:
		return real_line;
	case 1:
		return infinity;
	case 2:
		return point_metric;
	case 3:
		return cycle_metric;
	default:
		exhashmap<cycle_node>::iterator it=nodes.begin();
		for (size_t n=4; n<i;++n)
			++it;
		return nodes[it->first];
	}
}*/

@ We need to make substitution in the form of [[exmap]].
<<figure class>>=
figure figure::subs(const ex & e, unsigned options) const
{
	exmap m;
	if (e.info(info_flags::list)) {
		lst sl = ex_to<lst>(e);
		for (const auto& i : sl)
			m.insert(std::make_pair(i.op(0), i.op(1)));
	} else if (is_a<relational>(e)) {
		m.insert(std::make_pair(e.op(0), e.op(1)));
	} else
		throw(std::invalid_argument("cycle::subs(): the parameter should be a relational or a lst"));

	return ex_to<figure>(subs(m, options));
}

@
<<figure class>>=
ex figure::subs(const exmap & m, unsigned options) const
{
	exhashmap<cycle_node> snodes;
	for (const auto& x: nodes)
		snodes[x.first]=ex_to<cycle_node>(x.second.subs(m, options));

	if (options & do_not_update_subfigure)
		return figure(point_metric.subs(m, options), cycle_metric.subs(m, options), snodes);
	else
		return figure(point_metric.subs(m, options), cycle_metric.subs(m, options), snodes).update_cycles();
}

@
<<figure class>>=
ex figure::evalf(int level) const
{
	exhashmap<cycle_node> snodes;
	for (const auto& x: nodes)
#if GINAC_VERSION_ATLEAST(1,7,0)
		snodes[x.first]=ex_to<cycle_node>(x.second.evalf());

	return figure(point_metric.evalf(), cycle_metric.evalf(), snodes);
#else
		snodes[x.first]=ex_to<cycle_node>(x.second.evalf(level));

	return figure(point_metric.evalf(level), cycle_metric.evalf(level), snodes);
#endif
}

@
\subsubsection{Archiving/Unarchiving utilities}
\label{sec:arch-util}

@
<<figure class>>=
void figure::archive(archive_node &an) const
{
	inherited::archive(an);
	an.add_ex("real_line", real_line);
	an.add_ex("infinity", infinity);
	an.add_ex("point_metric", point_metric);
	an.add_ex("cycle_metric", cycle_metric);
	an.add_bool("float_evaluation", float_evaluation);

@ [[exhashmap]] class does not have an archiving facility, thus we store it as two correponding lists.
<<figure class>>=
	lst keys, cnodes;
	for (const auto& x: nodes) {
		keys.append(x.first);
		cnodes.append(x.second);
	}
	an.add_ex("keys", keys);
	an.add_ex("cnodes", cnodes);
	an.add_string("info_text", info_text);
}

@ The respective un-archiving function. For some unclear reasons if both point
and cycle metrics are indexed by the same symbol, then the cyle metric
becomes a copy of the point one.
<<figure class>>=
void figure::read_archive(const archive_node &an, lst &sym_lst)
{
	inherited::read_archive(an, sym_lst);
	an.find_ex("point_metric",  point_metric, sym_lst);
	an.find_ex("cycle_metric", cycle_metric, sym_lst);
	lst all_sym=sym_lst;
	ex keys, cnodes;
	an.find_ex("real_line", real_line, sym_lst);
	all_sym.append(real_line);
	an.find_ex("infinity", infinity, sym_lst);
	all_sym.append(infinity);
	an.find_bool("float_evaluation", float_evaluation);

@
<<figure class>>=
	//an.find_ex("keys", keys, all_sym);
	an.find_ex("keys", keys, sym_lst);
	for (const auto& it : ex_to<lst>(keys))
		all_sym.append(it);
	all_sym.sort();
	all_sym.unique();
	an.find_ex("cnodes", cnodes, all_sym);
	lst::const_iterator it1 = ex_to<lst>(cnodes).begin();
	nodes.clear();
	for (const auto& it : ex_to<lst>(keys)) {
		nodes[it]=ex_to<cycle_node>(*it1);
		++it1;
	}
	an.find_string("info_text", info_text);
}

@
<<figure class>>=
GINAC_BIND_UNARCHIVER(figure);

@
<<figure class>>=
bool figure::info(unsigned inf) const
{
	switch (inf) {
	case status_flags::expanded:
		return (inf & flags);
	}
	return inherited::info(inf);
}

@
\subsubsection{Relations and measurements}
\label{sec:relat-meas}

@ The method to check that two cycles are in a relation.
<<figure class>>=
ex figure::check_rel(const ex & key1, const ex & key2, PCR rel, bool use_cycle_metric,
					 const ex & parameter, bool corresponds) const
{
	<<run through all cycles in two nodes correspondingly>>
	<<add checked relation>>
	<<run through all cycles in two nodes async>>
	<<add checked relation>>
@ %def check_rel

@ This piece of code is common in [[check_rel]] and [[measure]].
<<run through all cycles in two nodes correspondingly>>=
	lst res,
		cycles1=ex_to<lst>(ex_to<cycle_node>(nodes.find(key1)->second)
						   .make_cycles(use_cycle_metric? cycle_metric : point_metric)),
		cycles2=ex_to<lst>(ex_to<cycle_node>(nodes.find(key2)->second)
						   .make_cycles(use_cycle_metric? cycle_metric : point_metric));

	if (corresponds && cycles1.nops() == cycles2.nops()) {
		auto it2=cycles2.begin();
		for (const auto& it1 : cycles1) {
			lst calc=ex_to<lst>(rel(it1,*(it2++),parameter));
			for (const auto& itr : calc)

@ We add corresponding relation. We wish to make output homogeneous
despite of the fact that [[rel]] can be of different type: either
returning [[relational]] or not.
<<add checked relation>>=
			{
				ex e=(itr.op(0)).normal();
				if (is_a<relational>(e))
					res.append(e);
				else
					res.append(e==0);
			}

@ If cycles are treated asynchronously we run two independent loops.
<<run through all cycles in two nodes async>>=
	  }
	} else {
		for (const auto& it1 : cycles1) {
			for (const auto& it2 : cycles2) {
				lst calc=ex_to<lst>(rel(it1,it2,parameter));
				for (const auto& itr : calc)

@ Simply finish the routine with the right number of brackets.
<<figure class>>=
			}
		}
	}
	return res;
}

@ The method to measure certain quantity, it essentially copies code
from the previous method.
<<figure class>>=
ex figure::measure(const ex & key1, const ex & key2, PCR rel, bool use_cycle_metric,
				   const ex & parameter, bool corresponds) const
{
	<<run through all cycles in two nodes correspondingly>>
	res.append(itr.op(0));
	<<run through all cycles in two nodes async>>
	res.append(itr.op(0));
				}
			}
		}
	return res;
}
@ %def measure

@ We apply [[func]] to all cycles in the, figure one-by-one.
<<figure class>>=
ex figure::apply(PEVAL func, bool use_cycle_metric, const ex & param) const
{
	lst res;
	for (const auto& x: nodes) {
		int i=0;
		lst cycles=ex_to<lst>(x.second.make_cycles(use_cycle_metric? cycle_metric : point_metric));
		for (const auto& itc : cycles) {
			res.append(lst{func(itc, param), x.first, i});
			++i;
		}
	}
	return res;
}
@ %def apply

@
\subsubsection{Default Asymptote styles}
\label{sec:defa-asympt-styl}

@ A simple \Asymptote\ style. We produce different colours for points,
lines and circles. No further options are specified.
<<figure class>>=
string asy_cycle_color(const ex & label, const ex & C, lst & color)
{
	string asy_options="";
	if (is_less_than_epsilon(ex_to<cycle>(C).det())) {// point
		color=lst{0.5,0,0};
		asy_options="dotted";
	} else if (is_less_than_epsilon(ex_to<cycle>(C).get_k())) // straight line
		color=lst{0,0.5,0};
	else  // a proper circle-hyperbola-parabola
		color=lst{0,0,0.5};

	return asy_options;
}
@ %def asy_cycle_color

@  A style to place labels.
<<figure class>>=
string label_pos(const ex & label, const ex & C, const string draw_str) {
	stringstream sstr;
	sstr << latex << label;

	string name=ex_to<symbol>(label).get_name(), new_TeXname;

	if (sstr.str() == name) {
		string TeXname;
		<<auto TeX name>>
		if (TeXname_new =="")
			new_TeXname=name;
		else
			new_TeXname=TeXname_new;
	} else
		new_TeXname=sstr.str();
@ %def label_pos

@ We use [[regex]] to spot places for labels in the \Asymptote\ output.
<<figure class>>=
	std::regex draw("([.\\n\\r\\s]*)(draw)\\(([\\w]+,)?((?:\\(.+?\\)|\\{.+?\\}|[^-,0-9\\.])+),([.\\n\\r]*)");
	std::regex dot("([.\\n\\r\\s]*)(dot)\\(([\\w]*,)?((?:\\(.+?\\)|\\{.+?\\}|[^-,0-9\\.])+|[\\w]+),([.\\n\\r]*)");
	std::regex e1("symbolLaTeXname");

	if (std::regex_search(draw_str, dot)) {
			string labelstr=std::regex_replace (draw_str, dot,
								"label($3\"$symbolLaTeXname$\", $4, SE);\n",
								std::regex_constants::format_no_copy);
			return std::regex_replace (labelstr, e1, new_TeXname);
	} else if (std::regex_search(draw_str, draw)) {
			string labelstr=std::regex_replace (draw_str, draw,
								"label($3\"$symbolLaTeXname$\", point($4,0.1), SE);\n",
								std::regex_constants::format_no_copy | std::regex_constants::format_first_only);
			return std::regex_replace (labelstr, e1, new_TeXname);
	} else
		return "";
}

@
\subsection{Functions defining cycle relations}
\label{sec:cycles-relations}

@ This is collection of linear cycle relations which do not require a parameter.
<<add cycle relations>>=
ex cycle_orthogonal(const ex & C1, const ex & C2, const ex & pr)
{
	return lst{(ex)lst{ex_to<cycle>(C1).is_orthogonal(ex_to<cycle>(C2))}};
}
@ %def cycle_orthogonal

@
<<add cycle relations>>=
ex cycle_f_orthogonal(const ex & C1, const ex & C2, const ex & pr)
{
	return lst{(ex)lst{ex_to<cycle>(C1).is_f_orthogonal(ex_to<cycle>(C2))}};
}
@ %def cycle_f_orthogonal

@
<<add cycle relations>>=
ex cycle_adifferent(const ex & C1, const ex & C2, const ex & pr)
{
	return lst{(ex)lst{cycle_data(C1).is_almost_equal(ex_to<basic>(cycle_data(C2)),true)? 0: 1}};
}
@ %def cycle_adifferent

@ To \emph{check} the tangential property we use the condition from
\cite{Kisil12a}*{Ex.~5.26(i)}
\begin{equation}
  \label{eq:tangent-condition}
  (\scalar{C_1}{C_2})^2-\scalar{C_1}{C_1}\scalar{C_2}{C_2}=0.
\end{equation}
<<add cycle relations>>=
ex check_tangent(const ex & C1, const ex & C2, const ex & pr)
{
	return lst{(ex)lst{pow(ex_to<cycle>(C1).cycle_product(ex_to<cycle>(C2)),2)
				-ex_to<cycle>(C1).cycle_product(ex_to<cycle>(C1))
				*ex_to<cycle>(C2).cycle_product(ex_to<cycle>(C2)) == 0}};
}
@ %def check_tangent

@ To \emph{define} tangential property, theoretically we can
use~\eqref{eq:tangent-condition} as well.
However, a system of several such quadratic conditions will be difficult to
resolve. Thus, we use a single quadratic relations
\(\scalar{C_1}{C_1}=-1\) which allows to linearise the tangential
property to a pair of identities: \(\scalar{C_1}{C_2}\pm\sqrt{\scalar{C_2}{C_2}}=0\).
<<add cycle relations>>=
ex cycle_tangent(const ex & C1, const ex & C2, const ex & pr)
{
	return lst{lst{ex_to<cycle>(C1).cycle_product(ex_to<cycle>(C1))+numeric(1)==0,
					ex_to<cycle>(C1).cycle_product(ex_to<cycle>(C2))
				   -sqrt(abs(ex_to<cycle>(C2).cycle_product(ex_to<cycle>(C2))))==0},
			   lst{ex_to<cycle>(C1).cycle_product(ex_to<cycle>(C1))-numeric(1)==0,
					ex_to<cycle>(C1).cycle_product(ex_to<cycle>(C2))
				   -sqrt(abs(ex_to<cycle>(C2).cycle_product(ex_to<cycle>(C2))))==0},
			   lst{ex_to<cycle>(C1).cycle_product(ex_to<cycle>(C1))+numeric(1)==0,
					ex_to<cycle>(C1).cycle_product(ex_to<cycle>(C2))
				   +sqrt(abs(ex_to<cycle>(C2).cycle_product(ex_to<cycle>(C2))))==0},
			   lst{ex_to<cycle>(C1).cycle_product(ex_to<cycle>(C1))-numeric(1)==0,
					ex_to<cycle>(C1).cycle_product(ex_to<cycle>(C2))
				   +sqrt(abs(ex_to<cycle>(C2).cycle_product(ex_to<cycle>(C2))))==0}};
}
@ %def cycle_tangent

@
<<add cycle relations>>=
ex cycle_tangent_o(const ex & C1, const ex & C2, const ex & pr)
{
	return lst{lst{ex_to<cycle>(C1).cycle_product(ex_to<cycle>(C1))+numeric(1)==0,
				ex_to<cycle>(C1).cycle_product(ex_to<cycle>(C2))
				-sqrt(abs(ex_to<cycle>(C2).cycle_product(ex_to<cycle>(C2))))==0},
			lst{ex_to<cycle>(C1).cycle_product(ex_to<cycle>(C1))-numeric(1)==0,
					ex_to<cycle>(C1).cycle_product(ex_to<cycle>(C2))
					-sqrt(abs(ex_to<cycle>(C2).cycle_product(ex_to<cycle>(C2))))==0}};
}
@ %def cycle_tangent_o

@
<<add cycle relations>>=
ex cycle_tangent_i(const ex & C1, const ex & C2, const ex & pr)
{
	return lst{lst{ex_to<cycle>(C1).cycle_product(ex_to<cycle>(C1))+numeric(1)==0,
				ex_to<cycle>(C1).cycle_product(ex_to<cycle>(C2))
				+sqrt(abs(ex_to<cycle>(C2).cycle_product(ex_to<cycle>(C2))))==0},
			lst{ex_to<cycle>(C1).cycle_product(ex_to<cycle>(C1))-numeric(1)==0,
					ex_to<cycle>(C1).cycle_product(ex_to<cycle>(C2))
					+sqrt(abs(ex_to<cycle>(C2).cycle_product(ex_to<cycle>(C2))))==0}};
}
@ %def cycle_tangent_i

@
<<add cycle relations>>=
ex cycle_different(const ex & C1, const ex & C2, const ex & pr)
{
	return lst{(ex)lst{ex_to<cycle>(C1).is_equal(ex_to<basic>(C2), true)? 0: 1}};
}
@ %def cycle_different

@ If the cycle product has imaginary part we return the false
statement. For a real cycle product we check its sign.
<<add cycle relations>>=
ex product_sign(const ex & C1, const ex & C2, const ex & pr)
{
	if (is_less_than_epsilon(ex_to<cycle>(C1).cycle_product(ex_to<cycle>(C1)).evalf().imag_part()))
		return lst{(ex)lst{pr*(ex_to<cycle>(C1).cycle_product(ex_to<cycle>(C1)).evalf().real_part() - epsilon) <0}};
	else
		return lst{(ex)lst{numeric(1) <0}};
}
@ %def product_sign

@ Now we define the relation between cycles to ``intersect with
certain angle'' (but the ``intersection'' may be imaginary). If cycles
are intersecting indeed then the value of [[pr]] is the cosine of the
angle.
<<add cycle relations>>=
ex cycle_angle(const ex & C1, const ex & C2, const ex & pr)
{
	return lst{lst{ex_to<cycle>(C1).cycle_product(ex_to<cycle>(C2).normalize_norm())-pr==0,
				ex_to<cycle>(C1).cycle_product(ex_to<cycle>(C1))+numeric(1)==0},
			lst{ex_to<cycle>(C1).cycle_product(ex_to<cycle>(C2).normalize_norm())-pr==0,
					ex_to<cycle>(C1).cycle_product(ex_to<cycle>(C1))-numeric(1)==0}};
}
@ %def cycle_angle

@ The next relation defines tangential distance between cycles.
<<add cycle relations>>=
ex steiner_power(const ex & C1, const ex & C2, const ex & pr)
{
	cycle C=ex_to<cycle>(C2).normalize();
	return lst{lst{ex_to<cycle>(C1).cycle_product(C)+sqrt(abs(C.cycle_product(C)))
				-pr*ex_to<cycle>(C1).get_k()==0,
				ex_to<cycle>(C1).cycle_product(ex_to<cycle>(C1))+numeric(1)==0},
			lst{ex_to<cycle>(C1).cycle_product(C)+sqrt(abs(C.cycle_product(C)))
						-pr*ex_to<cycle>(C1).get_k()==0,
					ex_to<cycle>(C1).cycle_product(ex_to<cycle>(C1))-numeric(1)==0}};
}
@ %def steiner_power

@ Cross tangential distance is different by a sign of one term.
<<add cycle relations>>=
ex cycle_cross_t_distance(const ex & C1, const ex & C2, const ex & pr)
{
	cycle C=ex_to<cycle>(C2).normalize();
	return lst{lst{ex_to<cycle>(C1).cycle_product(C)-sqrt(abs(C.cycle_product(C)))
				-pow(pr,2)*ex_to<cycle>(C1).get_k()==0,
				ex_to<cycle>(C1).cycle_product(ex_to<cycle>(C1))+numeric(1)==0},
			lst{ex_to<cycle>(C1).cycle_product(C)-sqrt(abs(C.cycle_product(C)))
				-pow(pr,2)*ex_to<cycle>(C1).get_k()==0,
				ex_to<cycle>(C1).cycle_product(ex_to<cycle>(C1))-numeric(1)==0}};
}
@ %def cycle_cross_t_distance

@ Check that all coefficients of the first cycle are real.
<<add cycle relations>>=
ex coefficients_are_real(const ex & C1, const ex & C2, const ex & pr)
{
	cycle C=ex_to<cycle>(ex_to<cycle>(C1.evalf()).imag_part());
	if (! (is_less_than_epsilon(C.get_k()) && is_less_than_epsilon(C.get_m())))
		return lst{(ex)lst{0}};
	for (int i=0; i < ex_to<cycle>(C1).get_dim(); ++i)
		if (! is_less_than_epsilon(C.get_l(i)))
			return lst{(ex)lst{0}};

	return lst{(ex)lst{1}};
}
@ %def coefficients_are_real

@
\subsubsection{Measured quantities}
\label{sec:measured-quantities}

@ This function measures relative powers of two cycles, which turn to
be their cycle product for norm-normalised vectors.
<<add cycle relations>>=
ex angle_is(const ex & C1, const ex & C2, const ex & pr)
{
	return lst{(ex)lst{ex_to<cycle>(C1).normalize_norm().cycle_product(ex_to<cycle>(C2).normalize_norm())}};
}
@ %def angle_is

@ This function measures relative powers of two cycles, which turn to
be their cycle product for \(k\)-normalised vectors.
<<add cycle relations>>=
ex power_is(const ex & C1, const ex & C2, const ex & pr)
{
	cycle Ca=ex_to<cycle>(C1).normalize(), Cb=ex_to<cycle>(C2).normalize();

	return lst{(ex)lst{Ca.cycle_product(Cb)+pr*sqrt(abs(Ca.cycle_product(Ca)*Cb.cycle_product(Cb)))}};
}
@ %def power_is

@
<<add cycle relations>>=
ex cycle_moebius(const ex & C1, const ex & C2, const ex & pr)
{
	return lst{(ex)lst{ex_to<cycle>(C2).matrix_similarity(pr.op(0),pr.op(1),pr.op(2),pr.op(3))}};
}
@ %def cycle_moebius

@ That relations works only for real matrices, thus we start from the relevant checks.
<<add cycle relations>>=
cycle_relation sl2_transform(const ex & key, bool cm, const ex & matrix) {
	if (is_a<lst>(matrix) && matrix.op(0).info(info_flags::real) && matrix.op(1).info(info_flags::real)
		&& matrix.op(2).info(info_flags::real) && matrix.op(3).info(info_flags::real))
			return cycle_relation(key, cycle_sl2, cm, matrix);
	else
		throw(std::invalid_argument("sl2_transform(): shall be applied only with a matrix having"
									" real entries"));
}
@ %def sl2_transform

@ That relations works only in two dimensions, thus we start from the relevant checks.
<<add cycle relations>>=
ex cycle_sl2(const ex & C1, const ex & C2, const ex & pr)
{
	if (ex_to<cycle>(C2).get_dim() == 2)
		return lst{(ex)lst{ex_to<cycle>(C2).sl2_similarity(pr.op(0),pr.op(1),pr.op(2),pr.op(3),
													   ex_to<cycle>(C2).get_unit())}};
	else
		throw(std::invalid_argument("cycle_sl2(): shall be applied only in two dimensions"));
}
@ %def cycle_sl2

@
\subsection{Additional functions}
\label{sec:additional-functions}

@ Equality of [[cycle]]s.
<<addional functions>>=
bool is_almost_equal(const ex & A, const ex & B)
{
	if ((not is_a<cycle>(A)) || (not is_a<cycle>(B)))
		return false;

	const cycle C1 = ex_to<cycle>(A),
        C2 = ex_to<cycle>(B);
	ex factor=0, ofactor=0;

	// Check that coefficients are scalar multiples of C2
	if (not is_less_than_epsilon((C1.get_m()*C2.get_k()-C2.get_m()*C1.get_k()).normal()))
		return false;
	// Set up coefficients for proportionality
	if (C1.get_k().normal().is_zero()) {
		factor=C1.get_m();
		ofactor=C2.get_m();
	} else {
		factor=C1.get_k();
		ofactor=C2.get_k();
	}
@ %def is_almost_equal

@ Now we iterate through the coefficients of [[l]].
<<addional functions>>=
	   for (unsigned int i=0; i<C1.get_l().nops(); i++)
		// search the the first non-zero coefficient
		if (factor.is_zero()) {
			factor=C1.get_l(i);
			ofactor=C2.get_l(i);
		} else
			if (! is_less_than_epsilon((C1.get_l(i)*ofactor-C2.get_l(i)*factor).normal()))
				return false;
	return true;
}

@
<<addional functions>>=
ex midpoint_constructor()
{
 	figure SF=ex_to<figure>((new figure)->setflag(status_flags::expanded));

	ex v1=SF.add_cycle(cycle_data(),"variable000");
	ex v2=SF.add_cycle(cycle_data(),"variable001");
	ex v3=SF.add_cycle(cycle_data(),"variable002");
@ %def midpoint_constructor

@ Join three point by an "interval" cycle.
<<addional functions>>=
	ex v4=SF.add_cycle_rel(lst{cycle_relation(v1,cycle_orthogonal),
				cycle_relation(v2,cycle_orthogonal),
				cycle_relation(v3,cycle_orthogonal)},
		"v4");

@  A cycle ortogonal to the above interval.
<<addional functions>>=
	ex v5=SF.add_cycle_rel(lst{cycle_relation(v1,cycle_orthogonal),
				cycle_relation(v2,cycle_orthogonal),
				cycle_relation(v4,cycle_orthogonal)},
		"v5");

@  The perpendicular to the interval and the cycle passing the midpoint.
<<addional functions>>=
	ex v6=SF.add_cycle_rel(lst{cycle_relation(v3,cycle_orthogonal),
				cycle_relation(v4,cycle_orthogonal),
				cycle_relation(v5,cycle_orthogonal)},
		"v6");

@ The mid point as the intersection point.
<<addional functions>>=
	ex r=symbol("result");
 SF.add_cycle_rel(lst{cycle_relation(v4,cycle_orthogonal),
			 cycle_relation(v6,cycle_orthogonal),
			 cycle_relation(r,cycle_orthogonal,false),
			 cycle_relation(v3,cycle_adifferent)},
	 r);

	return SF;
}


@ This is an auxiliary function which removes duplicated cycles from a
list [[L]].
<<addional functions>>=
ex unique_cycle(const ex & L)
{
	if(is_a<lst>(L) && (L.nops() > 1) ) {
		lst res;
		lst::const_iterator it = ex_to<lst>(L).begin();
		if (is_a<cycle_data>(*it)) {
			res.append(*it);
			++it;
			for (; it != ex_to<lst>(L).end(); ++it) {
				bool is_new=true;
				if (! is_a<cycle_data>(*it))
					break; // a non-cycle detected, get out

				for (const auto& it1 : res)
					if (ex_to<cycle_data>(*it).is_almost_equal(ex_to<basic>(it1),true)
						|| ex_to<cycle_data>(*it).is_equal(ex_to<basic>(it1),true)) {
						is_new=false; // is a duplicate
						break;
					}
				if (is_new)
					res.append(*it);
			}
			if (it == ex_to<lst>(L).end()) // all are processed, no non-cycle is detected
				return res;
		}
	}
	return L;
}
@ %def unique_cycle

@ The debug output may be switched on and switched off by the
following methods.
<<addional functions>>=
void figure_debug_on() { FIGURE_DEBUG = true; }
void figure_debug_off() { FIGURE_DEBUG = false; }
bool figure_ask_debug_status() { return FIGURE_DEBUG; }
@ %def figure_debug_on figure_debug_off figure_ask_debug_status

@ Setting variable [[show_asy_graphics]] to switch \Asymptote\ display
on and off.
<<addional functions>>=
void show_asy_on() { show_asy_graphics=true; }
void show_asy_off() { show_asy_graphics=false; }
@ %def show_asy_on show_asy_off

@
\section{Change Log}
\label{sec:changes-log}

\begin{description}
\item[3.2] The following changes are committed:
  \begin{itemize}
  \item Add [[figure::info_text]] to record information for humans.
  \item Several bugs causing crashes fixed;
  \item Renamed several methods and members of different classes to
    avoid confusions and errors.
  \item Add method [[get_all_keys_sorted()]], which sorts output
    from lower to higher generations. Method  [[figure::do_print()]]
    uses it now for output.
  \item Better structure of the \Asymptote\ output.
  \item Add [[figure::get_max_generation()]] method.
  \item Fix archiving/unarchiving of figure.
  \item [[cycle_node]] is archiving its custom \Asymptote\ style.
  \item Minor improvements of code and documentation.
  \item Introduce [[do_print_double()]] for a more compact output of figures.
  \end{itemize}
\item[3.1] The following changes are committed:
  \begin{itemize}
  \item  Updated cycle solver to handle homogeneous equations properly
    and produce root-free parametrisation in some cases.
  \item Theoretical aspects are revised in documentation.
  \item In cycles with numerous instances only corresponding cycles
    may be checked for a relation.
  \item Numerous other small improvements.
 \end{itemize}
\item[3.0]  The following changes are committed:
  \begin{itemize}
  \item Functions [[sl2_clifford()]] and [[sl2_similarity()]]
    work for hypercomplex matrices as well.
  \item Cycle library is able to work both in vector and paravector
    formalisms.
  \item Add flag [[ignore_unit]] to [[cycle::is_equal()]].
  \item Add [[with_label]] parameter to [[figure::asy_write()]].
  \item Improved the example with modular group action.
  \item Numerous small improvements to code and documentations.
  \end{itemize}
\item[2.7]  The following changes are committed:
  \begin{itemize}
  \item Container ([lst]) assignments are using curly brackets
    now.
  \item Some fixes for upcoming \GiNaC\ 1.7.0.
  \end{itemize}
\item[2.6]  The following changes are committed:
  \begin{itemize}
  \item Installation instructions are updated and tested.
  \item \texttt{PyGiNaC} (refreshed) is added as a subproject.
  \end{itemize}
\item[2.5] The following changes are committed:
  \begin{itemize}
  \item Documentation is updated.
  \item 3D visualiser is added as a subproject.
  \item Minor fixes and adjustments.
  \end{itemize}
\item[2.4] The following minor changes are committed:
  \begin{itemize}
  \item Embedded PDF animation can be produced.
  \item Numerous improvements to documentation.
  \end{itemize}
\item[2.3] The following minor changes are committed:
  \begin{itemize}
  \item The stereometric example is done with the symbolic parameter.
  \item A concise mathematical introduction is written.
  \item Re-shape code of figure library.
  \item Use both symbolic and float checks to analyse newly evaluated cycles.
  \item Some minor code improvements.
  \end{itemize}
\item[2.2] The following minor changes are committed:
  \begin{itemize}
  \item New cycle relations [[moebius_transform]] and
    [[sl2_transform]] are added.
  \item Example programme with modular group action is added.
  \item Method [[add_cycle_rel]] may take a single relation now.
  \item Numerous internal fixes.
  \end{itemize}
\item[2.1] The following minor changes are committed:
  \begin{itemize}
  \item The method [[figure::get_all_keys()]] is added
  \item Debug output may be switched on/off from the code.
  \item Improvements to documentation.
  \item Initialisation of cycles in {\Python} wrapper are corrected.
  \end{itemize}
\item[2.0] The two-dimension restriction is removed from the [[figure]]
  library.  This breaks APIs, thus the major version number is increased.
\item[1.0] First official stable release with all essential functionality.
\end{description}
@ 
<<separating chunk>>=

@
\section{License}
\label{sec:license}
This programme is distributed under GNU GPLv3~\cite{GNUGPL}.
<<license>>=
// The library for ensembles of interrelated cycles in non-Euclidean geometry
//
//  Copyright (C) 2014-2018 Vladimir V. Kisil <kisilv@maths.leeds.ac.uk>
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.

@
\section{Index of Identifiers}
\label{sec:index-identifiers}
\small
\nowebindex

@
\fi
\end{document}
