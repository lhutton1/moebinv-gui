%	$Id: parab-ortho1.nw,v 1.73 2014/10/05 22:03:41 kisilv Exp $	

% -*- mode: Noweb; noweb-code-mode: c++-mode; tab-width: 4 -*--*-
\documentclass[twoside,a4paper]{amsart}
\PassOptionsToPackage{pdfauthor={Vladimir V. Kisil},%
  pdftitle={Schwerdtfeger--Fillmore--Springer--Cnops Construction Implemented in GiNaC},%
  pdfsubject={Library description},%
  backref=page,%
  pagebackref=true, %
  pdfkeywords={GiNaC, cycle, CAS},%
  breaklinks=true,%
  bookmarks=true,%
}{hyperref}
\usepackage{xr-hyper}
\externaldocument[E-]{parabolic1}
\usepackage[printedin,extnum]{myamsart}
\input{mydef}
\ppnum{LEEDS--MATH--PURE--2005--29\\
}{arXiv: \href{http://arXiv.org/abs/cs.MS/0512073}{cs.MS/0512073}}
{2005}
\usepackage{noweb}
%\usepackage{amsrefs}
\usepackage{graphicx}
\usepackage{marvosym}
%\noweboptions{longxref,subscriptidents}
%\input{a4m}
\textheight 26.5cm
\textwidth 18cm
\oddsidemargin -.9cm
\evensidemargin -.9cm
\topmargin -1.5cm
\renewcommand{\baselinestretch}{1}

\pagestyle{noweb}
\nwfilename{parab-ortho1.nw}
\makeatletter
\let\tab=&
\def\idxexample#1{\nwix@id@uses#1}
\makeatother
\newlabel{th-FSCc-intertwine}{{4.13}{45}{}{}{}}
\newlabel{ex-check-cycle-conj}{{6.22}{78}{}{}{}}
\newlabel{ex-cycle-prod-conj}{{6.24.i}{79}{}{}{}}
\newlabel{ex-check-conform-dist}{{7.14.i}{94}{}{}{}}
\newlabel{ex-check-conform-length}{{7.14.ii}{94}{}{}{}}
\def\nwbackslash{\texttt{\char92}}
\def\nwlbrace{\textbf{\texttt{\char123}}}
\def\nwrbrace{\textbf{\texttt{\char125}}}
\newcommand{\CPP}{\texttt{C++}}
\newcommand{\NoWEB}{\texttt{noweb}}
\providecommand{\MetaPost}{\texttt{Meta}\-\texttt{Post}}
%\providecommand{\NoWEB}{\texttt{NoWEB}}
\providecommand{\GiNaC}{\textsf{GiNaC}}
\providecommand{\pyGiNaC}{\textsf{pyGiNaC}}
\providecommand{\cycle}[3][]{{#1 C^{#2}_{#3}}}
\providecommand{\realline}[3][]{#1 R^{#2}_{#3}}
\providecommand{\Asymptote}{\texttt{Asymptote}}
%\providecommand{\url}[1]{\texttt{#1}}
\providecommand{\bs}{\breve{\sigma}}
\providecommand{\rs}{\mathring{\sigma}}
\newif\iftth
\let\myappendix=\appendix
\providecommand{\tr}{\mathop{tr}}
\providecommand{\vecbf}[1]{\mathbf{#1}}
\providecommand{\clifford}[2][]{\ifcase #1 #2\or \tilde{#2} \or \breve{#2} \fi}
\hypersetup{colorlinks=true,bookmarks=true}
\begin{document}
@ %keyword basic
@ %keyword ex
@ %keyword numeric
@ %keyword idx
@ %keyword varidx
@ %keyword matrix
@ %keyword symbol
@ %keyword realsymbol
@ %keyword relational
@ %keyword indexed
@ %keyword tensor
@ %keyword tensormetric
@ %keyword lst
@ %keyword clifford
@ %keyword cycle
@ %keyword cycle2D

\title[Schwerdtfeger--Fillmore--Springer--Cnops Construction Implemented in
\GiNaC]{Schwerdtfeger--Fillmore--Springer--Cnops Construction\\ Implemented in \GiNaC}

\author[Vladimir V. Kisil]%
{\href{http://www.maths.leeds.ac.uk/~kisilv/}{Vladimir V. Kisil}}
\thanks{On  leave from Odessa University.}

\address{%
%Institute of Mathematics\\
%Economics and Mechanics\\
%Odessa State University\\
%ul. Petra Velikogo, 2\\
%Odessa-57, 270057, UKRAINE
School of Mathematics\\
University of Leeds\\
Leeds LS2\,9JT\\
UK
}

\email{\href{mailto:kisilv@maths.leeds.ac.uk}{kisilv@maths.leeds.ac.uk}}

\urladdr{\href{http://www.maths.leeds.ac.uk/~kisilv/}%
{http://www.maths.leeds.ac.uk/\~{}kisilv/}}

\begin{abstract}
  This is an implementation of the Schwerdtfeger--Fillmore--Springer--Cnops
  construction (SFSCc) based on the Clifford algebra
  capacities~\cite{Kisil04c} of the \GiNaC\ computer algebra system.
  SFSCc linearises the linear-fraction action of the M\"obius group.
  This turns to be very useful in several theoretical and applied fields
  including engineering.  The package is realised as a C++ library and
  there are several Python wrapper of it, which can be used in
  interactive mode.

  The core of this realisation of SFSCc is done for an arbitrary
  dimension, while a subclass for two dimensional cycles add some
  2D-specific routines including a visualisation to PostScript files
  through the \MetaPost\ or \Asymptote\ software. Calculations can be
  done either in vector or paravector formalism.

  This library is a backbone of many results published
  in~\cite{Kisil05a}, which serve as illustrations of its usage. It can be
  ported (with various level of required changes) to other CAS with
  Clifford algebras capabilities.

  There is an ISO image of a Live Debian DVD attached to this paper
  at \texttt{arXiv} and the \href{https://docs.google.com/file/d/0BzfWNH9hAT3VMFl6Z3Z4aVJmcW8}{Google drive} (an updated version).

  The software is distributed under GNU GPLv3, see Appendix~\ref{sec:license}.
\end{abstract}
\dedicatory{Dedicated to the memory of Dennis Ritchie}
\subjclass[2010]{Primary 51B25; Secondary 51N25, 68U05, 11E88, 68W30.}
\date{\today\ (v2.3)}
\maketitle

\tableofcontents

\section{Introduction}
\label{sec:introduction}
The usage of computer algebra system (CAS) in Clifford Algebra
research has an established history with the famous ``Green
book''~\cite{DelSomSou92} already accompanied by a floppy disk with a
\texttt{REDUCE} package. This tradition is very much alive, see for
example the recent
books~\cites{GuerlebeckHabetaSproessig06,Kisil12a,Kisil11d}
accompanied by a software CD/DVD.  Numerous new packages are developed
by various research teams across the world to work with Clifford
algebras generally or address specific tasks, see on-line proceedings
of the recent IKM-2006 conference~\cite{IKM2006}.

Along this lines the present paper presents an implementation of the
Schwerdtfeger--Fill\-more--Springer--Cnops construction\footnote{In
  the case of circles this technique was already spectacularly
  developed by H.~Schwerdtfeger in 1960-ies, see
  \cite{Schwerdtfeger79a}. Unfortunately, that beautiful book was not
  known to the present author until he accomplished his own
  works~\cites{Kisil05a,Kisil05b,Kisil12a}.} (SFSCc) along with
illustrations of its usage.
SFSCc~\citelist{\cite{Schwerdtfeger79a}*{\S~1.1}
  \cite{Cnops02a}*{\S~4.1} \cite{Porteous95}*{\S~18}
  \cite{FillmoreSpringer90a} \cite{Kirillov06}*{\S~4.2}
  \cite{Kisil05a} \cite{Kisil12a}*{\S~4.2}} linearises the
linear-fraction action of the M\"obius group in \(\Space{R}{n}\).
This has clear advantages in several theoretical and applied fields
including engineering.  Our implementation is based on the Clifford
algebra capacities of the \GiNaC\ computer algebra
system~\cite{GiNaC}, which were described in~\cite{Kisil04c}. The code
is written using \NoWEB\
\href{http://en.wikipedia.org/wiki/Literate_programming}{literate
  programming} tool~\cite{NoWEB}

The core of this realisation of SFSCc is done for an arbitrary
dimension of \(\Space{R}{n}\) with a metric given by an arbitrary
bilinear form.   Corresponding calculation can be done using both vector
or paravector formalims in Clifford algebras, see
\S~\ref{sec:paravector-class}. Results of
calculations are largely independent from used formalism with some
notable exceptions: determinants of SFSC matrices and M\"obius maps
defined by those matrices, see Rems.~\ref{re:paravector-det-sign},
and~\ref{re:paravector-moebius-map}.
\begin{rem}
  \label{re:paravector-GiNaC-version}
  Paravector formalism shall not work with \GiNaC\ prior
  v.1.7.1. Earlier versions of \GiNaC\ will result in errors of this
  type:
\begin{verbatim}
 get_clifford_comp(): expression is not a Clifford vector to the given units
\end{verbatim}
\end{rem}

We also present a subclass for two dimensional cycles
(i.e. circles, parabolas and hyperbolas), which add some 2D specific
routines including a visualisation to PostScript files through the
\MetaPost~\cite{MetaPost} or \Asymptote~\cite{Asymptote} packages.
This software is the backbone of many results published
in~\cites{Kisil05a,Kisil12a,Kisil11d} and we use its application to~\cite{Kisil05a}
for the demonstration purpose.

There is a Python wrapper~\cite{pycycle} for this library. It
is based on \texttt{BoostPython} and \texttt{pyGiNaC} packages. The
wrapper allows to use all functions and methods from the library in
Python scripts or Python interactive shell. The drawing of object from
[[cycle2D]] may be instantly seen in the interactive mode through the
\Asymptote. The live DVD supplied with book~\cite{Kisil12a} is based
on the library presented in this paper and its Python wrapper.

This library is now a part of MoebInv project
(\url{http://moebinv.sourceforge.net/})~\cite{Kisil14b}. Please look
there for latest updates, source and binary distributions. ISO images of
live DVD may be referred there as well. We do not
plan to use arXiv for these purposes anymore.

The present package can be ported (with various level of required
changes) to other CAS with Clifford algebras capabilities similar to
\GiNaC.

The software is distributed under GNU GPLv3, see
Appendix~\ref{sec:license} and~\cite{GNUGPL}.

@

\section{User interface to classes cycle and cycle2D}
\label{sec:user-interf-class}
The [[cycle class]] describes loci of points \(\vecbf{x}\in\Space{R}{n}\) defined by a
quadratic equation
\begin{equation}
  \label{eq:quadric-def}
  k\vecbf{x}^2-2\scalar{\vecbf{l}}{\vecbf{x}}+m=0, \quad \textrm{
    where } k,m\in\Space{R}{}, \ \vecbf{l}\in\Space{R}{n}.
\end{equation}
The class [[cycle]] correspondingly has member variables [[k]], [[l]],
[[m]] to describe the equation~\eqref{eq:quadric-def} and the Clifford
algebra [[unit]] to describe the metric of surrounding space. The
plenty of methods are supplied for various tasks within SFSCc.

We also define a subclass [[cycle2D]] which has more methods specific
to two dimensional environment.


@
\subsection[Constructors of cycle]{Constructors of [[cycle]]}
\label{sec:constructors-cycle}

Here is various constructors for the [[cycle]]s. The first one takes
values of \(k\), \(\vecbf{l}\), \(m\) as well as [[metric]] supplied
directly. Note that \(\vecbf{l}\) is admitted either in form of a [[lst]], [[matrix]]
or [[indexed]] objects from \GiNaC. Similarly [[metric]] can be given
by an object from either [[tensor]], [[indexed]], [[matrix]] or [[clifford]] classes
exactly in the same way as metric is provided for a
[[clifford_unit()]] constructors~\cite{Kisil04c}.
<<cycle class constructors>>=
public:
cycle(const ex & k, const ex & l, const ex & m,
   const ex & metr = -(new tensdelta)->setflag(status_flags::dynallocated));
@ %def cycle k l m metr

@  Constructor for a [[cycle]]~\eqref{eq:quadric-def} with \(k=1\) and
given [[l]] defined by the condition that square of its ``radius''
(which is \(\det C\), see~\cite[Defn.~\ref{E-de:radius}]{Kisil05a}) is
[[r_squared]]. If a non-zero [[e]] is provided, then it is used to
calculate [[C.det(e)]], otherwise the default value is [[C.det(metr)]].
Note that for the default value of the [[metr]] the
value of [[l]] coincides with the centre of this [[cycle]].

<<cycle class constructors>>=
cycle(const lst & l,
   const ex & metr = -(new tensdelta)->setflag(status_flags::dynallocated),
   const ex & r_squared = 0, const ex & e = 0,
   const ex & sign = (new tensdelta)->setflag(status_flags::dynallocated));
@ %def cycle

@ If we want to have a cycle identical to to a given one [[C]]
up to a space metric which should be replaced by a new one [[metr]],
we can use the next constructor.
<<cycle class constructors>>=
cycle(const cycle & C, const ex & metr);
@ %def cycle

@ To any cycle SFSCc associates a matrix, which is of the
form~\eqref{eq:matrix-from-cycle}~\cite[~\eqref{E-eq:matrix-for-cycle}]{Kisil05a}.
The following constructor make a [[cycle]] from its matrix
representation, i.e. it is the realisation of the inverse of the map
\(Q\)~\cite[\eqref{E-eq:matrix-for-cycle}]{Kisil05a}.

The dimensionality of the point space may not be correctly guessed
from the matrix if both vector and paravector formalisms are allowed
(cf. \S~\ref{sec:paravector-class}), i.e. the absence of the
[[dirac_ONE]] may come either from the vector formalism or mean
[[l.oplus(0)==0]] in paravector formalim. Thus, the the correct
non-zero value of the dimensionality (the last parameter) shall be
supplied whenever possible.
<<cycle class constructors>>=
cycle(const matrix & M, const ex & metr, const ex & e = 0, const ex & sign = 0, const ex & dim = 0);
@ %def cycle

@
\subsection[Accessing parameters of a cycle]{Accessing parameters of a [[cycle]]}
\label{sec:access-param-cycle}

The following set of methods [[get_*()]] provide a reading access to
the various data in the class.
<<accessing the data of a cycle>>=
public:
 virtual inline ex get_dim() const { return ex_to<varidx>(l.op(1)).get_dim(); }
 virtual ex get_metric() const;
 virtual ex get_metric(const ex &i0, const ex &i1) const;
 virtual inline ex get_k() const { return k; }
@ %def get_dim get_metric get_k

@ The member [[l]] can be obtained as the whole by the call
[[get_l()]], or its individual component is read, for example, by [[get_l(1)]].
<<accessing the data of a cycle>>=
inline ex get_l() const { return l; }
inline ex get_l(const ex & i) const
{ return (l.is_zero()?0:l.subs(l.op(1) == i, subs_options::no_pattern)); }
inline ex get_m() const {return m;}
inline ex get_unit() const {return unit;}
@ %def get_l get_m get_unit

@ Methods [[nops()]], [[op()]], [[let_op()]], [[is_equal()]],
[[subs()]] are standard for expression in \GiNaC\ and described in the
\GiNaC\ tutorial.
The first three methods are rarely called by a user.
In many cases the method [[subs()]]
may replaced by more suitable [[subject_to()]]~\ref{sec:geom-meth-cycle}.

<<accessing the data of a cycle>>=
size_t nops() const {return 4;}
ex op(size_t i) const;
ex & let_op(size_t i);
bool is_equal(const basic & other, bool projectively = true, bool ignore_unit = false) const;
bool is_zero() const;
cycle subs(const ex & e, unsigned options = 0) const;
inline cycle normal() const
 { return cycle(k.normal(), l.normal(), m.normal(), unit.normal());}
inline cycle expand() const { return cycle(k.expand(), l.expand(), m.expand(), unit);}
@ %def nops op let_op is_equal is_zero subs normal expand

@ We also provide a method [[the_same_as()]] which return a [[GiNaC::lst]]
of identities (i.e. [[GiNaC::relational]]s), which defines that two
cycles are given by the same point of the projective space
\(\Space{P}{3}\).
<<accessing the data of a cycle>>=
ex the_same_as(const basic & other) const;

@
\subsection{Linear Operations on Cycles}
\label{sec:line-oper-cycl}
Cycles are represented by a points in a projective vector space, thus
we wish to have a full set of linear operation on them. The metric is
inherited from the first [[cycle]] object. First we define it as an
methods of the [[cycle]] class.
<<Linear operation as cycle methods>>=
virtual cycle add(const cycle & rh) const;
virtual cycle sub(const cycle & rh) const;
virtual cycle exmul(const ex & rh) const;
virtual cycle div(const ex & rh) const;
@ %def add sub exmul div

@ After that we overload standard binary operations for [[cycle]].
<<Linear operation on cycles>>=
const cycle operator+(const cycle & lh, const cycle & rh);
const cycle operator-(const cycle & lh, const cycle & rh);
const cycle operator*(const cycle & lh, const ex & rh);
const cycle operator*(const ex & lh, const cycle & rh);
const cycle operator/(const cycle & lh, const ex & rh);
@ %def operator+ operator- operator* operator/

@ We also define a product of two cycles through their matrix
representation~\eqref{eq:matrix-from-cycle}.
<<Linear operation on cycles>>=
const ex operator*(const cycle & lh, const cycle & rh);

@
\subsection[Geometric methods in cycle]{Geometric methods in [[cycle]]}
\label{sec:geom-meth-cycle}

We start from some general methods which deal with [[cycle]].
@ The next method is needed to get rid of the homogeneous ambiguity in the
projective space of cycles. If the cycle has non-zero determinant,
then it is scaled to have new determinant equal [[D]], with \(1\) as
the default value. The last parameter [[fix_paravector=true]] ensures
that the result of normalisation is independent from the used
formalism, see Rem.~\ref{re:paravector-det-sign}.
<<specific methods of the class cycle>>=
public:
cycle normalize_det(const ex & e = 0,
					const ex & sign = (new tensdelta)->setflag(status_flags::dynallocated),
					const ex & D = 1, bool fix_paravector = true) const;
@ %def normalize_det

@ The square \(\scalar{\cycle{}{}}{\cycle{}{}}\) of the norm of a cycle
\(\cycle{}{}\) is twice its determinant \(\det \cycle{}{}\), we provide a method to
normalise the norm as well.
<<specific methods of the class cycle>>=
inline cycle normalize_norm(const ex & e = 0,
					const ex & sign = (new tensdelta)->setflag(status_flags::dynallocated),
					const ex & N = 1, bool fix_paravector = true) const
{return normalize_det(e, sign, N*numeric(1,2), fix_paravector);}
@ %def normalize_norm

@ The next normalization acts as follows: if [[k_new=0]] the [[cycle]]
is normalised such that its \(\det\) becomes \(1\). Otherwise the
first non-zero coefficient among [[k]], [[m]], \(l_0\), \(l_1\),
\ldots\ is set to [[k_new]].
<<specific methods of the class cycle>>=
cycle normalize(const ex & k_new = numeric(1), const ex & e = 0) const;
@ %def normalize

@ The method [[center()]] returns a list of components of the cycle
centre or the corresponding vector ([[D]] matrix) if the dimension
is not symbolic. The metric, if not supplied is taken from the cycle.

<<specific methods of the class cycle>>=
virtual ex center(const ex & metr = 0, bool return_matrix = false) const;
@ %def center

@ The next method returns the value of the expression
\(-k\vecbf{y}^2-2\scalar{\vecbf{l}}{\vecbf{y}}x+m x^2\) for the given
cycle and point with homogeneous coordinates
\([\vecbf{y}:x]\). Obviously it should be \(0\) if \(\vecbf{x}\)
belongs to the cycle.
<<specific methods of the class cycle>>=
virtual ex val(const ex & y, const ex & x = 1) const;
@ %def val

@ Then method [[passing()]] returns a [[relational]] defined by the identity
\(k\vecbf{x}^2-2\scalar{\vecbf{l}}{\vecbf{x}}+m\equiv 0\), i.e  this
relational describes incidence of point to a cycle.

<<specific methods of the class cycle>>=
inline ex passing(const ex & y) const {return  val(y).numer().normal() == 0;}
@ %def passing

@ We oftenly need to consider a cycle which satisfies some additional
conditions, this can be done by the following method [[subject_to]]. Its
typical application looks like:
\begin{webcode}[[C2 = C.subject_to(lst{C.passing(P), C.is_orthogonal(C1}));]]\end{webcode}
The second parameters [[vars]] specifies which components of the
[[cycle]] are considered as unknown. Its default value represents all
of them which are symbols.
<<specific methods of the class cycle>>=
cycle subject_to(const ex & condition, const ex & vars = 0) const;
@ %def subject_to

@
\subsection{Methods representing SFSCc}
\label{sec:meth-repr-fscc}
There is a set of specific methods which represent mathematical side
of SFSCc.

@ The next method is the main gateway to the SFSCc, it generates the
\(2\times 2\) matrix
\begin{equation}
  \label{eq:matrix-from-cycle}
  \begin{pmatrix}
    \vecbf{l}_i \sigma^i_j\clifford[1]{e}^j & m\\
    k &  -\vecbf{l}_i  \sigma^i_j \clifford[1]{e}^j
  \end{pmatrix}
  \quad
  \textrm{ from the cycle }
  k\vecbf{x}^2-2\scalar{\vecbf{l}}{\vecbf{x}}+m=0.
  \quad
\end{equation}
Note, that the Clifford unit \(\clifford[1]{e}\) has an arbitrary
metric unrelated to the initial metric stored in the [[unit]] member
variable. If the last parameter set to [[true]] then in paravector
formalism a Clifford conjugation of the matrix will be return. The
parameter does not make any effect in the vector formalism. This is
required by several methods, e.g. [[cycle::cycle_similarity()]].

<<specific methods of the class cycle>>=
virtual matrix to_matrix(const ex & e = 0,
						 const ex & sign = (new tensdelta)->setflag(status_flags::dynallocated),
						 bool conjugate = false) const;
@ %def to_matrix

@ The next method returns the value of determinant of the
matrix~\eqref{eq:matrix-from-cycle} corresponding to the [[cycle]]. It has
explicit geometric meaning,
see~\cite[\S~\ref{E-sec:lengths-orth}]{Kisil05a}. Before calculation
the cycle is normalised by the condition [[k==k_norm]], if [[k_norm]]
is zero then no normalisation is done.
<<specific methods of the class cycle>>=
virtual ex det(const ex & e = 0,
  const ex & sign = (new tensdelta)->setflag(status_flags::dynallocated),
			   const ex & k_norm = 0, bool fix_paravector = false) const;
@ %def det

@
\begin{rem}
  \label{re:paravector-det-sign}
   It shall be noted, that the
   determinant has opposite signs in vector and paravector
   formalisms. This can be fixed by the last Boolean parameter
   [[fix_paravector]], which ensure that the sign will be the same as
   in vector formalism.
\end{rem}

@ The determinant of a k-normalised cycle can be treated as the square of its radius
<<specific methods of the class cycle>>=
virtual inline ex radius_sq(const ex & e = 0,
					const ex & sign = (new tensdelta)->setflag(status_flags::dynallocated)) const
{ return this->det(e, sign, numeric(1), true);}
@ %def radius_sq

@ The matrix~\eqref{eq:matrix-from-cycle} corresponding to a cycle may
be multiplied by another matrix, which in turn may be either generated
by another cycle or be of a different origin. The next methods
multiplies a cycle by another cycle or matrix supplied in [[C]].

<<specific methods of the class cycle>>=
virtual ex mul(const ex & C, const ex & e = 0,
     const ex & sign = (new tensdelta)->setflag(status_flags::dynallocated),
     const ex & sign1 =0) const;
@ %def mul

@ Having a matrix \(C\) which represents a cycle and another matrix
\(M\) we can consider a similar matrix \(M^{-1}CM\).  The later matrix
will correspond to a cycle as well, which may be obtained by the
following three methods.  In the case then \(M\) belongs to the
\(\SL\) group the next two methods make a proper conversion of \(M\)
into Clifford-valued form.
<<specific methods of the class cycle>>=
cycle sl2_similarity(const ex & a, const ex & b, const ex & c, const ex & d,
	const ex & e = 0,
	const ex & sign = (new tensdelta)->setflag(status_flags::dynallocated),
	bool not_inverse=true,
	const ex & sign_inv = (new tensdelta)->setflag(status_flags::dynallocated)) const;
cycle sl2_similarity(const ex & M, const ex & e = 0,
	const ex & sign = (new tensdelta)->setflag(status_flags::dynallocated),
	bool not_inverse=true,
	const ex & sign_inv = (new tensdelta)->setflag(status_flags::dynallocated)) const;
@ %def sl2_similarity

@ If \(M\) is a generic \(2\times 2\)-matrix of another sort then it is used in the
similarity in the unchanged form by the next method.
<<specific methods of the class cycle>>=
virtual cycle matrix_similarity(const ex & M, const ex & e = 0,
      const ex & sign = (new tensdelta)->setflag(status_flags::dynallocated),
	bool not_inverse=true,
      const ex & sign_inv = (new tensdelta)->setflag(status_flags::dynallocated)) const;
@ %def matrix_similarity

@ The \(2\times 2\)-matrix \(M=
\begin{pmatrix}
  a&b\\c&d
\end{pmatrix}\) can be also defined by the collection of its elements.
<<specific methods of the class cycle>>=
virtual cycle matrix_similarity(const ex & a, const ex & b, const ex & c, const ex & d,
      const ex & e = 0,
      const ex & sign = (new tensdelta)->setflag(status_flags::dynallocated),
      bool not_inverse=true,
      const ex & sign_inv = (new tensdelta)->setflag(status_flags::dynallocated)) const;

@ Finally, we have a method for reflection of a cycle in another cycle
[[C]], which is given by the similarity of the representing matrices:
\(C C_1 C\), see~\cite[\S~\ref{E-sec:invers-in-cycl}]{Kisil05a}.
<<specific methods of the class cycle>>=
virtual cycle cycle_similarity(const cycle & C, const ex & e = 0,
        const ex & sign = (new tensdelta)->setflag(status_flags::dynallocated),
        const ex & sign1 = 0,
      const ex & sign_inv = (new tensdelta)->setflag(status_flags::dynallocated)) const;
@ %def cycle_similarity

@ A cycle in the matrix form~\eqref{eq:matrix-from-cycle} naturally
defines a M\"obius transformations of the points:
\begin{equation}
  \label{eq:moebius-from-cycle}
  \begin{pmatrix}
    \vecbf{l}_i \sigma^i_j\clifford[1]{e}^j & m\\
    k &  -\vecbf{l}_i  \sigma^i_j \clifford[1]{e}^j
  \end{pmatrix} : \vecbf{x} \mapsto
    \frac{\vecbf{l}_i \sigma^i_j\clifford[1]{e}^j \vecbf{x} + m}
    {k \vecbf{x} -\vecbf{l}_i  \sigma^i_j \clifford[1]{e}^j}
\end{equation}
The following methods realised this transformations.

<<specific methods of the class cycle>>=
virtual ex moebius_map(const ex & P, const ex & e = 0,
					   const ex & sign = (new tensdelta)->setflag(status_flags::dynallocated)) const;
@ %def moebius_map

@
\begin{rem}
  \label{re:paravector-moebius-map}
  The result depends on either vector or paravector formalism is
  used. In two dimensions, the second component received the opposed
  sign in paravector formalism: for example, [[lst{u,v}]] and [[lst{u,-v}]].
\end{rem}

@ For two matrices \(C_1\) and \(C_2\) obtained from cycles the expression
\begin{equation}
  \label{eq:cycle-inner-product}
   \scalar{C_1}{C_2}=-\Re\tr{(C_1C_2)}
\end{equation}
naturally defines an inner product in the space of cycles. The follwong methods realised it.
<<specific methods of the class cycle>>=
virtual ex cycle_product(const cycle & C, const ex & e = 0,
						 const ex & sign = (new tensdelta)->setflag(status_flags::dynallocated)) const;
@ %def cycle_product

@ The inner product~\eqref{eq:cycle-inner-product} defines an
orthogonality relation \(\scalar{C_1}{C_2}\equiv 0\) in the space of
cycles which returned by the method [[is_orthogonal()]].
<<specific methods of the class cycle>>=
virtual inline ex is_orthogonal(const cycle & C, const ex & e = 0,
   const ex & sign = (new tensdelta)->setflag(status_flags::dynallocated)) const
    {return (cycle_product(C, e, sign) == 0);}
@ %def is_orthogonal

@ In many cases we need a higher order orthogonal relation between
cycles--- so called f-orthogonality, see
\cite[\S~\ref{E-sec:focal-orthogonality}]{Kisil05a}, which is given by
the relation:
\begin{displaymath}
      \Re\tr(\cycle{s}{\bs} \cycle[\tilde]{s}{\bs}\cycle{s}{\bs}\realline{s}{\bs})=0.
\end{displaymath}
<<specific methods of the class cycle>>=
ex is_f_orthogonal(const cycle & C, const ex & e = 0,
				   const ex & sign = (new tensdelta)->setflag(status_flags::dynallocated),
				   const ex & sign1 = 0,
				   const ex & sign_inv = (new tensdelta)->setflag(status_flags::dynallocated)) const;
@ %def is_f_orthogonal

@ The remaining to methods check if a cycle is a liner object and if
it is normalised to \(k=1\).
<<specific methods of the class cycle>>=
 inline ex is_linear() const {return (k == 0);}
 inline ex is_normalized() const {return (k == 1);}
@ %def is_linear is_normalized

@
\subsection{Two dimensional cycles}
\label{sec:two-dimens-cycl}
Two dimensional cycle [[cycle2D]] is a derived class of [[cycle]]. We
need to add only very few specific methods for two dimensions, notably
for the visualisation.

@ This a specialisation of the constructors from [[cycle]] class to
[[cycle2D]]. Here is the main constructor.

<<constructors of the class cycle2D>>=
public:
	cycle2D(const ex & k1, const ex & l1, const ex & m1,
			const ex & metr = -unit_matrix(2));
@ %def cycle2D

@ Constructor for the [[cycle2D]] from [[l]] and square of its radius.

<<constructors of the class cycle2D>>=
cycle2D(const lst & l, const ex & metr = -unit_matrix(2), const ex & r_squared =0,
  const ex & e =0, const ex & sign = unit_matrix(2));

@ Construction of [[cycle2D]] from its SFSCc matrix, dimensionality is
not supplied because its is known to be \(2\).
<<constructors of the class cycle2D>>=
cycle2D(const matrix & M, const ex & metr, const ex & e = 0, const ex & sign = 0);

@ Make a two dimensional cycle out of a general one, if the
dimensionality of the space permits. The metric of point space can
be replaced as well if a valid [[metr]] is supplied.
<<constructors of the class cycle2D>>=
cycle2D(const cycle & C, const ex & metr = 0);

@ The realisation of 2D cycles through matrices with hypercomplex
numbers~\cites{Kisil06a,Kisil12a,Kisil11d} lead to some important differences
with this library using the Clifford algebras. One of them: the
determinant of a matrix change sign. The next method return the
determinant as it will be calculated on those hypercomplex matrices.
<<methods specific for class cycle2D>>=
public:
virtual inline ex hdet(const ex & e = 0,
  const ex & sign = (new tensdelta)->setflag(status_flags::dynallocated),
  const ex & k_norm = 0) const
{return -det(e, sign, k_norm, true);}
@ %def hdet

@ The method [[focus()]] returns list of the focus coordinates and the
focal length is provided by [[focal_length()]].
This turns to be meaningful not only for parabolas, see~\cite{Kisil05a}.

<<methods specific for class cycle2D>>=
ex focus(const ex & e = diag_matrix(lst{-1, 1}), bool return_matrix = false) const;
inline ex focal_length() const {return (get_l(1)/2/k);} // focal length of the cycle
@ %def focus focal_length

@ The methods [[roots()]] returns values of \(u\) (if [[first = true]])
such that \(k(u^2-\sigma y^2)-2l_1u-2l_2y+m=0\),
i.e. solves a quadratic equations. If [[first = false]] then values
of \(v\) satisfying to \(k(y^2-\sigma v^2)-2l_1y-2l_2v+m=0\)
are returned.
<<methods specific for class cycle2D>>=
 lst roots(const ex & y = 0, bool first = true) const;
@ %def roots

@ The next methods is a generalisation of the previous one: it returns intersection
points with the line \(ax+b\).
<<methods specific for class cycle2D>>=
 lst line_intersect(const ex & a, const ex & b) const;
@ %def line_intersect

@ The method [[metapost_draw()]] outputs to the stream [[ost]] \MetaPost\ comands
to draw parts of two the [[cycle2D]] within the rectangle with the
lower left vertex ([[xmin]], [[ymin]]) and upper right  ([[xmax]],
[[ymax]]). The colour of drawing is specified by [[color]] (the
default is black) and any additional \MetaPost\ options can be provided
in the string [[more_options]]. By default each set of the drawing
commands is preceded a comment line giving description of the cycle,
this can be suppressed by setting [[with_header = false]]. The default
number of points per arc is reasonable in most cases, however user can
override this with supplying a value to [[points_per_arc]]. The last
parameter is for internal use. If you do not want imaginary cycles to
be shown use the value [["invisible"]] for [[imaginary_options]].
<<methods specific for class cycle2D>>=
 void metapost_draw(ostream & ost, const ex & xmin = -5, const ex & xmax = 5,
					const ex & ymin = -5, const ex & ymax = 5, const lst & color = lst{},
					const string more_options = "",
					bool with_header = true, int points_per_arc = 0, bool asymptote = false,
					const string picture = "", bool only_path=false, bool is_continuation=false,
					const string imaginary_options="withcolor .9*green withpen pencircle scaled 4pt") const;
@ %def metapost_draw

@ Besides inherited [[cycle::sl2_similarity()]] (see
\S~\ref{sec:derived-class-two}), there are further methods for two
dimensional cycles to make similarity with complex, dual and double
numbers. Real and imaginary parts need to be supplied as two separate
matrices. In the first method only two matrices [[M1]] and [[M2]] are
mandatory, if the rest is not supplied, the method
[[sl2_similarity(const ex \& M, const ex \& e,...)]] will correctly
handle this situation.
<<methods specific for class cycle2D>>=
cycle2D sl2_similarity(const ex & M1, const ex & M2, const ex & e,
	const ex & sign,
	bool not_inverse=true,
	const ex & sign_inv = (new tensdelta)->setflag(status_flags::dynallocated)) const;
cycle2D sl2_similarity(const ex & a1, const ex & b1, const ex & c1, const ex & d1,
	const ex & a2, const ex & b2, const ex & c2, const ex & d2,
	const ex & e = 0,
	const ex & sign = (new tensdelta)->setflag(status_flags::dynallocated),
	bool not_inverse=true,
	const ex & sign_inv = (new tensdelta)->setflag(status_flags::dynallocated)) const;
@ %def sl2_similarity


@  The similar method provides a drawing output for
\Asymptote~\cite{Asymptote} with the same meaning of
parameters. However, format of [[more_options]] and
[[imaginary_options]] should be adjusted
correspondingly. Currently [[asy_draw()]] is realised as a
wrapper around  [[metapost_draw()]] but this may be changed.

<<methods specific for class cycle2D>>=
inline void asy_draw(ostream & ost, const string picture,
					 const ex & xmin = -5, const ex & xmax = 5,
					 const ex & ymin = -5, const ex & ymax = 5, const lst & color = lst{},
					 const string more_options = "", bool with_header = true,
					 int points_per_arc = 0, const string imaginary_options="rgb(0,.9,0)+4pt") const
{metapost_draw(ost, xmin, xmax, ymin, ymax, color, more_options, with_header,
				points_per_arc, true, picture, false, false, imaginary_options); }

inline void asy_draw(ostream & ost = std::cout,
					 const ex & xmin = -5, const ex & xmax = 5,
					 const ex & ymin = -5, const ex & ymax = 5, const lst & color = lst{},
					 const string more_options = "",
					 bool with_header = true, int points_per_arc = 0,
					 const string imaginary_options="rgb(0,.9,0)+4pt") const
{metapost_draw(ost, xmin, xmax, ymin, ymax, color, more_options, with_header,
				points_per_arc, true, "", false, false, imaginary_options); }
@ %def asy_draw

@ Finally, we have a similar method which does not issue drawing
command, instead it writes a definition for a (array of) path, which
may be manipulated later.
<<methods specific for class cycle2D>>=
inline void asy_path(ostream & ost = std::cout,
					 const ex & xmin = -5, const ex & xmax = 5,
					 const ex & ymin = -5, const ex & ymax = 5,
					 int points_per_arc = 0, bool is_continuation = false) const
{metapost_draw(ost, xmin, xmax, ymin, ymax, lst{}, "", false,
				points_per_arc, true, "", true, is_continuation); }
@ %def asy_path

@
\subsection[An Example: Moebius Invariance of cycles]{An Example: M\"obius Invariance of cycles}
\label{sec:mobi-invar-cycl}

A quick illustration of the library usage is the symbolic calculation
which proves the Lem.~\ref{E-pr:transform-cycles}
from~\cite{Kisil05b}: We check that a M\"obius transformation
\(g\in\SL\) acts on cycles by similarity \(g: C \rightarrow
gCg^{-1}\). We use the following predefined objects:
\begin{webcode}
  cycle2D C(k,lst{l,n},m,e);
  ex W=lst{u,v};
\end{webcode}

Firstly we define a [[cycle2D]] [[C2]] by the condition
between [[k]], [[l]] and [[m]] in the generic [[cycle2D]] [[C]] that
[[C]] passes through some point [[W]].

<<Moebius transformation of cycles>>=
	C2 = Cv.subject_to(lst{Cv.passing(W)});

@ The point [[gW]] is defined to be the M\"obius transform of
[[W]] by  an arbitrary \(g\).
<<Moebius transforms of W>>=
const matrix gW=ex_to<matrix>(clifford_moebius_map(sl2_clifford(a, b, c, d, ev), W, ev).subs(sl2_relation1,
  subs_options::algebraic | subs_options::no_pattern).normal());

@ Finally we verify that the new cycle \(gCg^{-1}\) passes through [[P]]. This
proves Lem.~\ref{E-pr:transform-cycles} from~\cite{Kisil05a}.
<<Moebius transformation of cycles>>=
cout << "Conjugation of a cycle comes through Moebius transformation for vectors: "
	 << C2.sl2_similarity(a, b, c, d, evs, S2, true, S2).val(gW).subs(sl2_relation1,
                subs_options::algebraic | subs_options::no_pattern).normal().is_zero()
 << endl << endl;

@
%\ifx\jobname{parab-ortho1}

@
\section{Demonstration through example}
\label{sec:main-procedure}
We illustrate the library usage by the complete program which was used
for computer-assisted proofs in the paper~\cite{Kisil05a}. The
numerous cross-references between these two papers are active
hyperlinks. It is recommended to obtain PDF files for both of them
from \url{http://arXiv.org} and put into the same local directory. In
this case clicking on a reference in a PDF reader will automatically
transfer to the appropriate place (even in the other paper).

\subsection[Outline of the main()]{Outline of the [[main()]]}
\label{sec:outline-main}

The [[main()]] procedure does several things:
\begin{enumerate}
\item Makes symbolic calculations related to M\"obius invariance;
<<List of symbolic calculations>>=
  <<Moebius transformation of cycles>>
  <<K-orbit invariance>>
  <<Check Moebius transformations of zero cycles>>
  <<Check transformations of zero cycles by conjugation>>
cout << endl;

@
\item Calculates properties of orthogonality conditions and
  corresponding inversion in cycles;
<<List of symbolic calculations>>=
  <<Orthogonality conditions>>
  <<Two points and orthogonality>>
  <<One point and orthogonality>>
  <<Orthogonal line>>
  <<Inversion in cycle>>
  <<Reflection in cycle>>
  <<Yaglom inversion>>
cout << endl;

@
\item Calculates properties of f-orthogonality conditions and second
  type of inversion;
<<List of symbolic calculations>>=
  <<Focal orthogonality conditions>>
  <<One point and f-orthogonality>>
  <<f-orthogonal line>>
  <<f-inversion in cycle>>
cout << endl;

@
\item Calculates various length formulae;
<<List of symbolic calculations>>=
  <<Distances from cycles>>
  <<Lengths from centre>>
  <<Lengths from focus>>
  <<Infinitesimal cycle>>
cout << endl;

@
\item Generates \Asymptote\ output of the for illustrations.

@
\end{enumerate}
Since we aiming into two targets simultaneously---validate our
software and use it for mathematical proofs---there are many double
checks and superfluous calculations. In particular, all checks are
done twice: for vector and paravector formalism (see also
Rem.~\ref{re:paravector-GiNaC-version} for required \GiNaC\
version). The positive aspect of this---a better illustration of the
library usage.

@
\subsubsection{The program outline}
\label{sec:programs-outline}

Here is the main entry into the program and its outline. We start from
some inclusions, note that \GiNaC\ is included through [[<cycle.h>]].
<<*>>=
<<license>>
#include <fstream>
#include <cycle.h>

#define par_matr diag_matrix(lst{-1, 0})
#define hyp_matr diag_matrix(lst{-1, 1})
using namespace MoebInv;
using namespace std;
using namespace GiNaC;

@ We try to make the output more readable both in simple text
and \LaTeX\ modes.
<<*>>=
#define math_string << (output_latex?"$":"")
//$ (this is to balance dollar signs for LaTeX highlights in Xemacs)
#define wspaces (output_latex?"\\quad ":"  ")

@ The structure of the program is transparent. We declare all variables.
<<*>>=
<<Declaration of variables>>
<<Subroutines definitions>>
int main(){
 cout << boolalpha;

 if (output_latex) cout << latex;

@ If paravector calculations are not possible the corresponding
warning is printed.
<<*>>=
#if GINAC_VERSION_ATLEAST(1,7,1)
#else
cerr << "GiNaC version is not sufficiently large to handle paravector calculations." << endl
	<< "All false results for paravectors shall be ignored!" << endl;
#endif

@ Then we make all symbolic calculations listed above. The exception
catcher helps to identify the possible problems.
<<*>>=
	try {
		<<List of symbolic calculations>>
		} catch (exception &p) {
		cerr << "*****       Got a problem with symbolic calculations: " <<  p.what() << endl;
	}

@ We end up with drawing illustration to our paper~\cite{Kisil05a}.
<<*>>=
	<<Draw Asymptote pictures>>
}

@
\subsubsection{Declaration of variables}
\label{sec:decl-vari}

First we declare all variables from the standard \GiNaC\ classes here.
<<Declaration of variables>>=
const string eph_names="eph";
const numeric half(1,2);

const realsymbol a("a"), b("b"), c("c"), d("d"), x("x"), y("y"), z("z"), t("t"),
  k("k"), l("L","l"), m("m"), n("n"), // Cycles parameters
  k1("k1","\\tilde{k}"), l1("l1","\\tilde{l}"), m1("m1","\\tilde{m}"), n1("n1","\\tilde{n}"),
  u("u"), v("v"), u1("u1"), v1("v1"), // Coordinates of points in \(\Space{R}{2}\)
  epsilon("eps", "\\epsilon"); // The "infinitesimal" number

const varidx nu2(symbol("nu", "\\nu"), 2), mu2(symbol("mu", "\\mu"), 2);

@ We need a plenty of symbols which will hold various parameters like
\(e_1^2\),  \(\breve{e}_1^2\), \(s\) for the SFSCc.
<<Declaration of variables>>=
const realsymbol sign("si", "\\sigma"), sign1("si1", "\\breve{\\sigma}"), //Signs of \(e_1^2\) of  \(\breve{e}_1^2\)
												 sign2("si2", "\\sigma_2"), sign3("si3", "\\sigma_3"),
												 sign4("si4", "\\mathring{\\sigma}"),
												 s("s"), s1("s1", "s_1"), s2("s2", "s_2");
int si, si1; // Values of \(e_1^2\) and \(\breve{e}_1^2\) for substitutions

 const matrix S2(2, 2, lst{1, 0, 0, jump_fnct(sign2)}),
	 S3(2, 2, lst{1, 0, 0, jump_fnct(sign3)}),
	 S4(2, 2, lst{1, 0, 0, jump_fnct(sign4)}); //Signs of [[l]] in the matrix representations of cycles

@ Here are several expressions which will keep results of calculations.
<<Declaration of variables>>=
ex u2, v2, // Coordinates of the Moebius transform of [[(u, v)]]
            u3, v3, u4, v4, u5, v5,
            P, P1, // points on the plain
            K, L0, L1, // Parameters of cycles
            Len_c, // Expressions of Lengths
            p;

@  Next we define metrics (through Clifford units) for the space of
points ([[M]], [[e]]) and space of spheres ([[M1]], [[es]]) in vector formalism.
<<Declaration of variables>>=
const ex M = diag_matrix(lst{-1, sign}), // Metrics of point spaces
	ev =  clifford_unit(mu2, M, 0), // Clifford algebra generators in the point space
	M1 = diag_matrix(lst{-1, sign1}), // Metrics of cycles spaces
	evs =  clifford_unit(nu2, M1, 1),  // Clifford algebra generators in the sphere space
	evh =  clifford_unit(nu2, S2, 1),  // Clifford algebra generators with Heviside function
	ev4 = clifford_unit(nu2, diag_matrix(lst{-1, sign4}), 2);

@ Here we define clifford units for paravector formalism.
<<Declaration of variables>>=
#if GINAC_VERSION_ATLEAST(1,7,1)
const varidx nu1(symbol("nu", "\\nu"), 1), mu1(symbol("mu", "\\mu"), 1);
const ex ep =  clifford_unit(mu1, diag_matrix(lst{sign}), 0), // Clifford algebra generators in the point space
	eps =  clifford_unit(nu1, diag_matrix(lst{sign1}), 1),  // Clifford algebra generators in the sphere space
	eph =  clifford_unit(nu1, diag_matrix(lst{jump_fnct(sign2)}), 1),  // Clifford algebra generators in the sphere space
	ep4 = clifford_unit(nu1, diag_matrix(lst{sign4}), 2);

@  If \GiNaC\ version is not sufficient to run paravector formalism,
we simply copy values for vector formalism.
<<Declaration of variables>>=
#else
const varidx nu1=nu2, mu1=mu2;
const ex ep =  ev,
	eps =  evs,
	eph =  evh,
	ep4 = ev4;
#endif

@ Now we define instances of [[cycle2D]] class. Some of them (like
[[real_line]] or generic cycles [[C]] and [[C1]]) are constants. First
they are done for vector formalism.
<<Declaration of variables>>=
cycle2D C2, C3, C4, C5, C6, C7, C8, C9, C10, C11;

const cycle2D real_linev(0, lst{0, numeric(1)}, 0, ev), // the real line
            Cv(k, lst{l, n}, m, ev), Cv1(k1, lst{l1, n1}, m1, ev); // two generic cycles
const cycle2D Zvinf(0, lst{0, 0}, 1, ev), // the zero-radius cycle at infinity
            Zv(lst{u, v}, ev), Zv1(lst{u, v}, ev, 0, evs), // two generic cycles of zero-radius
            Zv2(lst{u, v}, ev, 0, evs, S2);

@ And now---for paravector formalism.
<<Declaration of variables>>=
const cycle2D real_linep(0, lst{0, numeric(1)}, 0, ep), // the real line
            Cp(k, lst{l, n}, m, ep), Cp1(k1, lst{l1, n1}, m1, ep); // two generic cycles
const cycle2D Zpinf(0, lst{0, 0}, 1, ep), // the zero-radius cycle at infinity
            Zp(lst{u, v}, ep), Zp1(lst{u, v}, ep, 0, eps), // two generic cycles of zero-radius
            Zp2(lst{u, v}, ep, 0, eps, S2);

@ For solution of various systems of linear equations we need the
followings [[lst]]s.
<<Declaration of variables>>=
lst eqns, eqns1,
	vars=lst{k1, l1, m1, n1},
	solns, solns1, // Solutions of linear systems
		sign_val;

@ Here are [[relational]]s and lists of [[relational]]s which will be
used for automatic simplifications in calculations.
They are based on properties of \(\SL\) and values of the parameters.
<<Declaration of variables>>=
const ex sl2_relation = (c*b == a*d-1), sl2_relation1 = (a == (1+b*c)/d); // since \(ad-bc\equiv 1\)
 const lst signs_cube = lst{pow(sign, 3) == sign, pow(sign1, 3) == sign1}; // \(s_{i}^3\equiv s_{i}\) since \(s_{i}=-1, 0, 1\)

const int debug = 0;
const bool output_latex = true;

@ Two generic points on the plain are defined as constant vectors
(\(2\times 1\)matrices).
<<Declaration of variables>>=
const matrix W(2,1, lst{u, v}), W1(2,1, lst{u1, v1}),
	Wbar(2,1, lst{u, -v}); // Needed for paravector formalism

@ We will also frequently use their M\"obius transforms.
<<Declaration of variables>>=
const matrix gW1=ex_to<matrix>(clifford_moebius_map(sl2_clifford(a, b, c, d, ev), W1, ev).subs(sl2_relation1,
   subs_options::algebraic | subs_options::no_pattern).normal());
<<Moebius transforms of W>>

@ We make rhe same check as in \S~\ref{sec:mobi-invar-cycl} now for paravectors.
<<Moebius transformation of cycles>>=
	  C2 = Cp.subject_to(lst{Cp.passing(W)});
	  cout << "Conjugation of a cycle comes through Moebius transformation for paravectors: "
		   << C2.sl2_similarity(a, b, c, d, eps, S2, true, S2).val(gW).subs(sl2_relation1,
																			subs_options::algebraic | subs_options::no_pattern).normal().is_zero()
		   << endl << endl;

@  We repeat some calculations several times for various values of
parameters, such calculations are gathered here as subroutines.
<<Subroutines definitions>>=
	<<Parabolic Cayley transform of cycles>>
	<<Check conformal property>>
	<<Print perpendicular>>
	<<Focal length checks>>
	<<Infinitesimal cycle calculations>>

@
\subsection[Moebius Transformation and Conjugation of Cycles]{M\"obius
  Transformation and Conjugation of Cycles}
\label{sec:symb-calc}

@
\subsubsection[Transformations of K-orbits]{Transformations of \(K\)-orbits}
\label{sec:transf-k-orbits}
As a simple check we verify that cycles given by the equation
\((u^2-\sigma v^2)-2v\frac{t^{-1}-\sigma t }{2}+1=0\),
see~\cite[Lem.~\ref{E-le:k-orbit-gen}]{Kisil05a} are \(K\)-invariant,
i.e. are \(K\)-orbits. To this end we make a similarity of a cycle
[[C2]] of this from with a matrix from \(K\) and check that the result
coincides with [[C2]]. First for vector form.
<<K-orbit invariance>>=
auto K_inv = [](string S, const ex & e) {
cycle2D C2 = cycle2D(1, lst{0, (pow(t,-1)-sign*t)/2}, 1, e);
cout << "A K-orbit is preserved " << S << C2.sl2_similarity(cos(x), sin(x), -sin(x), cos(x), e).is_equal(C2)

@ We also check that [[C2]] passing the point \((0, t)\).
<<K-orbit invariance>>=
<< ", and  passing (0, t): " << (bool)ex_to<relational>(C2.passing(lst{0, t})) << endl; };

@ Now we do the check both for vectors and paravectors.
<<K-orbit invariance>>=
	  K_inv("for vectors: ", ev);
	  K_inv("for paravectors: ", ep);

@
\subsubsection{Transformation of Zero-Radius Cycles}
\label{sec:transf-zero-radi}

Firstly, we check some basic information about the zero-radius
cycles. This mainly done to verify our library.
<<Check Moebius transformations of zero cycles>>=
cout << wspaces << "Determinant of zero-radius Z1 cycle in metric e is for vector: "
	math_string << canonicalize_clifford(Zv1.det(ev, S2)) math_string << endl;
 cout << wspaces << "The opposite value for paravector: "
	  << canonicalize_clifford(Zv1.det(ev, S2)+Zp1.det(ep, S2)).normal().is_zero()  << endl;

<<Check Moebius transformations of zero cycles>>=
cout << wspaces << "Focus of zero-radius cycle is (vector): " math_string
	 << Zv1.focus(ev) math_string << endl;
cout << wspaces << "The same value for paravector: "
	 << (Zv1.focus(ev,true)-Zp1.focus(ep,true)).evalm().is_zero()  << endl;
cout << wspaces << "Centre of zero-radius cycle is (vector): " math_string
	 << Zv1.center(ev) math_string << endl;
cout << wspaces << "The same value for paravector: "
	 << (Zv1.center(ev,true)-Zp1.center(ep,true)).evalm().is_zero()  << endl;
cout  << wspaces << "Focal length of zero-radius cycle is (vector): " math_string
	  << Zv1.focal_length() math_string << endl;
cout << wspaces << "The same value for paravector: "
	 << (Zv1.center(ev,true)-Zp1.center(ep,true)).evalm().is_zero()  << endl;

@ This chunk checks that M\"obius transformation of a zero-radius
cycle is a zero-radius cycle with centre obtained from the first one
by the same M\"obius transformation.
<<Check Moebius transformations of zero cycles>>=
auto Z_rad_tr=[](const cycle2D & Z1, const ex & e, const ex & es)
	{return canonicalize_clifford(Z1.sl2_similarity(a, b, c, d, e, S2).det(es, S2)).subs(sl2_relation1,
																						 subs_options::algebraic | subs_options::no_pattern); };

cout << "Image of the zero-radius cycle under Moebius transform has zero radius vector: "
	 << Z_rad_tr(Zv1,ev,evs).is_zero()
	 << " and paravector: " << Z_rad_tr(Zp1,ep,eps).is_zero() << endl;

@ We calculate the M\"obius transformation of the centre of [[Z]]
<<Check Moebius transformations of zero cycles>>=
u2 = gW.op(0);
v2 = gW.op(1);

@ Here we find parameters of the transformed zero-radius cycle \(C_2=gZg^{-1}\).
<<Check Moebius transformations of zero cycles>>=
auto Z_center=[](string S, const cycle2D & Z, const ex & e) {
	C2 = Z.sl2_similarity(a, b, c, d, e);
	K = C2.get_k();
	L0 = C2.get_l(0);
	L1 = C2.get_l(1).normal();

@  And we finally check that [[gW]] coincides with the centre of the transformed cycle
[[C2]]. This proves~\cite[Lem.~\ref{E-le:moeb-conj-z-cycle}]{Kisil05a}.
<<Check Moebius transformations of zero cycles>>=
cout <<"The centre of the Moebius transformed zero-radius cycle for " << S
 << equality((u2*K-L0).subs(sl2_relation, subs_options::algebraic | subs_options::no_pattern)) << ", "
 << equality((v2*K-L1).subs(sl2_relation, subs_options::algebraic | subs_options::no_pattern))
	<< endl; };

@ Now its called for vectors and paravectors.
<<Check Moebius transformations of zero cycles>>=
 Z_center("vector: ", Zv, ev);
 Z_center("paravector: ", Zp, ep);

@
\subsubsection{Cycles conjugation}
\label{sec:cycles-conjugation}
This chunk checks that transformation of a zero-radius cycle by
conjugation with a cycle is a zero-radius cycle with centre
obtained from the first one by the same transformation.

Firstly we calculate parameters of \(C_2=CZC\) .
<<Check transformations of zero cycles by conjugation>>=
auto Z_conjugated=[](const cycle2D & Z, const cycle2D & C, const ex & e) {
	<<Check either vector formalism is used>>

@ On a number of occasions we will need to check either vector or
paravector formalism is used.
<<Check either vector formalism is used>>=
	bool is_vector = (ex_to<idx>(e.op(1)).get_dim() == 2);

@ The rest of the check for cycle conjuagation.
<<Check transformations of zero cycles by conjugation>>=
	matrix S1=ex_to<matrix>(diag_matrix(lst{1, s1})),  S2=ex_to<matrix>(diag_matrix(lst{1, s2}));
	lst square_sub=lst{pow(s1,2)==1, pow(s2,2)==1};
	cycle2D Zn = Z.cycle_similarity(C, e, S1, S2, pow(S1,-1).evalm());
	cout << "Image of the zero-radius cycle under cycle similarity has zero radius for "
	<< (is_vector? "" : "para") << "vector: " << canonicalize_clifford(Zn.det(e, S1)).subs(square_sub,
																						   subs_options::algebraic | subs_options::no_pattern).normal().is_zero()
	<< endl;

@ Then we check that it coincides with transformation point [[P]]
which is calculated in agreement with above used matrices [[S2]] and
[[S3]]. This proves the result~\cite[Lem.~\ref{E-le:cycle-conj-is-moeb}]{Kisil05a}
<<Check transformations of zero cycles by conjugation>>=
lst Pc=ex_to<lst>(Zn.center(diag_matrix(lst{-1,-s2*s1})));
if (is_vector)
	P=C.moebius_map(Z.center(diag_matrix(lst{-1,-s2/s1})));
else
	P=C.moebius_map(Z.center(diag_matrix(lst{-1,s2/s1})));

cout <<"The centre of the conjugated zero-radius cycle coinsides with Moebius trans for "
	<< (is_vector? "" : "para") << "vector: " <<  equality((P.op(0)-Pc.op(0)).normal().subs(square_sub,
																							subs_options::algebraic))
	<< ", " << equality((P.op(1)-Pc.op(1)).normal().subs(square_sub,subs_options::algebraic))
	<< endl; };

@ Finally checks are called in vector and paravector cases.
<<Check transformations of zero cycles by conjugation>>=
Z_conjugated(Zv, Cv, ev);
Z_conjugated(Zp, Cp, ep);

@
\subsection{Orthogonality of Cycles}
\label{sec:orthogonality-cycles}

\subsubsection{Various orthogonality conditions}
\label{sec:vari-orth-cond}

We calculate orthogonality condition between two
[[cycle2D]]s by the identity \(\Re \tr(C_1C_2)=0\). The expression
are stored in variables, which will be used later in our calculations.

@ Here is the orthogonality of two generic [[cycle2D]]s\ldots
<<Orthogonality conditions>>=
cout << wspaces << "The orthogonality in vectors is: " math_string
 << (ex)Cv.is_orthogonal(Cv1, evs, S2) math_string << endl
<< "for paravectors is the same: "
<< Cv.is_orthogonal(Cv1, evs, S2).is_equal(Cp.is_orthogonal(Cp1, eps, S2)) << endl;

@ \ldots and then its reduction to orthogonality of two straight lines.
<<Orthogonality conditions>>=
cout << wspaces << "The orthogonality of two lines is: " math_string
 << (ex)Cv.subs(k == 0).is_orthogonal(Cv1.subs(k1 == 0), evs, S2) math_string << endl;

@  Here is the orthogonality of a generic [[cycle2D]] to a zero-radius
[[cycle2D]]. This reduces to concurrence of the centre the zero-radius
and generic cycle.
<<Orthogonality conditions>>=
cout << wspaces << "The orthogonality to z-r-cycle is: " math_string
<< (ex)Cv.is_orthogonal(Zv, evs)  math_string << endl
	<< "for paravectors is the same: " <<
	Cv.is_orthogonal(Zv, evs).is_equal(Cp.is_orthogonal(Zp, eps)) << endl;

@  Here is the orthogonality of two zero-radius [[cycle2D]]s.
<<Orthogonality conditions>>=
cout << wspaces << "The orthogonality of two z-r-cycle is: " math_string
 <<  (ex)cycle2D(lst{u1, v1}, ev, 0, S2).is_orthogonal(Zv, evs) math_string << endl
	<< "for paravectors is the same: "
<< cycle2D(lst{u1, v1}, ev, 0, S2).is_orthogonal(Zv, evs).is_equal(
																   cycle2D(lst{u1, v1}, ep, 0, S2).is_orthogonal(Zp, eps)) << endl;

@ This chunk finds the parameters of a cycle [[C2]] passing through two
points \((u,v)\), \((u_1,v_1)\) and orthogonal to the given cycle
[[C]]. This gives three linear equations with four variables which are
consistent in a generic position.

<<Two points and orthogonality>>=
	C2 = Cv1.subject_to(lst{Cv1.passing(W),
				Cv1.passing(W1),
				Cv1.is_orthogonal(Cv, evs)}, vars);

@ To find the singularity condition of the above solution we
analyse the denominator of [[k]], which calculated to be:
\begin{displaymath}
  k = \frac{-2 (u^\prime (\sigma_1 n+v k)-v l+(-k v^\prime-\sigma_1 n) u+l v^\prime) n_1 }
  {-u^{\prime 2} l+u^{\prime 2} u k+\sigma l v^{\prime 2}-u^\prime
    u^2 k+u^\prime v^2 \sigma k+u^\prime m-u \sigma k v^{\prime 2}+u^2 l-v^2 \sigma l-u m}.
\end{displaymath}

<<Two points and orthogonality>>=
if (debug > 0)
cout << "Cycle through two point is possible and unique if denominator is not zero: " << endl
 math_string << C2.get_k() math_string << endl << endl;

@
\subsubsection{Orthogonality and Inversion}
\label{sec:orth-invers}

Now we check that any orthogonal cycle comes through the inverse of
any its point. To this end we calculate a generic cycle [[C2]]
passing through a point \((u, v)\) and orthogonal to a cycle
[[C]].
<<One point and orthogonality>>=
auto Ortho_inv=[](const cycle2D & C, const cycle2D & C1, const ex & e, const ex & es) {
	<<Check either vector formalism is used>>
	C2 = C1.subject_to(lst{C1.passing(W),
				C1.is_orthogonal(C, es)});

@
 \sublabel{chu:orth-invers-2}
Then we calculate another cycle [[C3]] with an additional
condition that it passing through the M\"obius transform \(P\) of
\((u, v)\).
<<One point and orthogonality>>=
	P = C.moebius_map(is_vector? W : Wbar, e, -M1);

	C3 = C1.subject_to(lst{C1.passing(P),
				C1.passing(W),
				C1.is_orthogonal(C, es)});

@  Then we check twice in different ways the same mathematical statement:
\begin{enumerate}
\item that both cycles [[C2]] and [[C3]] are identical,
  i.e. the addition of inverse point does not put more restrictions;
<<One point and orthogonality>>=
cout << "Both orthogonal cycles (through one point and through its inverse)"
	" are the same for " << (is_vector? "" : "para") << "vector: "
	<< C2.is_equal(C3) << endl

@ \item that cycle [[C2]] passes through the inversion [[P]] as well.
<<One point and orthogonality>>=
	<< "Orthogonal cycle passes through the transformed point "
	<< (is_vector? "" : "para") << "vector: "
	<< C2.val(P).normal().is_zero() << endl << endl;
};

@ Finally we make both checks.
<<One point and orthogonality>>=
Ortho_inv(Cv, Cv1, ev, evs);
Ortho_inv(Cp, Cp1, ep, eps);

@
\end{enumerate}

@
\subsubsection{Orthogonal Lines}
\label{sec:orthogonal-lines}

This chunk checks that the straight line [[C4]] passing through a point \((u,
v)\) and its inverse [[P]] in the cycle [[C]] is orthogonal to the
initial cycle [[C]].
<<Orthogonal line>>=
auto Ortho_line=[](const cycle2D & C, const cycle2D & C1, const ex & e, const ex & es) {
	<<Check either vector formalism is used>>
	C4 = C1.subject_to(lst{C1.passing(W), C1.passing(P), C1.is_linear()});
cout << "For " << (is_vector? "" : "para") << "vectors" << endl
	<< wspaces << "Line through point and its inverse is orthogonal: " << C4.cycle_product(C, es).is_zero()
	<< endl;

@ We also calculate that all such lines intersect in a single point
\((u_3, v_3)\), which is independent from \((u,v)\). This point will be
understood as centre of the cycle [[C5]] in \S~\ref{sec:ghost-cycle}.
<<Orthogonal line>>=
u3 = C.center().op(0);
v3 = C4.roots(u3, false).op(0).normal();
cout << wspaces << "All lines come through the point " math_string
	<<"(" << u3 << ", " << v3 << ")" math_string << endl;

@ The double check is done next: we calculate the inverse [[P1]] of
a vector [[(u3+u, v3+v)]] and check that [[P1-(u3, v3)]] is collinear
to [[(u, v)]].

<<Orthogonal line>>=
if (is_vector)
	P1 = C.moebius_map(lst{u3+u, v3+v}, e, -M1);
else
	P1 = C.moebius_map(lst{u3+u, -v3-v}, e, -M1);
cout << wspaces << "Conjugated vector is parallel to (u,v): "
		<< ((P1.op(0)-u3)*v-(P1.op(1)-v3)*u).normal().is_zero() << endl;
if (debug > 1)
	cout << wspaces << "Conjugated vector to (u, v) is: " math_string
		 << "(" << (P1.op(0)-u3).normal() << ", "
		 << (P1.op(1)-v3).normal() << ")" math_string << endl; };

@ Finally we make both checks.
<<Orthogonal line>>=
Ortho_line(Cv, Cv1, ev, evs);
Ortho_line(Cp, Cp1, ep, eps);

@
\subsubsection{The Ghost Cycle}
\label{sec:ghost-cycle}
We build now the cycle [[C5]] which defines inversion. We build
it from two conditions:
\begin{enumerate}
\item [[C5]] has its centre in the point [[(u3, v3)]] which is the
  intersection of all orthogonal lines (see \S~\ref{sec:orthogonal-lines}).
\item The determinant of [[C5]] with delta-sign is equal to
  determinant of [[C]] with signs defined by [[M1]].
\end{enumerate}

<<Inversion in cycle>>=
auto Ghost_cycle=[](const cycle2D & C, const cycle2D & C1, const ex & e, const ex & es) {
	<<Check either vector formalism is used>>
	C5 = cycle2D(lst{u3, -v3*jump_fnct(sign)}, e, C.radius_sq(e, M1)).subs(signs_cube,
																		   subs_options::algebraic | subs_options::no_pattern);

@ As a consequence we find out that [[C5]] has the same roots as [[C]].
<<Inversion in cycle>>=
cout << "For " << (is_vector? "" : "para") << "vectors" << endl
	 << wspaces << "Ghost cycle has common roots with C : "
	  << (C5.val(lst{C.roots().op(0), 0}).normal().is_zero()
		  && C5.val(lst{C.roots().op(1), 0}).normal().is_zero()) << endl
	  << wspaces << "$\\chi(\\sigma)$-centre of ghist cycle is equal to "
	  "$\\breve{\\sigma}$-centre of C: "
	  << (C5.center(diag_matrix(lst{-1,jump_fnct(sign)}), true)-C.center(es, true)).normal().is_zero()
	  <<  endl;

@ Finally we calculate point [[P1]] which is the inverse of \((u_3,
v_3)\) in [[C5]].
<<Inversion in cycle>>=
	P1 = C5.moebius_map(is_vector? W : Wbar, e, diag_matrix(lst{1, -jump_fnct(sign)}));
	P = C.moebius_map(is_vector? W : Wbar, e, -M1);

@ The final check: [[P1]] (inversion in [[C5]] in terms of [[sign]])
coincides with [[P]]---the inversion  in [[C]] in terms of [[sign1]],
see chunk~\subpageref{chu:orth-invers-2}.
<<Inversion in cycle>>=
cout << wspaces << "Inversion in (C-ghost, sign) coincides with inversion in (C, sign1): "
	  << (P1-P).subs(signs_cube, subs_options::algebraic | subs_options::no_pattern).normal().is_zero()
	   << endl; };

@ Finally we make both checks.
<<Inversion in cycle>>=
Ghost_cycle(Cv, Cv1, ev, evs);
Ghost_cycle(Cp, Cp1, ep, eps);

@
\subsubsection{The real line and reflection in cycles}
\label{sec:reflection-cycles}

We check that conjugation \(C_1 \Space{R}{} C_1\) maps the
[[real_line]] to the cycle [[C]] and wise verse for the properly
chosen [[C1]],
see~\cite[Lem.~\ref{E-le:cycle-refl-real-line}]{Kisil05a}. The
cycle [[C9]] is defined through the value [[C.det()]], to make this
working for both vector and aparvector formalism we need to set the
parameter [[fix_paravector = true]] or employ [[C.hdet()]] method,
which set this automatically.
<<Reflection in cycle>>=
for (si=-1; si<2; si+=2) {
	auto Inv_RL=[](const cycle2D & C, const cycle2D & C1, const cycle2D & real_line,
				   const ex & e, const ex & es) {
		<<Check either vector formalism is used>>
		C9 = cycle2D(k, lst{l, n+si*sqrt(C.hdet(es)*sign1)},m,es);
		cout << "For " << (is_vector? "" : "para") << "vectors" << endl
		<< wspaces << "Inversion to the real line (with " << (si==-1? "-" : "+") << " sign): " << endl
		<< wspaces << "Conjugation of the real line is the cycle C: "
		<< real_line.cycle_similarity(C9, es).subs(pow(sign1,2)==1, subs_options::algebraic).is_equal(C) << endl
		<< wspaces << "Conjugation of the cycle C is the real line: "
		<< C.cycle_similarity(C9, es).subs(pow(sign1,2)==1, subs_options::algebraic).is_equal(real_line) << endl


@ We also check two additional properties which caracterises the inversion
cycle [[C9]] in term of common roots of [[C]]
\cite[Lem.~\ref{E-it:inv-cycle-root}]{Kisil05a} and [[C]] passing
through [[C9]] centre \cite[Lem.~\ref{E-it:inv-cycle-center}]{Kisil05a}.
<<Reflection in cycle>>=
		<< wspaces << "Inversion cycle has common roots with C: "
		<< (C9.val(lst{C.roots().op(0), 0}).numer().normal().is_zero()
			&& C9.val(lst{C.roots().op(1), 0}).numer().normal().is_zero()) << endl
		<< wspaces << "C passing the centre of inversion cycle: "
		<< cycle2D(C, es).val(C9.center()).numer().subs(sign1==sign, subs_options::no_pattern).normal()
		.subs(pow(sign,2)==1, subs_options::algebraic | subs_options::no_pattern).is_zero() << endl; };
	Inv_RL(Cv, Cv1, real_linev, ev, evs);
	Inv_RL(Cp, Cp1, real_linep, ep, eps);
}

@
\subsubsection{Yaglom inversion of the second kind}
\label{sec:invers-second-kind}
In the book~\cite[\S~10]{Yaglom79} the inversion of second kind related to a
parabola \(v=k(u-l)^2+m\) is defined by the map:
\begin{displaymath}
  (u,v) \mapsto (u, 2(k(u-l)^2+m)-v).
\end{displaymath}
We shows here that this is a composition of three inversions in two
parabolas and the real line,
see~\cite[Prop.\ref{E-pr:inv-2nd-kind-decomp}]{Kisil05b}.
<<Yaglom inversion>>=
auto Yaglom_inv=[](const cycle2D & real_line, const ex & e) {
	<<Check either vector formalism is used>>
	cout << "For " << (is_vector? "" : "para") << "vectors "
	<< "Yaglom inversion of the second kind is three reflections in the cycles: "
	<< (real_line.moebius_map(cycle2D(lst{l, 0}, e, -m/k).moebius_map(cycle2D(lst{l, 2*m}, e, -m/k)
																   .moebius_map(is_vector? W : Wbar))).subs(sign==0)
	 -matrix(2,1,lst{u, 2*(k*pow(u-l,2)+m)-v})).normal().is_zero() << endl; };

Yaglom_inv(real_linev, ev);
Yaglom_inv(real_linep, ep);

@
\subsection{Focal Orthogonality}
\label{sec:focal-orth-1}

We study now the focal orthogonality condition
(f-orthogonality), \cite[\S~\ref{E-sec:focal-orthogonality}]{Kisil05a}.

\subsubsection{Expressions for f-orthogonality}
\label{sec:expr-orth-s.k}

@ One more simple consistency check: the [[real_line]] is invariant
under all M\"obius transformations.
<<Focal orthogonality conditions>>=
auto Focal_orth_cond=[](const cycle2D & real_line, const ex & e) {
	<<Check either vector formalism is used>>
	cout << "For " << (is_vector? "" : "para") << "vectors"
	<< wspaces << "The real line is Moebius invariant: "
	<< real_line.is_equal(real_line.sl2_similarity(a, b, c, d, e)) << endl; };
Focal_orth_cond(real_linev,evs);
Focal_orth_cond(real_linep,eps);

@ Formulae for focal orthogonality:
<<Focal orthogonality conditions>>=
cout << "Reflection in the real line (vector): "
						 math_string << Zv.cycle_similarity(real_linev, evs).normalize()
						 math_string << endl
<< wspaces << "for paravector is the same: "
<< Zv.cycle_similarity(real_linev, evs).is_equal(Zp.cycle_similarity(real_linep, eps),true,true) << endl;

cout  << "Reflection of the real line in cycle C (vectors): " << endl
	math_string << real_linev.cycle_similarity(Cv, evs, S2, S3) math_string << endl
	  << wspaces << "for paravectors is the same: "
	  << real_linev.cycle_similarity(Cv, evs, S2, S3).is_equal(real_linep.cycle_similarity(Cp, eps, S2, S3),true,true)
	  << endl;

@ The focal orthogonality condition between two different
cycles is calculated by the identity~\cite[\S~\ref{E-sec:focal-orthogonality}]{Kisil05a}
\begin{displaymath}
  \Re \tr \scalar{C_1C_2C_1}{\Space{R}{}}=0.
\end{displaymath}
@ Here is f-orthogonality of two generic [[cycle2D]]s\ldots
<<Focal orthogonality conditions>>=
cout  << "The f-orthogonality is (vectors): " math_string
<< (ex)Cv.is_f_orthogonal(Cv1, evs, S2) math_string << endl
<< wspaces << "for paravectors is the same: "
<< Cv.is_f_orthogonal(Cv1, evs, S2).is_equal(Cp.is_f_orthogonal(Cp1, eps, S2)) << endl;

@ \ldots and its reduction to the straight lines case.
<<Focal orthogonality conditions>>=
cout << wspaces << "The f-orthogonality of two lines is (vectors): " math_string
<< (ex)Cv.subs(k == 0).is_f_orthogonal(Cv1.subs(k1==0), evs, S2) math_string << endl
<< wspaces << "for paravectors is the same: "
<< Cv.subs(k == 0).is_f_orthogonal(Cv1.subs(k1==0), evs, S2).is_equal(
																	  Cp.subs(k == 0).is_f_orthogonal(Cp1.subs(k1==0), eps, S2)) << endl;

@ Here is f-orthogonality of a generic [[cycle2D]] to a zero-radius [[cycle2D]].
<<Focal orthogonality conditions>>=
cout << wspaces << "The f-orthogonality to z-r-cycle is first way (vectors): "  << endl
	math_string << (ex)Cv.is_f_orthogonal(Zv1, evs, S2) math_string << endl
<< wspaces << "for paravectors is the same: "
<< Cv.is_f_orthogonal(Zv1, evs, S2).is_equal(Cp.is_f_orthogonal(Zp1, eps, S2)) << endl;

@ Since f-orthogonality is not
symmetric~\cite[\S~\ref{E-sec:focal-orthogonality}]{Kisil05a},
we calculate separately f-orthogonality of a
zero-radius [[cycle2D]] to a generic [[cycle2D]].
<<Focal orthogonality conditions>>=
cout << wspaces << "The f-orthogonality to z-r-cycle in second way (vectors): " << endl
	math_string << (ex)Zv1.is_f_orthogonal(Cv, evs, S2) math_string << endl
<< wspaces << "for paravectors is the same: "
<< Zv1.is_f_orthogonal(Cv, evs, S2).is_equal(Zp1.is_f_orthogonal(Cp, eps, S2)) << endl;

@ Here is f-orthogonality of two zero-radius [[cycle2D]]s.
<<Focal orthogonality conditions>>=
	//C9 = cycle2D(lst{u1, v1}, e);
cout << wspaces << "The f-orthogonality of two z-r-cycle is (vectors): " << endl
 math_string << (ex)Zv1.is_f_orthogonal(cycle2D(lst{u1, v1}, ev), evs, S2) math_string << endl
<< wspaces << "for paravectors is the same: "
<< Zv1.is_f_orthogonal(cycle2D(lst{u1, v1}, ev), evs, S2).is_equal(
																   Zp1.is_f_orthogonal(cycle2D(lst{u1, v1}, ep), eps, S2)) << endl;

@
\subsubsection{Properies of f-orthogonality }
\label{sec:prop-orth-s.k}

Find the parameters of cycle passing through a point
and f-orthogonal to the given one
<<One point and f-orthogonality>>=
cycle2D Cv6 = Cv1.subject_to(lst{Cv1.passing(W), Cv.is_f_orthogonal(Cv1, evs)}),
	Cp6 = Cp1.subject_to(lst{Cp1.passing(W), Cp.is_f_orthogonal(Cp1, eps)});
 if (debug > 1)
	 cout << "Cycle f-orthogonal to (k, (l, n), m) is (vectors): " << endl
		 math_string << C6 math_string << endl
		  << wspaces << "for paravectors is the same: "
		  << Cv6.is_equal(Cp6,true, true);

@ Check the orthogonality of the line through a point to the
cycle.
<<f-orthogonal line>>=
auto Focal_orth_line=[](const cycle2D & C6, const cycle2D & C, const ex & e) {
	<<Check either vector formalism is used>>
	C7 = C6.subject_to(lst{C6.is_linear()});
	u4 = C.center().op(0);
	v4 = C7.roots(u4, false).op(0).normal();

@ All orthogonal lines come through the same point, which the
focus of the cycle [[C]] with respect to metric [[(-1, -sign1)]].
<<f-orthogonal line>>=
cout << wspaces << "For " << (is_vector? "" : "para")
	<< "vectors all lines come through the focus related $\\breve{e}$: "
	<< (C.focus(diag_matrix(lst{-1, -sign1}), true)-matrix(2, 1, lst{u4, v4})).normal().is_zero() << endl; };

 Focal_orth_line(Cv6, Cv, ev);
 Focal_orth_line(Cp6, Cp, ep);

@
\subsubsection{Inversion from the f-orthogonality}
\label{sec:invers-from-orth}
We express f-orthogonality to a cycle [[C]] through the usual
orthogonality to another cycle [[C8]]. This cycle is the reflection of
the real line in [[C]], see~\ref{sec:reflection-cycles}.

<<f-inversion in cycle>>=
auto Focal_inversion=[](const cycle2D & C, const cycle2D & C6, const cycle2D & real_line,
						const ex & e, const ex & es) {
	<<Check either vector formalism is used>>
	C8 = real_line.cycle_similarity(C, es, diag_matrix(lst{1, sign1}),
									diag_matrix(lst{1, jump_fnct(sign)}), diag_matrix(lst{1, sign1})).normalize(n*k);
	if (debug > 1)
		cout << "f-ghost cycleis : " math_string << C8 math_string << endl;

@ We check that [[C8]] has common roots with [[C]].
<<f-inversion in cycle>>=
	cout << "For " << (is_vector? "" : "para") << "vectors" << endl;
	cout << wspaces << "f-ghost cycle has common roots with C: "
		<< (C8.val(lst{C.roots().op(0), 0}).numer().normal().is_zero()
			&& C8.val(lst{C.roots().op(1), 0}).numer().normal().is_zero()) << endl;

@ This chunk checks that centre of [[C8]] coincides with focus of [[C]].
<<f-inversion in cycle>>=
	cout  << wspaces << "$\\chi(\\sigma)$-center of f-ghost cycle coincides "
	"with $\\breve{\\sigma}$-focus of C : "
	<< (C8.center(diag_matrix(lst{-1,jump_fnct(sign)}), true)
		-C.focus(diag_matrix(lst{-1, -sign1}), true)).evalm().normal().is_zero_matrix()
	<< endl;

@ Finally we check that f-inversion in [[C]] defined through
f-orthogonality coincides with inversion in [[C8]].
<<f-inversion in cycle>>=
	P1 = C8.moebius_map(is_vector? W : Wbar, e, diag_matrix(lst{1, -jump_fnct(sign)}))
	.subs(signs_cube, subs_options::algebraic | subs_options::no_pattern).normal();
	cout << wspaces << "f-inversion in C coincides with inversion in f-ghost cycle: "
	<< C6.val(P1).normal().subs(signs_cube, subs_options::algebraic | subs_options::no_pattern).normal().is_zero()
	<< endl; };

@ Finally, we do the check for both formalisms.
<<f-inversion in cycle>>=
Focal_inversion(Cv,Cv6,real_linev,ev,evs);
Focal_inversion(Cp,Cp6,real_linep,ep,eps);

@
\subsection{Distances and Lengths}
\label{sec:distances-lengths}

\subsubsection{Distances between points}
\label{sec:dist-betw-points}

We calculate several distances from the cycles.

The distance is given by the extremal value of diameters for all
possible cycles passing through the both
points~\cite[Defn.~\ref{E-de:distance}]{Kisil05b}. Thus we first
construct a generic [[cycle2d]] [[C10]] passing through two points
\((u, v)\) and \((u^\prime,v^\prime)\).

<<Distances from cycles>>=
auto Distance1=[](const cycle2D & C, const ex & e, const ex & es) {
	<<Check either vector formalism is used>>
	cycle2D C10 = cycle2D(numeric(1), lst{l, n}, m, e);
	C10 = C10.subject_to(lst{C10.passing(W), C10.passing(W1)}, lst{m, n, l});
	if (debug > 0) cout << wspaces << "C10 is:   "  << C10 << endl;

@ Then we calculate the square of its radius as the value of the
determinant [[D]]. The point [[l]] of extremum [[Len_c]] is calculated from the
condition \(D^\prime_l=0\).
<<Distances from cycles>>=
	ex D = 4*C10.radius_sq(es);
	Len_c = D.subs(lsolve(lst{D.diff(l) == 0}, lst{l})).normal();

@ Now we check that [[Len_c]] is equal to~\cite[Lem.~\ref{E-le:distance-first}]{Kisil05a}
\begin{displaymath}
        d^2(y, y^\prime) = \frac{ \bs ((u-u^\prime)^2-\sigma(v- v^\prime)^2) +4(1-\sigma\bs) v v^\prime}
      {(u- u^\prime)^2 \bs-(v-v^\prime)^2} ((u-u^\prime)^2 -\sigma(v- v^\prime)^2),
\end{displaymath}
<<Distances from cycles>>=
	cout << "For " << (is_vector? "" : "para") << "vectors" << endl;
	cout << wspaces << "Distance between (u,v) and (u\',v\') in elliptic and hyperbolic spaces is "
	<< endl;

if (output_latex) {
 ex dist = (sign1*(pow(u-u1,2)-sign*pow(v-v1,2))+4*(1-sign*sign1)*v*v1)*(pow(u-u1,2)
   -sign*pow(v-v1,2))/(pow(u-u1,2)*sign1-pow(v-v1,2));
 cout << "\\(\\displaystyle " << dist << "\\): " <<  (Len_c-dist).normal().is_zero() << endl;
} else
 cout << endl
  << "  s1*((u-u\')^2-s*(v-v\')^2)+4*(1-s*s1)*v*v\')*((u-u\')^2-s*(v-v\')^2)"
  << endl
  << "  ---------------------------------------------------------------      : "
  <<  (Len_c-(sign1*(pow(u-u1,2)-sign*pow(v-v1,2))+4*(1-sign*sign1)*v*v1)*(pow(u-u1,2)
   -sign*pow(v-v1,2))/(pow(u-u1,2)*sign1-pow(v-v1,2))).normal().is_zero() << endl
  <<"               (u-u\')^2*s1-(v-v\')^2" << endl << endl;

@ Conformity is verified in the same chunk (see
\S~\ref{sec:check-conformity}) for this and all subsequent
distances and lengths. Value [[si = -1]] initiates
conformality checks only
in elliptic and hyperbolic point spaces.
<<Distances from cycles>>=
	check_conformality(Len_c, -1);
	C11 = C10.subs(lsolve(lst{D.diff(l) == 0}, lst{l}));
	print_perpendicular(C11);

@ In parabolic space the extremal value is attained in the point
\(\frac{1}{2}(u+u1)\), since it separates upward-branched parabolas
from down-branched.
<<Distances from cycles>>=
	Len_c = D.subs(lst{sign ==0, l == (u+u1)*half}).normal();
	cout << wspaces << "Value at the middle point (parabolic point space):" << endl << wspaces
	math_string << Len_c math_string << endl;

@ Value [[si = 0]] initiates conformality checks only in the parabolic point space.
<<Distances from cycles>>=
	check_conformality(Len_c, 0);
	C11 = C10.subs(lst{sign ==0, l == (u+u1)*half});
	print_perpendicular(C11); };

@ Now we are checking this in both formalisms.
<<Distances from cycles>>=
Distance1(Cv, ev, evs);
Distance1(Cp, ep, eps);

@  We need to check the case \(v=v^\prime\) separately, since it is not covered
by the above chunk. This is done almost identically to the previous
case, with replacement of \(l\) by \(n\), since the value of \(l\) is
now fixed.
<<Distances from cycles>>=
auto Distance2=[](const cycle2D & C, const ex & e, const ex & es) {
	cycle2D C10 = cycle2D(numeric(1), lst{l, n}, m, e);
	C10 = C10.subject_to(lst{C10.passing(W),
				C10.passing(lst{u1, v})});
	if (debug > 1)
		cout << wspaces  << C10 << endl;

@ This time the extremal point [[n]] is found from the condition \(D^\prime_n=0\).
<<Distances from cycles>>=
	ex D = 4*C10.radius_sq(es);
	return D.subs(lsolve(lst{D.diff(n) == 0}, lst{n})).normal(); };

ex Dv=Distance2(Cv, ev, evs);
	cout << "For vectors distance between (u,v) and (u\',v\') "
		 << "(value at critical point): " << endl
		 << wspaces math_string << Dv  math_string
		 << endl << endl
		 << wspaces << " for paravector is the same: "
		 <<Dv.is_equal(Distance2(Cp, ep, eps)) << endl;

@
\subsubsection{Check of the conformal property}
\label{sec:check-conformity}

We check conformal property of all distances and lengths. This is most
time-consuming portion of the program and it took few minutes
on my computer. The rest is calculated within twenty seconds.
<<Check conformal property>>=
void check_conformality(const ex & Len_c, int si = 3) {
 <<Evaluate the fraction>>

@ Several times we fork for two cases: the first one if the check is done for all
signs combinations simultaneously.
<<Check conformal property>>=
if (si > 2)
 cout << wspaces << "This distance/length is conformal:" ;

@ The second case is we output coresponding results for different metric signs.
<<Check conformal property>>=
else
 cout << wspaces << "Conformity in a cycle space with metric:   E      P      H " << endl;

@ However we make the substitution of all possible combinations of [[sign]] and
[[sign1]] (an initial value of [[si]] should be set  before in
order to separate parabolic case from others). The first loop is for point space
metric sign.
<<Check conformal property>>=
do  {
 if (si > 1)
  si1 = 2;
 else {
  cout << wspaces << "Point space is " << eph_case(si) << ": ";
  si1 = -1;
 }

@ The second loop is for cycle space metric sign.
<<Check conformal property>>=
 do {
  if (si < 2)

@  However the substition of signs is not done for dummy loops.
<<Check conformal property>>=
Len_cD = Len_fD.subs(lst{sign == numeric(si), sign1 == numeric(si1)},
         subs_options::algebraic | subs_options::no_pattern).normal();

@ But even for dummy loops we make a check the conformity.
<<Check conformal property>>=
  <<Find the limit>>
  <<Check independence>>

@ and then finalise all loops.
<<Check conformal property>>=
		si1++;
	} while (si1 < 2);
	cout  << endl;
	si+=2;
} while (si < 2);
}

@ To this end we consider the ratio of distances between \((u,v)\) and
\((u+tx,v+ty)\) and between their images [[gW]] and [[gW1]] under the
generic M\"obius transform.
<<Evaluate the fraction>>=
ex Len_cD= ((Len_c.subs(lst{u == gW.op(0), v==gW.op(1), u1 == gW1.op(0),
					v1==gW1.op(1)}, subs_options::algebraic | subs_options::no_pattern)
		/Len_c).subs(lst{u1==u+t*x, v1==v+t*y}, subs_options::algebraic | subs_options::no_pattern)).normal();
ex Len_fD = Len_cD;

@ If [[Len_cD]] has the variable [[t]], we take the limit
\(t\rightarrow 0\) using the power series expansions.
<<Find the limit>>=
if (Len_cD.has(t))
 Len_cD = Len_cD.series(t==0,1).op(0).normal();

@ The limit of this ratio for \(t\rightarrow 0\) should be independent
from \((x,y)\) (see \cite[Defn.~\ref{E-de:conformal}]{Kisil05a}).
<<Check independence>>=
bool is_conformal = !(Len_cD.is_zero() || Len_cD.has(t)
     || Len_cD.has(x) || Len_cD.has(y));
cout << " " << is_conformal;
if (debug > 0 || (!is_conformal && (si > 2))) {
	cout << ". The factor is: " << endl << wspaces math_string << Len_cD.normal() math_string ;

}

@
\subsubsection{Calculation of Perpendiculars}
\label{sec:calc-perp}

Lengths define corresponding perpendicular conditions in terms of
shortest routes, see~\cite[Defn.~\ref{E-de:perpendicular}]{Kisil05a}.
<<Print perpendicular>>=
void print_perpendicular(const cycle2D & C) {
 cout << wspaces << "Perpendicular to ((u,v); (u\',v\')) is: "
  math_string << (C.get_l(1)+sign*C.get_k()*v1).normal() math_string << "; "
  math_string << (C.get_l(0)-C.get_k()*u1).normal() math_string << endl << endl;
}

@
\subsubsection{Length of intervals from centre}
\label{sec:length-direct-interv}

We calculate the lengths derived from the cycle
with a \emph{centre} at one point and passing through the second,
see~\cite[Defn.~\ref{E-de:length}]{Kisil05a}.

@ Firstly we need some more imaginary units, to accommodate different
types of centres (foci).
<<Declaration of variables>>=
ex sign5=sign4;

@ Then we build a [[cycle2D]] [[C11]] which passes through \((u^\prime, v^\prime)\) and
has its centre at \((u,v)\).
<<Lengths from centre>>=
auto Length_checks=[](const cycle2D & C, const ex & e, const ex & es, const ex & e4) {
	<<Check either vector formalism is used>>
	sign5=sign4;
	C11 = C.subject_to(lst{C.passing(W1), C.is_normalized()});
	C11 = C11.subject_to(lst{C11.center().op(0) == u, C11.center(e4).op(1)== v});

@ Then the distance is  radius the [[C11]],
see~\cite[Lem.~\ref{E-it:length-centre}]{Kisil05a}. We check conformity
and calculate the perpendicular at the end.
<<Lengths from centre>>=
	Len_c = C11.radius_sq(es).normal();
	cout << "For " << (is_vector? "" : "para") << "vectors" << endl;
	cout << wspaces << "Length from *center* between (u,v) and "
	math_string << "(u^\\prime,v^\\prime)" math_string << ":" << endl  << wspaces
	math_string << Len_c math_string << endl ;
	check_conformality(Len_c);
	print_perpendicular(C11);

@
\subsubsection{Length of intervals from focus}
\label{sec:length-interv-from}

We calculate the length derived from the cycle with a
\emph{focus} at one point. To use the linear solver in \GiNaC\ we need
to replace the condition [[C10.focus().op(1) == v]] by hand-made value
for the parameter [[n]].

There are two suitable values of [[n]] which correspond upward and
downward parabolas, which are expressed by plus or minus before the
square root.  After the value of length was found we master
a simpler expression for it which utilises the focal length [[p]] of
the parabola.
<<Lengths from focus>>=
focal_length_check(sign5*(-(v1-v)+sqrt(sign5*pow((u1-u), 2)+pow((v1-v), 2) -sign5*sign*pow(v1, 2))), C, e, es);

@ This chunk is similar to an above one but checks the second
parabola (the minus sign before the square root).
<<Lengths from focus>>=
focal_length_check(sign5*(-(v1-v)-sqrt(sign5*pow(u1-u, 2)+pow((v1-v), 2) -sign5*sign*pow(v1, 2))), C, e, es);

@ We need to verify separately the case of [[sign5=0]], in this case
[[p]] has a rational value.
<<Lengths from focus>>=
cout << "Shall be `false' for conformality below" << endl;
sign5=0;
focal_length_check((pow(u1-u,2)-sign*pow(v1,2))/(v1-v)/2, C, e, es); };

@ Finally, we do the check for both formalisms.
<<Lengths from focus>>=
Length_checks(Cv,ev,evs,ev4);
Length_checks(Cp,ep,eps,ep4);

@  Again to avoid non-linearity of equation, we first
construct a desired cycle.
<<Focal length checks>>=
void focal_length_check(const ex & p, const cycle2D & C, const ex e, const ex es) {
	cout << "Length from *focus* check for " math_string << "p = " << p math_string << endl;
	cycle2D C11 = C.subject_to(lst{C.passing(W1), k==1, l == u, n == p});

@ And now we verify that the length is equal
to \((1-\sigma_1)p^2-2vp\), see~\cite[Lem.~\ref{E-it:length-focus}]{Kisil05a}.
<<Focal length checks>>=
	  ex Len_c = C11.radius_sq(es).subs(pow(sign4,2)==1,subs_options::algebraic | subs_options::no_pattern).normal();
 cout << wspaces << "Length between (u,v) and (u\', v\') is equal to "
	  << (output_latex ?  "\\((\\mathring(\\sigma)-\\breve{\\sigma})p^2-2vp\\): ": "(s4-s1)*p^2-2vp: ")
	  << (Len_c - ((sign5-sign1)*pow(p, 2) - 2*v*p)).subs(signs_cube, subs_options::algebraic | subs_options::no_pattern)
	 .expand().subs(pow(sign4,2)==1,subs_options::algebraic | subs_options::no_pattern).normal().is_zero()
	  << endl;

@ and we check all requested properties for [[C11]]: it passes
[[(u1, v1)]] and has focus at [[(u, v)]].
<<Focal length checks>>=
	cout << wspaces << "checks: C11 passes through (u\', v\'): " << C11.val(W1).normal().is_zero()
<< "; C11 focus is at (u, v): "
<< (C11.focus(diag_matrix(lst{-1,sign5}),true).subs(pow(sign4,2)==1,subs_options::algebraic)-matrix(2,1,lst{u,v}))
														 .evalm().normal().is_zero_matrix() << endl;
check_conformality(Len_c);

@ We finally verify that focal perpendiculars are multiples of the
vector \((\sigma v^\prime+p, u-u^\prime)\), see~\cite[E-it:focal-perpendicularity]{Kisil05a}.
<<Focal length checks>>=
	  cout << wspaces << "Perpendicular to ((u,v); (u\',v\')) is "
		   << (output_latex ? "\\((\\sigma v\'+p, u-u\')\\): " : "(s*v\'+p, u-u\'): ")
		   << ((C11.get_l(1)+sign*C11.get_k()*v1-(sign*v1+p)).normal().is_zero()
			   && (C11.get_l(0)-C11.get_k()*u1-(u-u1)).normal().is_zero())
		   << endl << endl;
}

@
\subsection{Infinitesimal Cycles}
\label{sec:infinites-cycles}
The final bit of our calculation is related with the infinitesimal
radius cycles,
see~\cite[\S~\ref{E-sec:zero-length-cycles}]{Kisil05a}.

Some additional parameters.
<<Declaration of variables>>=
possymbol vp("vp","v_p"); //the positive instance of symbol [[v]]
ex displ; //displacement of the focus

@
\subsubsection{Basic properties of infinitesimal cycles}
\label{sec:basic-prop-infin}

@We define an infinitesimal cycle [[C10]] such that its squared radius
(\(\det\)) is an infinitesimal number \(\varepsilon^2\) and focus is
at \((u,v)\). This defined by the cycle \((1, u_0, n, u_0^2+2 n v_0
    -\rs n^2)\) where \(n\) satisfies to the equation
\begin{equation}
  \label{eq:inf-cycle-cond}
  (\rs-\bs)n^2-2v_0n+\varepsilon^2=0.
\end{equation}
Only one root of the quadratic case produces a cycle with an
infinitesimal focal length, and we consider it here:
<<Infinitesimal cycle>>=
infinitesimal_calculations(n==(vp-sqrt(pow(vp,2)+pow(epsilon,2)*(sign4-sign1)))/(sign4-sign1),
						   Cv,ev,evs,ev4,Cp,ep,eps,ep4);
//infinitesimal_calculations(n==(vp-abs(pow(pow(vp,2)-pow(epsilon,2)*(sign4-sign1),half)))/(sign4-sign1),
// C,e,es,e4,is_vector);

@ The second expression for an infinitesimal cycle for the case
\(\rs=\bs\) is given by the substitution
\(n=-\frac{\varepsilon^2}{2v}\), which the root
of~\eqref{eq:inf-cycle-cond} in this case.
<<Infinitesimal cycle>>=
infinitesimal_calculations(lst{n==pow(epsilon,2)/2/vp, sign4==sign1},Cv,ev,evs,ev4,Cp,ep,eps,ep4);

@ We organise the infinitesimal cycles check as a separate subroutine
and start it from several local variables definition.
<<Infinitesimal cycle calculations>>=
void infinitesimal_calculations(const ex & nval, const cycle2D C, const ex e, const ex es, const ex e4,
								const cycle2D Cn, const ex en, const ex ens, const ex en4) {
	exmap smap;
	smap[v]=vp;

@
<<Infinitesimal cycle calculations>>=
	cycle2D C10 = cycle2D(1, lst{u, n},  pow(u,2)-pow(n,2)*sign1-pow(epsilon,2), e).subs(nval),
	  Cn10 = cycle2D(1, lst{u, n},  pow(u,2)-pow(n,2)*sign1-pow(epsilon,2), en).subs(nval);
	cout << wspaces << "Inf cycle is: " math_string << C10 math_string << endl;
	cout << wspaces << "For paravector is the same: " << C10.is_equal(Cn10,true,true) << endl;
	cout << wspaces << "Square of radius of the infinitesimal cycle is: "
		math_string << C10.radius_sq(es).subs(signs_cube, subs_options::algebraic
											  | subs_options::no_pattern).normal() math_string << endl
		 << wspaces << "For paravector is the same: " << C10.radius_sq(es).subs(signs_cube, subs_options::algebraic
																				| subs_options::no_pattern).normal()
		.is_equal(Cn10.radius_sq(es).subs(signs_cube, subs_options::algebraic
										  | subs_options::no_pattern).normal()) << endl;


@ Then we verify that in parabolic space it focus is in the point
\((u,v)\) and the focal length is an infinitesimal.
<<Infinitesimal cycle calculations>>=
cout << wspaces << "Focus of infinitesimal cycle is: " math_string
	<< C10.focus(e4).subs(nval) math_string << endl
	<< wspaces << "For paravector is the same: "
	<< C10.focus(e4).subs(nval).is_equal(Cn10.focus(en4).subs(nval)) << endl
	<< wspaces << "Focal length is: " math_string
	<< C10.focal_length().series(epsilon==0,3).normal() math_string << endl
	<< wspaces << "For paravector is the same: "
	<< C10.focal_length().series(epsilon==0,3).normal().is_equal(
																 Cn10.focal_length().series(epsilon==0,3).normal())
	<< endl;

	cout << wspaces << "Infinitesimal cycle (vector) passing points" math_string
		 << "(u+" << epsilon*x <<", vp+"
		 << lsolve(C10.subs(sign==0).passing(lst{u+epsilon*x,vp+y}),y).series(epsilon==0,3).normal()
		 << "), " math_string << endl;

	cout << wspaces << "Infinitesimal cycle (paravector) passing points" math_string
		 << "(u+" << epsilon*x <<", vp+"
		 << lsolve(Cn10.subs(sign==0).passing(lst{u+epsilon*x,vp+y}),y).series(epsilon==0,3).normal()
		 << "), " math_string << endl;

@
\subsubsection{M\"obius transformations of infinitesimal cycles }
\label{sec:mobi-transf-infin}

Now we check that transformation of an infinitesimal cycle is an
infinitesimal cycle again\ldots
<<Infinitesimal cycle calculations>>=
	cycle2D C11=C10.sl2_similarity(a, b, c, d, es),
	Cn11=Cn10.sl2_similarity(a, b, c, d, ens);
	cout << wspaces << "Image under SL2(R) of infinitesimal cycle has radius squared: " << endl
		math_string << C11.radius_sq(es).subs(sl2_relation1,
											  subs_options::algebraic | subs_options::no_pattern).subs(signs_cube,
																									   subs_options::algebraic | subs_options::no_pattern)
		.series(epsilon==0,3).normal()
		math_string << endl
		 << wspaces << "For paravector is the same: "
		 << C11.radius_sq(es).subs(sl2_relation1,
								   subs_options::algebraic | subs_options::no_pattern).subs(signs_cube,
																							subs_options::algebraic | subs_options::no_pattern)
		.series(epsilon==0,3).normal().is_equal(Cn11.radius_sq(ens).subs(sl2_relation1,
																		 subs_options::algebraic | subs_options::no_pattern).subs(signs_cube,
																																  subs_options::algebraic | subs_options::no_pattern)
												.series(epsilon==0,3).normal()) << endl;

@ \ldots cycle similarity is under the test\ldots
<<Infinitesimal cycle calculations>>=
	cout << wspaces << "Image under cycle similarity of infinitesimal cycle has radius squared: "
		 << endl
		math_string << C10.cycle_similarity(C, es).radius_sq(es).subs(signs_cube, subs_options::algebraic
																	  | subs_options::no_pattern).series(epsilon==0,3).normal() math_string << endl
		<< wspaces << "For paravector is the same: "
		<< C10.cycle_similarity(C, es).radius_sq(es).subs(signs_cube, subs_options::algebraic
														  | subs_options::no_pattern).series(epsilon==0,3).normal()
		.is_equal(Cn10.cycle_similarity(Cn, es).radius_sq(ens).subs(signs_cube, subs_options::algebraic
																	| subs_options::no_pattern).series(epsilon==0,3).normal())
		 << endl;

@ \ldots and focus of the transformed cycle is (up to infinitesimals)
obtained from the focus of initial cycle by the same transformation.
<<Infinitesimal cycle calculations>>=
	ex displ = (C11.focus(e4, true).subs(nval) - gW.subs(smap, subs_options::no_pattern)).evalm();
	cout << wspaces << "Focus of the transormed cycle is from transformation of focus by: "
		math_string << displ.subs(sl2_relation, subs_options::algebraic
								  | subs_options::no_pattern).subs(lst{sign==0,a==(1+b*c)/d}).series(epsilon==0,2).normal()
		math_string << endl;

@
\subsubsection{Orthogonality with infinitesimal cycles}
\label{sec:orth-with-infin}

We also find expressions for the orthogonality (see
\S~\ref{sec:orthogonality-cycles}) with the infinitesimal radius
cycle.
<<Infinitesimal cycle calculations>>=
	cout << wspaces << "Orthogonality (leading term) to infinitesimal cycle is:" << endl << wspaces
									 math_string << ex(C.is_orthogonal(C10, es)).series(epsilon==0,1).normal() math_string << endl;

@ And the both expressions for the f-orthogonality (see
\S~\ref{sec:focal-orth-1}) conditions with the infinitesimal
radius cycle.  The second relation verifies the
Lem.~\ref{E-le:infinitesimal-ortho} from~\cite{Kisil05a}.
<<Infinitesimal cycle calculations>>=
	  cout << wspaces << "f-orthogonality of other cycle to infinitesimal:" << endl << wspaces
	  math_string << C.is_f_orthogonal(C10, es).series(epsilon==0,1).normal() math_string << endl
		   << "f-orthogonality of infinitesimal cycle to other:" << endl << wspaces
	  math_string << C10.is_f_orthogonal(C, es).series(epsilon==0,3).normal() math_string << endl;

@
\subsubsection{Cayley transform of infinitesimal cycles}
\label{sec:cayl-transf-infin}

@ Here is two matrices which defines the Cayley transform and its inverses:
<<Declaration of variables>>=
	const matrix TCv(2,2, lst{dirac_ONE(), -ev.subs(mu2==1), sign1*ev.subs(mu2==1), dirac_ONE()}),
	 TCp(2,2, lst{dirac_ONE(), -ep.subs(mu1==0), sign1*ep.subs(mu1==0), dirac_ONE()});
// the inverse is TCI(2,2, lst{dirac_ONE(), e.subs(mu==1), -sign1*e.subs(mu==1), dirac_ONE()});

@
We conclude with calculations of the parabolic Cayley
transform~\cite[\S~\ref{E-sec:cayl-transf-cycl}]{Kisil05a} on
infinitesimal radius cycles. The parabolic Cayley transform on cycles  is defined by the following transformation.
<<Parabolic Cayley transform of cycles>>=
cycle2D cayley_parab(const cycle2D & C, const ex & sign = -1)
{
	return cycle2D(C.get_k()-2*sign*C.get_l(1), C.get_l(), C.get_m()-2*C.get_l(1), C.get_unit());
}


@ The image of an infinitesimal cycle is another infinitesimal radius
cycle\ldots
<<Infinitesimal cycle calculations>>=
	C11 = cayley_parab(C10, sign1);
	cout << wspaces <<  "Det of Cayley-transformed infinitesimal cycle: "
		math_string << C11.radius_sq(es).subs(lst{sign == 0},
											  subs_options::algebraic | subs_options::no_pattern).series(epsilon==0,3).normal()
		math_string << endl;

@ \ldots with its focus mapped by the Cayley transform.
<<Infinitesimal cycle calculations>>=
	displ = (C11.focus(e4, true).subs(nval)
				 - clifford_moebius_map(TCv, matrix(2,1,lst{u,vp}), e)).evalm().normal();
	ex displn = (C11.focus(e4, true).subs(nval)
				 - clifford_moebius_map(TCp, matrix(2,1,lst{u,vp}), en)).evalm().normal();
	cout << wspaces << "Focus of the Cayley-transformed infinitesimal cycle displaced by: " math_string ;
 try{
	 cout << displ.subs(lst{sign == 0},
						subs_options::algebraic | subs_options::no_pattern).series(epsilon==0, 2).normal();
 } catch (exception &p) {
	 cout << "(" << displ.op(0).subs(lst{sign == 0},
									 subs_options::algebraic | subs_options::no_pattern).series(epsilon==0, 2).normal()
		  << ", " << displ.op(1).subs(lst{sign == 0},
									  subs_options::algebraic | subs_options::no_pattern).series(epsilon==0, 2).normal()
		  << ")";
}
cout  math_string << endl
<< wspaces << "For paravector is the same: " <<  displ.is_equal(displn) << endl;

@ f-orthogonality of
<<Infinitesimal cycle calculations>>=
cout << wspaces << "f-orthogonality of Cayley transforms of infinitesimal cycle to other:" << endl << wspaces
	math_string << C11.is_f_orthogonal(cayley_parab(C,sign1), es).series(epsilon==0,3).normal()
	math_string << endl << endl;
}

@
\subsection[Drawing the Asymptote output]{Drawing the \Asymptote\ output}
\label{sec:draw-metap-outp}
Although we use every possibility above to make double and cross
checks one may still wish to see ``by his own eyes'' that the
all calculations are correct. This may be done as follows.

We draw some \Asymptote\ pictures which are included
in~\cite{Kisil05a}, see also Fig.~\ref{fig:example}. We start from
illustration of the both orthogonality relations, see
\S~\ref{sec:orthogonality-cycles} and~\ref{sec:focal-orth-1}.
They are done for nine (\(=3\times 3\)) possible combinations of
metrics (elliptic, parabolic and hyperbolic) for the space of points
and space of cycles.

If \GiNaC\ version allows, we produce all pictures twice: in vector
and paravector formalism.
<<Draw Asymptote pictures>>=
#if GINAC_VERSION_ATLEAST(1,7,1)
for (int is_vector=0; is_vector<2;++is_vector) {
#else
for (int is_vector=1; is_vector<2;++is_vector) {
#endif
	cycle2D C, C1, Z, Z1, real_line, Zinf;
	varidx mu;
	ex e, es;
	ofstream asymptote;
	relational mu_subs;
	if (is_vector==1) {
		C=Cv; C1=Cv1; Z=Zv; Z1=Zv1;
		real_line=real_linev; Zinf=Zvinf;
		e=ev; es=evs;
		asymptote=ofstream("parab-ortho1-v.asy");
		mu=mu2;
		mu_subs=(mu==1);
	} else {
		C=Cp; C1=Cp1; Z=Zp; Z1=Zp1;
		real_line=real_linep;  Zinf=Zpinf;
		e=ep; es=eps;
		asymptote=ofstream("parab-ortho1-p.asy");
		mu=mu1;
		mu_subs=(mu==0);
	}

	P = C.moebius_map(is_vector==1? W : Wbar, e, -M1);
	P1 = C.moebius_map(is_vector==1? lst{u3+u, v3+v} : lst{u3+u, -v3-v}, e, -M1);

	C2 = C1.subject_to(lst{C1.passing(W), C1.is_orthogonal(C, es)});
	C4 = C1.subject_to(lst{C1.passing(W), C1.passing(P), C1.is_linear()});
	u3 = C.center().op(0);
	v3 = C4.roots(u3, false).op(0).normal();
	C5 = cycle2D(lst{u3, -v3*jump_fnct(sign)}, e, C.radius_sq(e, M1)).subs(signs_cube,
                 subs_options::algebraic | subs_options::no_pattern);
	C6 = C1.subject_to(lst{C1.passing(W), C.is_f_orthogonal(C1, eps)});
	C7 = C6.subject_to(lst{C6.is_linear()});
	C8 = real_line.cycle_similarity(C, es, diag_matrix(lst{1, sign1}), diag_matrix(lst{1, jump_fnct(sign)}),
									diag_matrix(lst{1, sign1})).normalize(n*k);


	asymptote << setprecision(2);
	for (si = -1; si < 2; si++) {
		for (si1 = -1; si1 < 2; si1++) {
			sign_val = lst{sign == si, sign1 == si1};

@ For each of those combinations we produce pictures from the set of
data which is almost identical. This help to see the influence of
[[sign]] and [[sign1]] parameters with constant other ones. All those
graphics are mainly application of [[asy_draw()]] method (see
\S~\ref{sec:two-dimens-cycl} mixed with some \Asymptote\ drawing
instructions. Since this is rather technical issue we put it
separately in Appendix~\ref{sec:deta-metap-draw}.
<<Draw Asymptote pictures>>=
try {
	{<<Drawing first orthogonality>>}
	{<<Drawing focal orthogonality>>}
} catch  (exception &p) {
	cerr << "*****       Got a problem with drawing " <<  p.what() << endl;
}
}
}

@ We finish the code with generation of some additional pictures for
the paper~\cite{Kisil05a}.
<<Draw Asymptote pictures>>=
try {
	<<Extra pictures from Asymptote>>
} catch  (exception &p) {
	cerr << "*****       Got a problem with extra drawing " <<  p.what() << endl;
}
asymptote.close();
}

@
\bibliographystyle{plain}
\bibliography{arare,aclifford,abbrevmr,akisil,ageometry,analyse,aphysics}

@
%\fi

@
\appendix

@
{
\let\oldsection=\section
\let\oldsubsection=\subsection
\let\chapter=\oldsection
\let\section=\oldsubsection
\let\subsection=\subsubsection
\input{epal_sw}
}
@
%\ifx\jobname{parab-ortho1}

@
\section{Textual output of the program}
\label{sec:text-outp-progr}

{\obeylines
Conjugation of a cycle comes through Moebius transformation for vectors: true

Conjugation of a cycle comes through Moebius transformation for paravectors: true

A K-orbit is preserved for vectors: true, and  passing (0, t): true
A K-orbit is preserved for paravectors: true, and  passing (0, t): true
\quad Determinant of zero-radius Z1 cycle in metric e is for vector: $- \sigma v^{2}+ v^{2} \breve{\sigma}$
\quad The opposite value for paravector: true
\quad Focus of zero-radius cycle is (vector): ${u,\frac{1}{2}  \sigma v-\frac{1}{2}  v \breve{\sigma}}$
\quad The same value for paravector: true
\quad Centre of zero-radius cycle is (vector): ${u,- \sigma v}$
\quad The same value for paravector: true
\quad Focal length of zero-radius cycle is (vector): $\frac{1}{2}  v$
\quad The same value for paravector: true
Image of the zero-radius cycle under Moebius transform has zero radius vector: true and paravector: true
The centre of the Moebius transformed zero-radius cycle for vector: -equal-, -equal-
The centre of the Moebius transformed zero-radius cycle for paravector: -equal-, -equal-
Image of the zero-radius cycle under cycle similarity has zero radius for vector: true
The centre of the conjugated zero-radius cycle coinsides with Moebius trans for vector: -equal-, -equal-
Image of the zero-radius cycle under cycle similarity has zero radius for paravector: true
The centre of the conjugated zero-radius cycle coinsides with Moebius trans for paravector: -equal-, -equal-

\quad The orthogonality in vectors is: $ \tilde{m} k+2  n \tilde{n} \breve{\sigma}+ \tilde{k} m-2  \tilde{l} l==0$
for paravectors is the same: true
\quad The orthogonality of two lines is: $2  n \tilde{n} \breve{\sigma}-2  \tilde{l} l==0$
\quad The orthogonality to z-r-cycle is: $-2  u l+ u^{2} k+m+2  n v \breve{\sigma}- \sigma v^{2} k==0$
for paravectors is the same: true
\quad The orthogonality of two z-r-cycle is: $- \sigma v^{2}- \chi(\sigma_2) v1^{2}-u1^{2}-2  u u1+2  v v1 \breve{\sigma}+u^{2}==0$
for paravectors is the same: true
Both orthogonal cycles (through one point and through its inverse) are the same for vector: true
Orthogonal cycle passes through the transformed point vector: true

Both orthogonal cycles (through one point and through its inverse) are the same for paravector: true
Orthogonal cycle passes through the transformed point paravector: true

For vectors
\quad Line through point and its inverse is orthogonal: true
\quad All lines come through the point $(\frac{l}{k}, -\frac{ n \breve{\sigma}}{k})$
\quad Conjugated vector is parallel to (u,v): true
For paravectors
\quad Line through point and its inverse is orthogonal: true
\quad All lines come through the point $(\frac{l}{k}, -\frac{ n \breve{\sigma}}{k})$
\quad Conjugated vector is parallel to (u,v): true
For vectors
\quad Ghost cycle has common roots with C : true
\quad $\chi(\sigma)$-centre of ghist cycle is equal to $\breve{\sigma}$-centre of C: true
\quad Inversion in (C-ghost, sign) coincides with inversion in (C, sign1): true
For paravectors
\quad Ghost cycle has common roots with C : true
\quad $\chi(\sigma)$-centre of ghist cycle is equal to $\breve{\sigma}$-centre of C: true
\quad Inversion in (C-ghost, sign) coincides with inversion in (C, sign1): true
For vectors
\quad Inversion to the real line (with - sign): 
\quad Conjugation of the real line is the cycle C: true
\quad Conjugation of the cycle C is the real line: true
\quad Inversion cycle has common roots with C: true
\quad C passing the centre of inversion cycle: true
For paravectors
\quad Inversion to the real line (with - sign): 
\quad Conjugation of the real line is the cycle C: true
\quad Conjugation of the cycle C is the real line: true
\quad Inversion cycle has common roots with C: true
\quad C passing the centre of inversion cycle: true
For vectors
\quad Inversion to the real line (with + sign): 
\quad Conjugation of the real line is the cycle C: true
\quad Conjugation of the cycle C is the real line: true
\quad Inversion cycle has common roots with C: true
\quad C passing the centre of inversion cycle: true
For paravectors
\quad Inversion to the real line (with + sign): 
\quad Conjugation of the real line is the cycle C: true
\quad Conjugation of the cycle C is the real line: true
\quad Inversion cycle has common roots with C: true
\quad C passing the centre of inversion cycle: true
For vectors Yaglom inversion of the second kind is three reflections in the cycles: true
For paravectors Yaglom inversion of the second kind is three reflections in the cycles: true

For vectors\quad The real line is Moebius invariant: true
For paravectors\quad The real line is Moebius invariant: true
Reflection in the real line (vector): $(1, {\left(\begin{array}{cc}u&- v\end{array}\right)}_{{symbol4262} }, - \sigma v^{2}+u^{2})$
\quad for paravector is the same: true
Reflection of the real line in cycle C (vectors): 
$(2  n \chi(\sigma_2) \chi(\sigma_3) k \breve{\sigma}, {\left(\begin{array}{cc}2  n \chi(\sigma_2) \chi(\sigma_3) l \breve{\sigma}&- \chi(\sigma_2) k m+ n^{2} \chi(\sigma_2) \breve{\sigma}+ \chi(\sigma_2) l^{2}\end{array}\right)}_{{symbol4443} }, 2  n \chi(\sigma_2) \chi(\sigma_3) m \breve{\sigma})$
\quad for paravectors is the same: true
The f-orthogonality is (vectors): $ \chi(\sigma_2) \tilde{n} l^{2}+ n \chi(\sigma_2) \tilde{k} m-2  n \chi(\sigma_2) \tilde{l} l+ n^{2} \chi(\sigma_2) \tilde{n} \breve{\sigma}- \chi(\sigma_2) k m \tilde{n}+ n \chi(\sigma_2) \tilde{m} k==0$
\quad for paravectors is the same: true
\quad The f-orthogonality of two lines is (vectors): $ \chi(\sigma_2) \tilde{n} l^{2}-2  n \chi(\sigma_2) \tilde{l} l+ n^{2} \chi(\sigma_2) \tilde{n} \breve{\sigma}==0$
\quad for paravectors is the same: true
\quad The f-orthogonality to z-r-cycle is first way (vectors): 
$ n u^{2} \chi(\sigma_2) k+ n^{2} \chi(\sigma_2) v \breve{\sigma}- n \chi(\sigma_2) v^{2} k \breve{\sigma}-2  n u \chi(\sigma_2) l+ \chi(\sigma_2) v l^{2}+ n \chi(\sigma_2) m- \chi(\sigma_2) v k m==0$
\quad for paravectors is the same: true
\quad The f-orthogonality to z-r-cycle in second way (vectors): 
$ \chi(\sigma_2) v m+2  n \chi(\sigma_2) v^{2} \breve{\sigma}- \chi(\sigma_2) v^{3} k \breve{\sigma}+ u^{2} \chi(\sigma_2) v k-2  u \chi(\sigma_2) v l==0$
\quad for paravectors is the same: true
\quad The f-orthogonality of two z-r-cycle is (vectors): 
$2  \chi(\sigma_2) v^{2} v1 \breve{\sigma}-2  u \chi(\sigma_2) u1 v- \sigma \chi(\sigma_2) v v1^{2}- \chi(\sigma_2) v^{3} \breve{\sigma}+ \chi(\sigma_2) u1^{2} v+ u^{2} \chi(\sigma_2) v==0$
\quad for paravectors is the same: true
\quad For vectors all lines come through the focus related $\breve{e}$: true
\quad For paravectors all lines come through the focus related $\breve{e}$: true
For vectors
\quad f-ghost cycle has common roots with C: true
\quad $\chi(\sigma)$-center of f-ghost cycle coincides with $\breve{\sigma}$-focus of C : true
\quad f-inversion in C coincides with inversion in f-ghost cycle: true
For paravectors
\quad f-ghost cycle has common roots with C: true
\quad $\chi(\sigma)$-center of f-ghost cycle coincides with $\breve{\sigma}$-focus of C : true
\quad f-inversion in C coincides with inversion in f-ghost cycle: true

For vectors
\quad Distance between (u,v) and (u',v') in elliptic and hyperbolic spaces is 
\(\displaystyle \frac{ {(4  v v1 {(-1+ \sigma \breve{\sigma})}+ \breve{\sigma} {( \sigma {(v-v1)}^{2}-{(u-u1)}^{2})})} {( \sigma {(v-v1)}^{2}-{(u-u1)}^{2})}}{ {(u-u1)}^{2} \breve{\sigma}-{(v-v1)}^{2}}\): true
\quad Conformity in a cycle space with metric:   E      P      H 
\quad Point space is Elliptic case (sign = -1):  true false false
\quad Point space is Hyperbolic case (sign = 1):  false false true
\quad Perpendicular to ((u,v); (u',v')) is: $\frac{1}{2} \frac{ \sigma v1^{3}-2  u u1 v-2  \sigma u1^{2} v1 \breve{\sigma}+ u1^{2} v1+3  \sigma v^{2} v1-2  u u1 v1- \sigma v^{3}+ u1^{2} v+ u^{2} v1-3  \sigma v v1^{2}-2  u^{2} \sigma v1 \breve{\sigma}+ u^{2} v+4  u \sigma u1 v1 \breve{\sigma}}{2  u u1 \breve{\sigma}+v1^{2}-2  v v1+v^{2}- u1^{2} \breve{\sigma}- u^{2} \breve{\sigma}}$; $\frac{1}{2} \frac{ \sigma u1 v1^{2} \breve{\sigma}+2  u v1^{2}+ u1^{3} \breve{\sigma}+ u \sigma v^{2} \breve{\sigma}- u^{3} \breve{\sigma}- \sigma u1 v^{2} \breve{\sigma}-2  u v v1-2  u1 v1^{2}+3  u^{2} u1 \breve{\sigma}- u \sigma v1^{2} \breve{\sigma}-3  u u1^{2} \breve{\sigma}+2  u1 v v1}{2  u u1 \breve{\sigma}+v1^{2}-2  v v1+v^{2}- u1^{2} \breve{\sigma}- u^{2} \breve{\sigma}}$

\quad Value at the middle point (parabolic point space):
\quad $u1^{2}-2  u u1+u^{2}$
\quad Conformity in a cycle space with metric:   E      P      H 
\quad Point space is Parabolic case (sign = 0):  true true true
\quad Perpendicular to ((u,v); (u',v')) is: $ \sigma v1$; $\frac{1}{2} u-\frac{1}{2} u1$

For paravectors
\quad Distance between (u,v) and (u',v') in elliptic and hyperbolic spaces is 
\(\displaystyle \frac{ {(4  v v1 {(-1+ \sigma \breve{\sigma})}+ \breve{\sigma} {( \sigma {(v-v1)}^{2}-{(u-u1)}^{2})})} {( \sigma {(v-v1)}^{2}-{(u-u1)}^{2})}}{ {(u-u1)}^{2} \breve{\sigma}-{(v-v1)}^{2}}\): true
\quad Conformity in a cycle space with metric:   E      P      H 
\quad Point space is Elliptic case (sign = -1):  true false false
\quad Point space is Hyperbolic case (sign = 1):  false false true
\quad Perpendicular to ((u,v); (u',v')) is: $\frac{1}{2} \frac{ \sigma v1^{3}-2  u u1 v-2  \sigma u1^{2} v1 \breve{\sigma}+ u1^{2} v1+3  \sigma v^{2} v1-2  u u1 v1- \sigma v^{3}+ u1^{2} v+ u^{2} v1-3  \sigma v v1^{2}-2  u^{2} \sigma v1 \breve{\sigma}+ u^{2} v+4  u \sigma u1 v1 \breve{\sigma}}{2  u u1 \breve{\sigma}+v1^{2}-2  v v1+v^{2}- u1^{2} \breve{\sigma}- u^{2} \breve{\sigma}}$; $\frac{1}{2} \frac{ \sigma u1 v1^{2} \breve{\sigma}+2  u v1^{2}+ u1^{3} \breve{\sigma}+ u \sigma v^{2} \breve{\sigma}- u^{3} \breve{\sigma}- \sigma u1 v^{2} \breve{\sigma}-2  u v v1-2  u1 v1^{2}+3  u^{2} u1 \breve{\sigma}- u \sigma v1^{2} \breve{\sigma}-3  u u1^{2} \breve{\sigma}+2  u1 v v1}{2  u u1 \breve{\sigma}+v1^{2}-2  v v1+v^{2}- u1^{2} \breve{\sigma}- u^{2} \breve{\sigma}}$

\quad Value at the middle point (parabolic point space):
\quad $u1^{2}-2  u u1+u^{2}$
\quad Conformity in a cycle space with metric:   E      P      H 
\quad Point space is Parabolic case (sign = 0):  true true true
\quad Perpendicular to ((u,v); (u',v')) is: $ \sigma v1$; $\frac{1}{2} u-\frac{1}{2} u1$

For vectors distance between (u,v) and (u',v') (value at critical point): 
\quad $-\frac{2  u u1 \breve{\sigma}-4 v^{2}- u1^{2} \breve{\sigma}+4  \sigma v^{2} \breve{\sigma}- u^{2} \breve{\sigma}}{\breve{\sigma}}$

\quad  for paravector is the same: true
For vectors
\quad Length from *center* between (u,v) and $(u^\prime,v^\prime)$:
\quad $\frac{ u1^{2} \mathring{\sigma}^{2}-2  u u1 \mathring{\sigma}^{2}- \sigma v1^{2} \mathring{\sigma}^{2}- v^{2} \breve{\sigma}+ u^{2} \mathring{\sigma}^{2}+2  v v1 \mathring{\sigma}}{\mathring{\sigma}^{2}}$
\quad This distance/length is conformal: true
\quad Perpendicular to ((u,v); (u',v')) is: $\frac{ \sigma v1 \mathring{\sigma}-v}{\mathring{\sigma}}$; $u-u1$

Length from *focus* check for $p =  {(\sqrt{ {(u-u1)}^{2} \mathring{\sigma}+{(v-v1)}^{2}- \sigma v1^{2} \mathring{\sigma}}+v-v1)} \mathring{\sigma}$
\quad Length between (u,v) and (u', v') is equal to \((\mathring(\sigma)-\breve{\sigma})p^2-2vp\): true
\quad checks: C11 passes through (u', v'): true; C11 focus is at (u, v): true
\quad This distance/length is conformal: true
\quad Perpendicular to ((u,v); (u',v')) is \((\sigma v'+p, u-u')\): true

Length from *focus* check for $p = - \mathring{\sigma} {(\sqrt{ {(u-u1)}^{2} \mathring{\sigma}+{(v-v1)}^{2}- \sigma v1^{2} \mathring{\sigma}}-v+v1)}$
\quad Length between (u,v) and (u', v') is equal to \((\mathring(\sigma)-\breve{\sigma})p^2-2vp\): true
\quad checks: C11 passes through (u', v'): true; C11 focus is at (u, v): true
\quad This distance/length is conformal: true
\quad Perpendicular to ((u,v); (u',v')) is \((\sigma v'+p, u-u')\): true

Shall be `false' for conformality below
Length from *focus* check for $p = \frac{1}{2} \frac{ \sigma v1^{2}-{(u-u1)}^{2}}{v-v1}$
\quad Length between (u,v) and (u', v') is equal to \((\mathring(\sigma)-\breve{\sigma})p^2-2vp\): true
\quad checks: C11 passes through (u', v'): true; C11 focus is at (u, v): true
\quad This distance/length is conformal: false. The factor is: 
\quad $\frac{y^{2}}{{( y d^{2}+ \sigma y c^{2} v^{2}+ u^{2} y c^{2}+2  u y c d-2  u c^{2} v x-2  c v d x)}^{2}}$
\quad Perpendicular to ((u,v); (u',v')) is \((\sigma v'+p, u-u')\): true

For paravectors
\quad Length from *center* between (u,v) and $(u^\prime,v^\prime)$:
\quad $\frac{ u1^{2} \mathring{\sigma}^{2}-2  u u1 \mathring{\sigma}^{2}- \sigma v1^{2} \mathring{\sigma}^{2}- v^{2} \breve{\sigma}+ u^{2} \mathring{\sigma}^{2}+2  v v1 \mathring{\sigma}}{\mathring{\sigma}^{2}}$
\quad This distance/length is conformal: true
\quad Perpendicular to ((u,v); (u',v')) is: $\frac{ \sigma v1 \mathring{\sigma}-v}{\mathring{\sigma}}$; $u-u1$

Length from *focus* check for $p =  {(\sqrt{ {(u-u1)}^{2} \mathring{\sigma}+{(v-v1)}^{2}- \sigma v1^{2} \mathring{\sigma}}+v-v1)} \mathring{\sigma}$
\quad Length between (u,v) and (u', v') is equal to \((\mathring(\sigma)-\breve{\sigma})p^2-2vp\): true
\quad checks: C11 passes through (u', v'): true; C11 focus is at (u, v): true
\quad This distance/length is conformal: true
\quad Perpendicular to ((u,v); (u',v')) is \((\sigma v'+p, u-u')\): true

Length from *focus* check for $p = - \mathring{\sigma} {(\sqrt{ {(u-u1)}^{2} \mathring{\sigma}+{(v-v1)}^{2}- \sigma v1^{2} \mathring{\sigma}}-v+v1)}$
\quad Length between (u,v) and (u', v') is equal to \((\mathring(\sigma)-\breve{\sigma})p^2-2vp\): true
\quad checks: C11 passes through (u', v'): true; C11 focus is at (u, v): true
\quad This distance/length is conformal: true
\quad Perpendicular to ((u,v); (u',v')) is \((\sigma v'+p, u-u')\): true

Shall be `false' for conformality below
Length from *focus* check for $p = \frac{1}{2} \frac{ \sigma v1^{2}-{(u-u1)}^{2}}{v-v1}$
\quad Length between (u,v) and (u', v') is equal to \((\mathring(\sigma)-\breve{\sigma})p^2-2vp\): true
\quad checks: C11 passes through (u', v'): true; C11 focus is at (u, v): true
\quad This distance/length is conformal: false. The factor is: 
\quad $\frac{y^{2}}{{( y d^{2}+ \sigma y c^{2} v^{2}+ u^{2} y c^{2}+2  u y c d-2  u c^{2} v x-2  c v d x)}^{2}}$
\quad Perpendicular to ((u,v); (u',v')) is \((\sigma v'+p, u-u')\): true

\quad Inf cycle is: $(1, {\left(\begin{array}{cc}u&\frac{v_p}{\mathring{\sigma}-\breve{\sigma}}-\frac{\sqrt{v_p^{2}+ \epsilon^{2} \mathring{\sigma}- \epsilon^{2} \breve{\sigma}}}{\mathring{\sigma}-\breve{\sigma}}\end{array}\right)}^{{symbol6306} }, -\frac{ \breve{\sigma} {(\sqrt{v_p^{2}+ \epsilon^{2} {(\mathring{\sigma}-\breve{\sigma})}}-v_p)}^{2}}{{(\mathring{\sigma}-\breve{\sigma})}^{2}}-\epsilon^{2}+u^{2})$
\quad For paravector is the same: true
\quad Square of radius of the infinitesimal cycle is: $\epsilon^{2}$
\quad For paravector is the same: true
\quad Focus of infinitesimal cycle is: ${u,v_p}$
\quad For paravector is the same: true
\quad Focal length is: ${(-\frac{1}{4} \frac{1}{v_p})} \epsilon^{2}+\mathcal{O}(\epsilon^{3})$
\quad For paravector is the same: true
\quad Infinitesimal cycle (vector) passing points$(u+ \epsilon x, vp+{(- x^{2} v_p)}+{(-\frac{1}{4} \frac{ \mathring{\sigma} x^{2}- x^{2} \breve{\sigma}-\mathring{\sigma}}{v_p})} \epsilon^{2}+\mathcal{O}(\epsilon^{3})), $
\quad Infinitesimal cycle (paravector) passing points$(u+ \epsilon x, vp+{(- x^{2} v_p)}+{(-\frac{1}{4} \frac{ \mathring{\sigma} x^{2}- x^{2} \breve{\sigma}-\mathring{\sigma}}{v_p})} \epsilon^{2}+\mathcal{O}(\epsilon^{3})), $
\quad Image under SL2(R) of infinitesimal cycle has radius squared: 
${(-\frac{4  \mathring{\sigma} \breve{\sigma}-\breve{\sigma}^{2}-6  \mathring{\sigma}^{2} \breve{\sigma}^{2}-\mathring{\sigma}^{4}+4  \mathring{\sigma}^{3} \breve{\sigma}}{{(2  u c d \breve{\sigma}^{2}+ u^{2} c^{2} \breve{\sigma}^{2}-2  d^{2} \mathring{\sigma} \breve{\sigma}+ u^{2} c^{2} \mathring{\sigma}^{2}+2  u c d \mathring{\sigma}^{2}-4  u c d \mathring{\sigma} \breve{\sigma}-2  u^{2} c^{2} \mathring{\sigma} \breve{\sigma}+ d^{2} \breve{\sigma}^{2}+ d^{2} \mathring{\sigma}^{2})}^{2}})} \epsilon^{2}+\mathcal{O}(\epsilon^{3})$
\quad For paravector is the same: true
\quad Image under cycle similarity of infinitesimal cycle has radius squared: 
${(\frac{ n^{4} \breve{\sigma}^{2}+8  k m \mathring{\sigma}^{3} l^{2} \breve{\sigma}+ n^{4} \mathring{\sigma}^{4} \breve{\sigma}^{2}-2  n^{2} \mathring{\sigma}^{4} l^{2} \breve{\sigma}-4  n^{4} \mathring{\sigma} \breve{\sigma}-8  n^{2} k m \mathring{\sigma} \breve{\sigma}^{2}+6  k^{2} m^{2} \mathring{\sigma}^{2} \breve{\sigma}^{2}-2  k m l^{2} \breve{\sigma}^{2}-12  n^{2} \mathring{\sigma}^{2} l^{2} \breve{\sigma}+6  \mathring{\sigma}^{2} l^{4} \breve{\sigma}^{2}-4  k^{2} m^{2} \mathring{\sigma}^{3} \breve{\sigma}+2  n^{2} k m \mathring{\sigma}^{4} \breve{\sigma}+8  k m \mathring{\sigma} l^{2} \breve{\sigma}+ k^{2} m^{2} \breve{\sigma}^{2}+ l^{4} \breve{\sigma}^{2}+ k^{2} m^{2} \mathring{\sigma}^{4}-4  n^{4} \mathring{\sigma}^{3} \breve{\sigma}+8  n^{2} \mathring{\sigma}^{3} l^{2} \breve{\sigma}^{2}-4  \mathring{\sigma}^{3} l^{4} \breve{\sigma}-2  k m \mathring{\sigma}^{4} l^{2}+6  n^{4} \mathring{\sigma}^{2} \breve{\sigma}^{2}-2  n^{2} l^{2} \breve{\sigma}-12  k m \mathring{\sigma}^{2} l^{2} \breve{\sigma}^{2}+12  n^{2} k m \mathring{\sigma}^{2} \breve{\sigma}-4  k^{2} m^{2} \mathring{\sigma} \breve{\sigma}-4  \mathring{\sigma} l^{4} \breve{\sigma}+8  n^{2} \mathring{\sigma} l^{2} \breve{\sigma}^{2}+ \mathring{\sigma}^{4} l^{4}+2  n^{2} k m \breve{\sigma}-8  n^{2} k m \mathring{\sigma}^{3} \breve{\sigma}^{2}}{{(2  n^{2} \mathring{\sigma} \breve{\sigma}^{2}+4  u k \mathring{\sigma} l \breve{\sigma}-2  u k \mathring{\sigma}^{2} l-2  \mathring{\sigma} l^{2} \breve{\sigma}- n^{2} \mathring{\sigma}^{2} \breve{\sigma}-2  u^{2} k^{2} \mathring{\sigma} \breve{\sigma}+ \mathring{\sigma}^{2} l^{2}+ u^{2} k^{2} \breve{\sigma}^{2}- n^{2} \breve{\sigma}+ l^{2} \breve{\sigma}^{2}+ u^{2} k^{2} \mathring{\sigma}^{2}-2  u k l \breve{\sigma}^{2})}^{2}})} \epsilon^{2}+\mathcal{O}(\epsilon^{3})$
\quad For paravector is the same: true
\quad Focus of the transormed cycle is from transformation of focus by: ${(\left(\begin{array}{c}0\\0\end{array}\right))}+{(\left(\begin{array}{c}0\\0\end{array}\right))} \epsilon+\mathcal{O}(\epsilon^{2})$
\quad Orthogonality (leading term) to infinitesimal cycle is:
\quad ${(-2  u l+ u^{2} k+m==0)}+\mathcal{O}(\epsilon)$
\quad f-orthogonality of other cycle to infinitesimal:
\quad ${(-2  n u l+ n u^{2} k+ n m==0)}+\mathcal{O}(\epsilon)$
f-orthogonality of infinitesimal cycle to other:
\quad ${(0==0)}+{(0==0)} \epsilon+{(\frac{1}{2}  (\frac{2  u l+2  n v_p- u^{2} k-m}{v_p}==0))} \epsilon^{2}+\mathcal{O}(\epsilon^{3})$
\quad Det of Cayley-transformed infinitesimal cycle: ${(-\frac{1+ u^{2} \breve{\sigma}-v_p}{v_p})} \epsilon^{2}+\mathcal{O}(\epsilon^{3})$
\quad Focus of the Cayley-transformed infinitesimal cycle displaced by: $(\mathcal{O}(\epsilon^{2}), \mathcal{O}(\epsilon^{2}))$
\quad For paravector is the same: true
\quad f-orthogonality of Cayley transforms of infinitesimal cycle to other:
\quad ${(0==0)}+{(0==0)} \epsilon+{(\frac{1}{2}  (\frac{2  u l+2  n v_p- u^{2} k-m}{v_p}==0))} \epsilon^{2}+\mathcal{O}(\epsilon^{3})$

\quad Inf cycle is: $(1, {\left(\begin{array}{cc}u&\frac{1}{2} \frac{\epsilon^{2}}{v_p}\end{array}\right)}^{{symbol17875} }, -\frac{1}{4} \frac{ \epsilon^{4} \breve{\sigma}}{v_p^{2}}-\epsilon^{2}+u^{2})$
\quad For paravector is the same: true
\quad Square of radius of the infinitesimal cycle is: $\epsilon^{2}$
\quad For paravector is the same: true
\quad Focus of infinitesimal cycle is: ${u,- v_p}$
\quad For paravector is the same: true
\quad Focal length is: ${(\frac{1}{4} \frac{1}{v_p})} \epsilon^{2}$
\quad For paravector is the same: true
\quad Infinitesimal cycle (vector) passing points$(u+ \epsilon x, vp+{( x^{2} v_p-2 v_p)}+{(-\frac{1}{4} \frac{\breve{\sigma}}{v_p})} \epsilon^{2}), $
\quad Infinitesimal cycle (paravector) passing points$(u+ \epsilon x, vp+{( x^{2} v_p-2 v_p)}+{(-\frac{1}{4} \frac{\breve{\sigma}}{v_p})} \epsilon^{2}), $
\quad Image under SL2(R) of infinitesimal cycle has radius squared: 
${(\frac{1}{{( u^{2} c^{2}+2  u c d+d^{2})}^{2}})} \epsilon^{2}+\mathcal{O}(\epsilon^{3})$
\quad For paravector is the same: true
\quad Image under cycle similarity of infinitesimal cycle has radius squared: 
${(\frac{ n^{4} \breve{\sigma}^{2}+ k^{2} m^{2}-2  k m l^{2}+l^{4}-2  n^{2} l^{2} \breve{\sigma}+2  n^{2} k m \breve{\sigma}}{{( u^{2} k^{2}+l^{2}-2  u k l- n^{2} \breve{\sigma})}^{2}})} \epsilon^{2}+\mathcal{O}(\epsilon^{3})$
\quad For paravector is the same: true
\quad Focus of the transormed cycle is from transformation of focus by: ${(\left(\begin{array}{c}0\\-2 \frac{v_p}{ u^{2} c^{2}+2  u c d+d^{2}}\end{array}\right))}+{(\left(\begin{array}{c}0\\0\end{array}\right))} \epsilon+\mathcal{O}(\epsilon^{2})$
\quad Orthogonality (leading term) to infinitesimal cycle is:
\quad ${(-2  u l+ u^{2} k+m==0)}+\mathcal{O}(\epsilon)$
\quad f-orthogonality of other cycle to infinitesimal:
\quad ${(-2  n u l+ n u^{2} k+ n m==0)}+\mathcal{O}(\epsilon)$
f-orthogonality of infinitesimal cycle to other:
\quad ${(0==0)}+{(0==0)} \epsilon+{(\frac{1}{2}  (-\frac{2  u l-2  n v_p- u^{2} k-m}{v_p}==0))} \epsilon^{2}+\mathcal{O}(\epsilon^{3})$
\quad Det of Cayley-transformed infinitesimal cycle: ${(\frac{1+ u^{2} \breve{\sigma}+v_p}{v_p})} \epsilon^{2}+\mathcal{O}(\epsilon^{3})$
\quad Focus of the Cayley-transformed infinitesimal cycle displaced by: ${(\left(\begin{array}{c}0\\-2  v_p\end{array}\right))}+{(\left(\begin{array}{c}0\\0\end{array}\right))} \epsilon+\mathcal{O}(\epsilon^{2})$
\quad For paravector is the same: true
\quad f-orthogonality of Cayley transforms of infinitesimal cycle to other:
\quad ${(0==0)}+{(0==0)} \epsilon+{(\frac{1}{2}  (-\frac{2  u l-2  n v_p- u^{2} k-m}{v_p}==0))} \epsilon^{2}+\mathcal{O}(\epsilon^{3})$




}

@
%\fi
@
\section{Example of the produced graphics}
\label{sec:example-prod-graph}
An example of graphics generated by the program is given in
Figure~\ref{fig:example}.
%\ifx\jobname{parab-ortho1}
This was produced by the part of program
from the Section~\ref{sec:first-orth-cond}.
%fi
\begin{figure}[htbp]
  \includegraphics[scale=.9]{first-ort-ee.eps}\hfill
  \includegraphics[scale=.9]{first-ort-ep.eps}\hfill
  \includegraphics[scale=.9]{first-ort-eh.eps}\\[4mm]
  \includegraphics[scale=.9]{first-ort-pe.eps}\hfill
  \includegraphics[scale=.9]{first-ort-pp.eps}\hfill
  \includegraphics[scale=.9]{first-ort-ph.eps}\\[4mm]
  \includegraphics[scale=.9]{first-ort-he.eps}\hfill
  \includegraphics[scale=.9]{first-ort-hp.eps}\hfill
  \includegraphics[scale=.9]{first-ort-hh.eps}
  \caption[Orthogonality of the first kind]{Orthogonality of the first
    kind in nine combinations.}
\label{fig:example}
\end{figure}


@
%\ifx\jobname{parab-ortho1}

@
\section[Details of the Asymptote Drawing]{Details of the \Asymptote\ Drawing}
\label{sec:deta-metap-draw}


\subsection{Drawing Orthogonality Conditions}
\label{sec:draw-orth-cond}


\subsubsection{First Orthogonality Condition}
\label{sec:first-orth-cond}

We define numeric values of all involved parameters first.%'
<<Drawing first orthogonality>>=
numeric xmin(-11,4), xmax(5), ymin(-3), ymax = (si == 0?numeric(25, 4): 4);
lst cycle_val = lst{sign == numeric(si), sign1 == numeric(si1),
					k == numeric(2,3), l == numeric(2,3), n == (si == 1?numeric(-1):numeric(1,2)), m ==numeric(-2)};
cycle2D Cf = C.subs(cycle_val), Cg = C5.subs(cycle_val), Cq =C2;
lst U, V;

@ We use various initial data for various geometries.
<<Drawing first orthogonality>>=
switch (si) {
case -1: // points b, a, center, c, d
	U = {numeric(11,4), Cg.roots(half).op(0), Cf.center().op(0).subs(cycle_val), (l/k).subs(cycle_val)};
	V = {Cf.roots(U.op(0), false).op(1), half, Cf.center().op(1).subs(cycle_val),
		 C4.roots(l/k, false).op(0).normal().subs(cycle_val)};
	break;
case 0:
	U = {numeric(17,4), Cg.roots().op(0), Cf.center().op(0).subs(cycle_val), (l/k).subs(cycle_val)};
	V = {Cf.roots(U.op(0), false).op(0), numeric(3,2), Cf.roots(l/k, false).op(0).subs(cycle_val),
		 C4.roots(l/k, false).op(0).normal().subs(cycle_val)};
	break;
case 1:
	U = {numeric(12,4), Cg.roots(numeric(3,4)).op(0), Cf.center().op(0).subs(cycle_val), (l/k).subs(cycle_val)};
	V = {Cf.roots(U.op(0), false).op(0), numeric(3,4), Cf.center().op(1).subs(cycle_val),
		 C4.roots(l/k, false).op(0).normal().subs(cycle_val)};
	break;
}

@ Moebius transform of the first point.
<<Drawing first orthogonality>>=
U.append(P.op(0).subs(cycle_val).subs(lst{u == U.op(0), v == V.op(0)}).normal());
V.append(P.op(1).subs(cycle_val).subs(lst{u == U.op(0), v == V.op(0)}).normal());

asymptote << endl <<  "erase();"  << endl <<  "size(175);"  << endl;
<<Drawing orthogonal cycles>>
asymptote << "shipout(\"first-ort-" << eph_names[si+1] << eph_names[si1+1] << "\");" << endl;

@ We start drawing from cycles.
<<Drawing orthogonal cycles>>=
for (int j = 0; j<2; j++)
	for (int i=0; i<(si==1?4:5); i++)
		Cq.subs(lst{k1 == (si == 0? numeric(3*i,2): numeric(i, 4)), n1 == half, u == U.op(j),
					v == V.op(j)}).subs(cycle_val).asy_draw(asymptote, xmin, xmax, ymin, ymax,
															lst{0.2, 0.2+j*(0.3+i/8.0), 0.2+(1-j)*(0.3+i/8.0)});

Cf.asy_draw(asymptote, xmin, xmax, ymin, ymax, lst{0.8, 0, 0}, "1");
Cg.asy_draw(asymptote, xmin, xmax, ymin, ymax, lst{0, 0, 0}, "0.3+dashed");
if (si == 0)
 C5.subs(lst{sign ==0, sign1==0}).subs(cycle_val).asy_draw(asymptote, xmin, xmax, ymin, ymax, lst{0, 0, 0},
                 "dotted");

@ To finish we add some additional drawing explaining the picture.
<<Drawing orthogonal cycles>>=
asymptote << "pair[] z={(" << ex_to<numeric>(U.op(0).evalf()).to_double() << ", "
 << ex_to<numeric>(V.op(0).evalf()).to_double() << ")";
 for (int j = 1; j<5; j++)
	 asymptote << ", (" << ex_to<numeric>(U.op(j).evalf()).to_double() << ", "
			   << ex_to<numeric>(V.op(j).evalf()).to_double() << ")" ;


asymptote << "};" << endl    << "  dot(z);" << endl
 << (si == 0? "  draw((z[2].x,0)--z[2], 0.3+dotted);" : "") << endl
 << (si == 0? "  draw((z[3].x,0)--z[3], 0.3+dotted);" : "") << endl
 << "  label(\"$a$\", z[1], NW);" << endl
   << "  label(\"$b$\", z[0], SE);" << endl
  << "  label(\"$c$\", z[3], E);" << endl
   << "  label" << "(\"$d$\", z[4], " << (si ==1?"NW);":"NE);") << endl;

<<Put units>>
<<Draw axes>>

@ This chunk draws the standard coordinat axes.
<<Draw axes>>=
asymptote << "  draw_axes((" << xmin.to_double() << ", " << ymin.to_double()
 << "), ( " << xmax.to_double() << ", " << ymax.to_double() << "));" << endl;

@
<<Put units>>=
asymptote  << "  label(\"$\\sigma=" << si << ", \\breve{\\sigma}=" << si1
  << "$\", (0, " << ymin.to_double() << "), S);" << endl << "draw((1,-0.1)--(1,0.1));" << endl
  << "draw((-0.1,1)--(0.1,1));" << endl
  << "label(\"$1$\", (1,0), S);" << endl
  << "label(\"$1$\", (0,1), E);" << endl;

@
\subsubsection{Focal Orthogonality Condition}
\label{sec:focal-orth-cond}

We draw some \Asymptote\ pictures to illustrate the focal orthogonality
relation. We define numeric values of all involved parameters first.

<<Drawing focal orthogonality>>=
numeric xmin(-11,4), xmax(5), ymin(-13,4), ymax = (si == 0?numeric(6): numeric(15,4));
lst cycle_val = lst{sign == numeric(si), sign1 == numeric(si1), sign2 == numeric(1), //sign3 == jump_fnct(-si), //sign3 == (si > 0?numeric(-1):numeric(1)),
     k == numeric(2,3), l == numeric(2,3), n == (si == 1?numeric(-4,3):half), m ==(si == 1?numeric(-9,3):numeric(-2))};
cycle2D Cf = C.subs(cycle_val), Cg = C8.subs(cycle_val), Cq =C6;
lst U, V;

@ We use various initial data for various geometries.
<<Drawing focal orthogonality>>=
switch (si) {
case -1: // points b, a, center, c, d
	U = {numeric(11,4), Cg.roots(half).op(0), Cf.focus().op(0).subs(cycle_val), (l/k).subs(cycle_val)};
	V = {Cf.roots(U.op(0), false).op(1), half, Cf.focus().op(1).subs(cycle_val),
		 C7.roots(l/k, false).op(0).normal().subs(cycle_val)};
	break;
case 0:
	U = {numeric(4), Cf.roots().op(0), Cf.focus().op(0).subs(cycle_val), (l/k).subs(cycle_val)};
	V = {Cf.roots(U.op(0), false).op(0), numeric(3,2), Cf.focus().op(0).subs(cycle_val),
		 C7.roots(l/k, false).op(0).normal().subs(cycle_val)};
	break;
case 1:
	U = {Cf.roots(numeric(1)).op(1), Cg.roots(numeric(6, 4)).op(1),
		 Cf.focus().op(0).subs(cycle_val), (l/k).subs(cycle_val)};
	V = {numeric(1), numeric(6, 4), Cf.focus().op(1).subs(cycle_val),
		 C7.roots(l/k, false).op(0).normal().subs(cycle_val)};
	break;
}

@ Moebius transform of [[P1]].
<<Drawing focal orthogonality>>=
U.append(P1.op(0).subs(cycle_val).subs(lst{u == U.op(0), v == V.op(0)}).normal()); // Moebius transform of [[U.op(0)]]
V.append(P1.op(1).subs(cycle_val).subs(lst{u == U.op(0), v == V.op(0)}).normal());

asymptote << endl << "erase();" << endl << "size(175);" << endl;
<<Drawing orthogonal cycles>>
asymptote << "shipout(\"sec-ort-" << eph_names[si+1] << eph_names[si1+1] << "\");" << endl;

@
\subsection[Extra pictures from Asymptote]{Extra pictures from \Asymptote}
\label{sec:extra-pictures-from}
We draw few more pictures in \Asymptote.
<<Extra pictures from Asymptote>>=
 numeric xmin(-5), xmax(5), ymin(-13,4), ymax = numeric(6);
 <<Three images of the same cycle>>
 <<Centres and foci of parabolas>>
 <<Zero-radius cycle implementations>>
 <<Parabolic diameters>>
 <<Distance as an extremum>>
 <<Infinitesimal cycles draw>>
 <<Cayley transform pictures>>
 <<Three inversions>>
 <<Hyperbolic inversion of a ball>>

@
\subsubsection{Different implementations of the same cycle}
\label{sec:diff-impl-same}

A cycle represented by a four numbers \((k, l, n, m\) looks
different in three spaces with different metrics.
<<Three images of the same cycle>>=
asymptote << endl << "erase();" << endl << "size(250);" << endl;
cycle2D C1f, C2f;
asymptote << "pair[] z;";
for (int j = -1; j<2; j++) {
 C1f = cycle2D(1, lst{-2.5, 1}, 3.75, diag_matrix(lst{-1, j}));
 C2f = cycle2D(1, lst{2.75, 3}, 14.0625, diag_matrix(lst{-1, j}));
 C1f.asy_draw(asymptote, xmin, xmax, ymin, ymax, lst{0, 1.0-0.4*(j+1), 0.4*(j+1)}, ".75", true, 7);
 C2f.asy_draw(asymptote, xmin, xmax, ymin, ymax, lst{0, 1.0-0.4*(j+1), 0.4*(j+1)}, ".75", true, 7);
 asymptote << "z.push((" << C1f.center().op(0) << ", "  << C1f.center().op(1) << ")); z.push(("
     << C2f.center().op(0) << ", "  << C2f.center().op(1) << "));" << endl;
}
asymptote << "z.push((" << C1f.roots().op(0) << ", 0));  z.push((" << C1f.roots().op(1) << ", 0));" << endl
  << " dot(z);" << endl
  << "  for (int j = 0; j<2; ++j) {"
  << "    label(\"$c_e$\", z[j], E);" << endl
  << "    label(\"$c_p$\", z[j+2], SE);" << endl
  << "    label(\"$c_h$\", z[j+4], E);" << endl
  << "    label((j==0?\"$r_0$\":\"$r_1$\"), z[j+6], (j==0? SW: SE));" << endl
  << "    draw(z[j]--z[j+4], .3+dashed);" << endl
  << "  }" << endl;
<<Draw axes>>
asymptote << "shipout(\"same-cycle\");" << endl;

@
\subsubsection{Centres and foci of cycles}
\label{sec:centres-foci-cycles}

We draw two parabolas and their centres with three type of foci.
<<Centres and foci of parabolas>>=
asymptote << endl << "erase();" << endl << "size(250);" << endl;
C1f = cycle2D(1, lst{-1.5, 2}, 3.75, par_matr);
C2f = cycle2D(1, lst{2, 2}, -3.5, par_matr);
C1f.asy_draw(asymptote, xmin, xmax, ymin, ymax, lst{0, 1.0-0.4, 0.4}, ".75", true, 7);
C2f.asy_draw(asymptote, xmin, xmax, ymin, ymax, lst{0, 1.0-0.4, 0.4}, ".75", true, 7);

asymptote << "pair[] z= {(" << C1f.center(-unit_matrix(2)).op(0) << ", "  << C1f.center(-unit_matrix(2)).op(1)
 << "), (" << C2f.center(-unit_matrix(2)).op(0) << ", "  << C2f.center(-unit_matrix(2)).op(1) << "), ";
for (int j = -1; j<2; j++) {
 ex MS = diag_matrix(lst{-1, j});
 lst F1 =  ex_to<lst>(C1f.focus(MS)),   F2 = ex_to<lst>(C2f.focus(MS));
 asymptote << "   (" << F1.op(0) << ", "  << F1.op(1) << "), ("
     << F2.op(0) << ", "  << F2.op(1) << ")" << (j==1? "};" : "," ) << endl;
}
asymptote << " dot (z);" << endl
  << " draw(z[0]--z[1], dashed);" << endl;

asymptote << "for (int j=1; j<3; ++j) {" << endl
 << "  label(\"$c_e$\", z[j-1], N);" << endl
 << "  label(\"$f_e$\", z[j+1], E);" << endl
 << "  label(\"$f_p$\", z[j+3], E);" << endl
 << "  label(\"$f_h$\", z[j+5], E);" << endl
 << " draw(z[j+1]--z[j+5], dotted+0.5);" << endl
 << "}" << endl;
<<Draw axes>>
asymptote << "shipout(\"parab-cent\");" << endl;

@
\subsubsection{Zero-radius cycles}
\label{sec:zer-radius-cycles}

Zero-radius cycles can look different in different EPH realisations,
here is an illustration.
<<Zero-radius cycle implementations>>=
asymptote << endl << "erase();" << endl << "size(250);" << endl
 << "pair[] z;" << endl;
{
	numeric xmin(-5), xmax(15), ymin(-5), ymax(5);
	for (int i1=-1; i1<2; i1++) {
		for(int i2=-1; i2<2; i2++) {
			lst val=lst{sign==i1, sign1==i2, u==6*i1+4, v==1.7};
			Z1.subs(val).asy_draw(asymptote, xmin, xmax, ymin, ymax, lst{0.5+0.4*i1, .5-0.3*i2, 0.5+0.3*i2},"", true, 7);
			asymptote << "dot((" << ex_to<numeric>(Z1.focus(e).op(0).subs(val)).to_double()
					  << ", "<< ex_to<numeric>(Z1.focus(e).op(1).subs(val)).to_double()
					  << "), " << 0.4+0.4*i1 << "red+"
					  <<  .4-0.3*i2 << "green+"
					  << 0.6+0.3*i2 << "blue);" << endl;
		}
	}
	<<Draw axes>>
}
asymptote << "shipout(\"zero-cycles\");" << endl;


@
\subsubsection{Diameters of cycles}
\label{sec:diameters-cycles}

The notion of diameter and related distance became strange in parabolic case.
<<Parabolic diameters>>=
asymptote << endl << "erase();" << endl << "size(250);" << endl;
C10 = cycle2D(1, lst{(-4-1)/2.0, 0.5}, 4,par_matr);
C10.asy_draw(asymptote, xmin, xmax, ymin, ymax, lst{0.1, 0, 0.6});
asymptote << "pair[] z = {(" << C10.roots().op(0) << ", 0), (" << C10.roots().op(1) << ", 0)};" << endl;
cycle2D(1, lst{5/2.0, 0.5}, 8,par_matr).asy_draw(asymptote, xmin, xmax, ymin, ymax,
                  lst{0.1, 0.6, 0}, "", true, 7);
C10 =cycle2D(-1, lst{-5/2.0, 0.5}, 8-5.0*5/2.0,par_matr);
C10.asy_draw(asymptote, xmin, xmax, ymin, ymax, lst{0.1, 0.6, 0},
"dashed ", true, 7);
asymptote << "z.push((" << C10.roots().op(1) << ", 0)); z.push((" << C10.roots().op(0) << ", 0));" << endl;
<<Put labels on 22-23>>
<<Draw axes>>
asymptote << "shipout(\"parab-diam\");" << endl;

@ Here is the common part of drawing points and labels on the figures 22-23.
<<Put labels on 22-23>>=
asymptote  << "z.push((z[2].x,0)); z.push((z[3].x,0));" << endl
  << " dot(z);" << endl
  << " draw(z[2]--z[3], black+.3);" << endl
  << " draw(z[0]--z[1], black+1.2);" << endl
  << " draw(z[4]--z[5], black+1.2);" << endl
  << "  label(\"$z_1$\", z[0], NW);" << endl
  << "  label(\"$z_2$\", z[1], SE);" << endl
  << "  label(\"$z_3$\", z[2], SW);" << endl
  << "  label(\"$z_4$\", z[3], SE);" << endl;

@
\subsubsection{Extremal property of the distance}
\label{sec:extr-prop-dist}

To illustrate the variational definition of the
distance~\cite[Defn.\ref{E-de:distance}]{Kisil05b}
we draw several cycles  which passes
two given points. The cycles with the extremal value of diameter
is highlighted in bold.
<<Distance as an extremum>>=
asymptote << endl << "erase();" << endl << "size(250);" << endl;
for (int j=-2; j < 3; j++) {
	ex_to<cycle2D>(C.subject_to(lst{C.passing(lst{xmin+1, ymax-5}), C.passing(lst{xmin+3, ymax-6.5}), k == 1,
					l == xmin+2+0.5*j}).subs(sign == -1)).asy_draw(asymptote, xmin, xmax, ymin, ymax,
																   lst{0, 0.4*abs(j), 1.0-0.4*abs(j)}, (j == 0 ? "1" : ".3"));
	ex_to<cycle2D>(C.subject_to(lst{C.passing(lst{xmax-4, ymax-5}), C.passing(lst{xmax-1, ymax-2}), k == 1,
					l == xmax-2.5-0.2*(j+2)}).subs(sign == 0)).asy_draw(asymptote, xmin, xmax, ymin, ymax,
																		lst{0.2*(j+2), 0, 1.0-0.2*(j+2)}, (j == -2 ? "1" : ".3"), true, 7);
}

@ Put label on the picture.
<<Distance as an extremum>>=
asymptote << "pair[] z ={ (" << xmin+1 << ", " << ymax-5 << "),  (" << xmin+3 << ", "
										 << ymax-6.5 << "),  (" << xmax-4 << ", " << ymax-5 << "),  (" << xmax-1
										 << ", " << ymax-2 << ")};" << endl;
<<Put labels on 22-23>>
asymptote << "  label(\"$d_e$\", .5z[0]+.5z[1], NE);" << endl
										 << "  label(\"$d_p$\", .5z[4]+.5z[5], S);" << endl;
<<Draw axes>>
asymptote << "shipout(\"dist-extr\");" << endl;

@
\subsubsection{Infinitesimal cycles}
\label{sec:infinitesimal-cycles}

Here we draw a set of parabola with the same focus and the focal length
tensing to zero.
<<Infinitesimal cycles draw>>=
asymptote << endl << "erase();" << endl  << "size(250);" << endl;
for (int j=1; j < 5; j++) {
 cycle2D(lst{-2.5, 4.5}, -unit_matrix(2), 16.0*GiNaC::pow(2, -2*j)).asy_draw(asymptote, xmin, xmax, ymin, ymax,
                     lst{0, 0.2*abs(j), 1.0-0.2*abs(j)}, ".3");
 cycle2D(lst{1, 1.25}, hyp_matr, 25*GiNaC::pow(1.8, -2*j)).asy_draw(asymptote, xmin, xmax, ymin, ymax/3,
                     lst{0.2*abs(j), 1.0-0.2*abs(j), 0}, ".3", true, 5+j);
 cycle2D(1, lst{2, GiNaC::pow(3,-j)}, 2*2+2.0*GiNaC::pow(3,-j)-GiNaC::pow(3,-2*j), par_matr)
	 .asy_draw(asymptote, xmin, xmax, ymin, ymax, lst{1.0-0.17*j, 0, 0.17*j}, ".3", true, 7);
}
asymptote  << " draw((2,1)--(2," << ymax << "), blue+1);" << endl;
cycle2D(lst{1, 1.25}, hyp_matr).asy_draw(asymptote, xmin, xmax, ymin, ymax/3, lst{1, 0, 0}, "1");
asymptote  << " dot((-2.5,4.5));" << endl
  << " dot((2,1));" << endl;
<<Draw axes>>
asymptote << "shipout(\"infinites\");" << endl;

@
\subsubsection{Pictures of the Cayley transform}
\label{sec:pict-cayl-transf}

We draw now pictures of Cayley transform, which shows that the unit
cycle [[UC]] may be obtained as a reflection of the real line into the cycle [[C10f]].
<<Cayley transform pictures>>=
xmin = -numeric(4,2); xmax=numeric(4,2); ymin=-numeric(7,2); ymax=numeric(3);
cycle2D C10f, UC;
C10f  = cycle2D(1, lst{0, sign2}, sign, e);
UC=real_line.cycle_similarity(C10f, es).normalize();

@ Now we run cycles over signatures of point and cycle spaces and sign of [[sign2]].
<<Cayley transform pictures>>=
for (si=-1; si<2; si++) {
 for (si1=-1; si1<2; si1++)
  if ((si ==0 ) || (si == si1)) {
   asymptote << endl << "erase();" << endl << "size(250);" << endl;
   for (int si2=-1; si2<2; si2=si2+2) {
    lst cycle_val = lst{sign == si, sign1 == si1, sign2==si2};

@ If point space is not parabolic,  the unit cycle [[UC]] is the reflection of real line
in  [[C10f]] and we draw both of them.
<<Cayley transform pictures>>=
    if (si != 0 ) {
     ex_to<cycle2D>(UC.subs(cycle_val, subs_options::algebraic | subs_options::no_pattern))
      .asy_draw(asymptote, xmin, xmax, ymin, ymax, lst{0, 0, 0.7}, "1.5", true, 7);
     C10f.subs(cycle_val, subs_options::algebraic | subs_options::no_pattern).normalize()
      .asy_draw(asymptote, xmin, xmax, ymin, ymax, lst{0, 0.7, 0}, (si2 ==si1 ? "1" : "Dotted "), true, 7);

@ In the parabolic space unit cycle obtained from the real line by [[cayley_parab()]] procedure.
<<Cayley transform pictures>>=
    } else
     ex_to<cycle2D>(cayley_parab(real_line,sign1).subs(cycle_val, subs_options::algebraic | subs_options::no_pattern))
      .asy_draw(asymptote, xmin, xmax, ymin, ymax, lst{0, 0, 0.7}, "1.5", true, 7);
   }

@ The pictures are finished with standard stuff.
<<Cayley transform pictures>>=
   <<Put units>>
      <<Draw axes>>
   asymptote << "shipout(\"cayley-"<< eph_names[si+1] << eph_names[si1+1]<<"\");" << endl;
  }
}

@
\subsubsection{Three types of inversions}
\label{sec:three-types-invers}

We draw here pictures for three types of the inversions. First we
make a rectangular grid.
<<Three inversions>>=
xmin=-2; xmax=2; ymin=-2; ymax=2;
C2=cycle2D(lst{0,(1-abs(sign))/2},e, 1);
C3=cycle2D(0,lst{l,n},m,e);
asymptote << endl << "erase();" << endl << "size(250);" << endl;
for(double i=-4; i<=4; i+=.4) {
 C3.subs(lst{sign==-1, l==0, n==1, m==i}).asy_draw(
  asymptote, xmin, xmax, ymin, ymax, lst{0.5, .75, 0.5},"0.25pt", true, 7);
 C3.subs(lst{sign==-1, l==1, n==0, m==i}).asy_draw(
  asymptote, xmin, xmax, ymin, ymax, lst{0.5, .5, 0.75},"0.25pt", true, 7);
}
C2.subs(sign==-1).asy_draw(asymptote, xmin, xmax, ymin, ymax, lst{1,0,0},".75pt", true, 7);
<<Draw axes>>
asymptote << "shipout(\"pre-invers\");" << endl;

@ Now we define inversions of the grid lines in the unit cycle and
draw them for three different metrics.
<<Three inversions>>=
C4=C3.cycle_similarity(C2);
for(int si=-1; si<2; si++) {
	asymptote << endl << "erase();" << endl << "size(250);" << endl;
	for(double i=-4; i<=4; i+=.4) {
		C4.subs(lst{sign==si, l==0, n==1, m==i}).asy_draw(
			asymptote, xmin, xmax, ymin, ymax, lst{0.5, .75, 0.5},"0.25pt", true, 9);
		C4.subs(lst{sign==si, l==1, n==0, m==i}).asy_draw(
			asymptote, xmin, xmax, ymin, ymax, lst{0.5, .5, 0.75},"0.25pt", true, 9);
	}
	C2.subs(sign==si).asy_draw(asymptote, xmin, xmax, ymin, ymax, lst{1,0,0},".75pt", true, 7);

@ We conclude by drawing the image of the cycle at infinity [[Zinf]].
<<Three inversions>>=
	ex_to<cycle2D>(Zinf.cycle_similarity(C2)).subs(sign==si).asy_draw(
		asymptote, xmin, xmax, ymin, ymax, lst{0,0,1}, (si==-1? "3pt": ".75pt"));
	<<Draw axes>>
	asymptote << "shipout(\"inversion-" << eph_names[si+1] << "\");" << endl;
}


@
\subsubsection{Drawing inversion of the hyperbolic ball}
\label{sec:draw-invers-hyperb}

A hyperbolic ball can be inverted without self-intersection. We
produce here an illustration of this.

Firstly we define some parameters
<<Hyperbolic inversion of a ball>>=
const int frames=20, balls=10; // number of frames and balls
const double r1=.1, r2=1, tmin=-3, tmax=3, // limits of balls' filling and inversions
    step2=(r2-r1)/(balls-1); // steps between balls

@ Then we open the file and put initialisation into it.
<<Hyperbolic inversion of a ball>>=
ofstream asymptote("ball-inv-d.asy");
asymptote << setprecision(2);
const numeric scale=2.5; //size of the picture
asymptote << "scale = " << scale << ";" << endl;

@ We have one cycle which will inverted by the matrix [[T]].
<<Hyperbolic inversion of a ball>>=
	matrix T=matrix(2, 2, lst{dirac_ONE(), -t*e.subs(mu_subs), t*e.subs(mu_subs), dirac_ONE()});
	const cycle2D Hyp=cycle2D(lst{0,0},e, a).matrix_similarity(T);

@ We run a cycle for different frames, the parameter [[t]] from the
matrix [[T]] get specific values.
<<Hyperbolic inversion of a ball>>=
for (int j=0; j<=2*frames ;j++ ) {
 double tval=(j==0 && j==2*frames ? 0 :
     (j==frames ? 10000000 :
      ex_to<numeric>((j<frames ? exp(tmin+j*(tmax-tmin)/(frames-2)) :
					  -GiNaC::exp(tmin+(2*frames-j)*(tmax-tmin)/(frames-2))).evalf()).to_double()));

@ Then we run a cycle over different hyperbolas filling up the
ball. Two copies are drown for GIF and PDF images.
<<Hyperbolic inversion of a ball>>=
 for (int i=0; i <balls; i++) {
	 Hyp.subs(lst{sign==1, a==GiNaC::pow(r1+i*step2,2), t==tval}).asy_draw(asymptote, "pa",
   -scale, scale, -scale, scale, lst{0.1+0.8*i/balls, 0, 0.9-0.8*i/balls});
	 Hyp.subs(lst{sign==1, a==GiNaC::pow(r1+i*step2,2), t==tval}).asy_draw(asymptote, "pb",
   -scale, scale, -scale, scale, lst{0.1+0.8*i/balls, 0, 0.9-0.8*i/balls});
 }

@ The boundary of the ball is drown in a highlighted way.
<<Hyperbolic inversion of a ball>>=
 Hyp.subs(lst{sign==1, a==1, t==tval}).asy_draw(asymptote, "pa",
  -scale, scale, -scale, scale, lst{1,0,0},"2pt");
 Hyp.subs(lst{sign==1, a==1, t==tval}).asy_draw(asymptote, "pb",
  -scale, scale, -scale, scale, lst{1,0,0},"2pt");
 asymptote << "newpic();" << endl  << endl ;
}

@ Finally we close the file.
<<Hyperbolic inversion of a ball>>=
asymptote.close();


@
\section[The Implementation the Classes cycle and cycle2D]{The Implementation the Classes [[cycle]] and [[cycle2D]]}
\label{sec:main-file-class}

This is the main file providing implementation the Classes [[cycle]]
and [[cycle2D]]. It is not well documented yet.

@
\subsection{Cycle and cycle2D classes header files}
\label{sec:cycle-class}

\subsubsection{Cycle header file}
\label{sec:header-file}

This the header file describing the classes [[cycle]] and
[[cycle2d]]. We start from the general inclusions and definitions and
then defining those two classes.
<<cycle.h>>=
<<license>>
#include <stdexcept>
#include <ostream>
#include <sstream>

#include <ginac/ginac.h>

namespace MoebInv {
using namespace std;
using namespace GiNaC;
@ %def MoebInv

@ We may need to verify \GiNaC version, e.g. for paravector formalism
(see Rem.~\ref{re:paravector-GiNaC-version} for required \GiNaC\
version).
<<cycle.h>>=
#define GINAC_VERSION_ATLEAST( major, minor, micro) \
	(GINACLIB_MAJOR_VERSION > major \
	|| (GINACLIB_MAJOR_VERSION == major && GINACLIB_MINOR_VERSION > minor) \
	|| (GINACLIB_MAJOR_VERSION == major && GINACLIB_MINOR_VERSION == minor && GINACLIB_MICRO_VERSION >= micro))
@ %def GINAC_VERSION_ATLEAST

@ We define version number for our own library. For the change log see
the file for companion library figure~\cite{Kisil14b}.
<<cycle.h>>=
#define MOEBINV_MAJOR_VERSION 3
#define MOEBINV_MINOR_VERSION 0
@ %def MOEBINV_MAJOR_VERSION MOEBINV_MINOR_VERSION

@ The brief outline of the header file.
<<cycle.h>>=
<<Auxiliary functions headers>>
<<cycle class>>
<<cycle2D class>>
<<paravector class>>

} // namespace MoebInv

@
\subsubsection{Some auxillary functions}
\label{sec:some-auxill-funct}

 Here is the list of some auxiliary functions which are defined and
used in the \texttt{cycle.h}.

@ There are few additional functions we need.
<<Auxiliary functions headers>>=
/** Check of equality of two expression and report the string */
const string equality(const ex & E);
inline const string equality(const ex & E1, const ex & E2) { return equality(E1-E2);}
inline const string equality(const ex & E, const ex & solns1, const ex & solns2)
{ ex e = E; return equality(e.subs(solns1), e.subs(solns2));}

/** Return the string describing the case (elliptic, parabolic or hyperbolic)  */
const string eph_case(const numeric & sign);

/** Return even (real) part of a Clifford number */
ex scalar_part(const ex & e);

///** Return odd part of a Clifford number */
//inline ex clifford_part(const ex & e) { return normal(canonicalize_clifford(e - clifford_bar(e)))/numeric(2);}

DECLARE_FUNCTION_1P(jump_fnct)

@ We often need a Clifford valued matrix which represent group of
invertible matrices with real, complex or hypercomplex entries. The
first two functions below produce a Clifford valued matrix from a real
valued one. The last two functions produce a Clifford valued matrix
from a pair of real matrix in a way which preserves multiplication of
complex, dual or double numbers.
<<Auxiliary functions headers>>=
matrix sl2_clifford(const ex & M, const ex & e, bool not_inverse=true);

matrix sl2_clifford(const ex & a, const ex & b, const ex & c, const ex & d, const ex & e, bool not_inverse=true);

matrix sl2_clifford(const ex & M1, const ex & M2, const ex & e, bool not_inverse=true);

matrix sl2_clifford(const ex & a1, const ex & b1, const ex & c1, const ex & d1,
					const ex & a2, const ex & b2, const ex & c2, const ex & d2,
					const ex & e, bool not_inverse=true);



@
\subsubsection[Members and methods in class cycle]{Members and methods in class [[cycle]]}
\label{sec:class-cycle-header}

The class [[cycle]] is derived from class [[basic]] in \GiNaC\
according to the general guidelines given in the \GiNaC\ tutorial. is defined through the general s
<<cycle class>>=
/** The class holding cycles kx^2-2<l,x>+m=0 */
class cycle : public basic
{
 GINAC_DECLARE_REGISTERED_CLASS(cycle, basic)

 <<cycle class constructors>>
 <<service functions for class cycle>>
 <<accessing the data of a cycle>>
 <<specific methods of the class cycle>>
 <<Linear operation as cycle methods>>

protected:
 ex unit; // A Clifford unit to store the dimensionality and metric of the point space
 ex k;
 ex l;
 ex m;
};
 GINAC_DECLARE_UNARCHIVER(cycle);

 <<Linear operation on cycles>>

@ This is a set of the service functions which is required that a
[[cycle]] is properly archived or printed to a stream.
<<service functions for class cycle>>=
 void archive(archive_node &n) const;
 void read_archive(const archive_node &n, lst &sym_lst);
 return_type_t return_type_tinfo() const;


@  Real and imaginary part of the representing vector.
<<service functions for class cycle>>=
ex real_part() const;
ex imag_part() const;
inline ex evalf() const { return cycle(k.evalf(), l.evalf(), m.evalf(), unit);}

@ Printing of cycles.
<<service functions for class cycle>>=
protected:
 void do_print(const print_dflt & c, unsigned level) const;
// void do_print_python(const print_dflt & c, unsigned level) const;
 void do_print_dflt(const print_dflt & c, unsigned level) const;
 void do_print_latex(const print_latex & c, unsigned level) const;

@
\subsubsection[The derived class cycle2D for two dimensional cycles]{The derived class [[cycle2D]] for two dimensional cycles}
\label{sec:derived-class-two}

We derive a class [[cycle2D]] from [[cycle]] in order to add some
more methods which only make sense in two dimensions.
<<cycle2D class>>=
class cycle2D : public cycle
{
 GINAC_DECLARE_REGISTERED_CLASS(cycle2D, cycle)

 <<constructors of the class cycle2D>>
 <<methods specific for class cycle2D>>
 <<duplicated methods for class cycle2D>>
};
GINAC_DECLARE_UNARCHIVER(cycle2D);

 <<duplicated linear operation on cycle2D>>


@ The general framework developed in the [[cycle]] class have some
duplicates for two dimensions.
<<duplicated methods for class cycle2D>>=
inline cycle2D subs(const ex & e, unsigned options = 0) const {
			return ex_to<cycle2D>(inherited::subs(e, options)); }
inline cycle2D normalize(const ex & k_new = numeric(1), const ex & e = 0) const {
	return ex_to<cycle2D>(inherited::normalize(k_new, e)); }
inline cycle2D normalize_det(const ex & e = 0,
							 const ex & sign = (new tensdelta)->setflag(status_flags::dynallocated),
							 const ex & D = 1, bool fix_paravector = true) const {
	return ex_to<cycle2D>(inherited::normalize_det(e, sign, D, fix_paravector)); }
inline cycle2D normalize_norm(const ex & e = 0,
							  const ex & sign = (new tensdelta)->setflag(status_flags::dynallocated),
							  const ex & N = 1, bool fix_paravector = true) const {
	return ex_to<cycle2D>(inherited::normalize_norm(e, sign, N, fix_paravector)); }

@ We duplicate the \(\SL\) similarity methods as well.
<<duplicated methods for class cycle2D>>=
inline cycle2D sl2_similarity(const ex & a, const ex & b, const ex & c, const ex & d,
	const ex & e = 0,
	const ex & sign = (new tensdelta)->setflag(status_flags::dynallocated),
	bool not_inverse=true,
	const ex & sign_inv = (new tensdelta)->setflag(status_flags::dynallocated)) const {
		return ex_to<cycle2D>(inherited::sl2_similarity(a, b, c, d, e, sign, not_inverse, sign_inv)); }
@ %def sl2_similarity

@ To separate calls with one or two matrices we provide various templates.
<<duplicated methods for class cycle2D>>=
inline cycle2D sl2_similarity(const ex & M) const {
	return ex_to<cycle2D>(inherited::sl2_similarity(M)); }
cycle2D sl2_similarity(const ex & M, const ex & e) const;
cycle2D sl2_similarity(const ex & M, const ex & e, const ex & sign) const;
inline cycle2D sl2_similarity(const ex & M, const ex & e, const ex & sign, bool not_inverse,
	const ex & sign_inv = (new tensdelta)->setflag(status_flags::dynallocated)) const {
	return ex_to<cycle2D>(inherited::sl2_similarity(M, e, sign, not_inverse, sign_inv)); }
@ %def sl2_similarity

@ Service methods in this class.
<<duplicated methods for class cycle2D>>=
inline cycle2D normal() const { return cycle2D(k.normal(), l.normal(), m.normal(), unit.normal());}
inline cycle2D expand() const { return cycle2D(k.expand(), l.expand(), m.expand(), unit);}
inline ex evalf() const { return ex_to<cycle2D>(inherited::evalf());}
inline cycle2D subject_to(const ex & condition, const ex & vars = 0) const {
 return ex_to<cycle2D>(inherited::subject_to(condition, vars)); }

// cycle2D(const archive_node &n, lst &sym_lst);
 void archive(archive_node &n) const;
 // ex unarchive(const archive_node &n, lst &sym_lst);
 void read_archive(const archive_node &n, lst &sym_lst);

@  Real and imaginary part of the representing vector.
<<duplicated methods for class cycle2D>>=
ex real_part() const;
ex imag_part() const;

@ We also specialise for the derived class [[cycle2D]] all operations
defined in \S~\ref{sec:line-oper-cycl}
<<duplicated linear operation on cycle2D>>=
const cycle2D operator+(const cycle2D & lh, const cycle2D & rh);
const cycle2D operator-(const cycle2D & lh, const cycle2D & rh);
const cycle2D operator*(const cycle2D & lh, const ex & rh);
const cycle2D operator*(const ex & lh, const cycle2D & rh);
const cycle2D operator/(const cycle2D & lh, const ex & rh);
const ex operator*(const cycle2D & lh, const cycle2D & rh);

@
\subsubsection{Paravector class}
\label{sec:paravector-class}

@ This is the definition of a technical class which wraps indexed
objects to works as paravectors (see
Rem.~\ref{re:paravector-GiNaC-version} for required \GiNaC\
version). More precisely, for an \(n\)-tuple \(x_\mu\),
\(\mu=0,\ldots,n-1\) the vector formalism associate the element
\(x_\mu e_\mu\) (Einstein summation notation) of the Clifford algebra
\(\Cliff{n}\). In the paravector formalism an \(n\)-tuple \(x_\nu\),
\(\nu=0,\ldots,n-1\) is associated to the element
\(x_0\cdot\mathbf{1}+ x_{\nu-1} e_\nu\) of the Clifford algebra
\(\Cliff{n-1}\). Besides the smaller dimensionality the main advantage
of the paravector formalism in two dimensions is commutativity of the
Clifford algebras \(\Cliff{1,0,0}\), \(\Cliff{0,1,0}\) and
\(\Cliff{0,0,1}\) which are isomorphic to complex, dual and double
numbers respectively.

\GiNaC\ does not recognise dummy index summation in the expressions of
the form \(x_{\nu-1} e_\nu\).
The present class [[paravector]] allows to wrap for \GiNaC\ the paravector
\(x_0\cdot\mathbf{1}+ x_{\nu-1} e_\nu\) as \(x_\mu
\tilde{e}_\mu\) in the method [[paravector::eval_indexed()]]. Here is
the formal part of its definition.
<<paravector class>>=
class paravector : public basic
{
GINAC_DECLARE_REGISTERED_CLASS(paravector, basic)

public:
	paravector(const ex & b);
	void archive(archive_node &n) const;
	void read_archive(const archive_node &n, lst &sym_lst);
	return_type_t return_type_tinfo() const;
	void do_print(const print_dflt & c, unsigned level) const;
	void do_print_dflt(const print_dflt & c, unsigned level) const;
	void do_print_latex(const print_latex & c, unsigned level) const;
	size_t nops(size_t i) const {return 1;}
	ex op(size_t i) const;
	ex & let_op(size_t i);
	ex subs(const ex & e, unsigned options = 0) const;
	ex subs(const exmap & m, unsigned options = 0) const override;
@ %def paravector

@ This is the only non-formal method in the class [[paravector]], it
evaluates if the shifted indexes \(\mu\rightarrow \mu+1\) leads to any
particular evaluation.
<<paravector class>>=
	ex eval_indexed(const basic & i) const;

@ Here is the only member of the class.
<<paravector class>>=
protected:
	ex vector;
};
GINAC_DECLARE_UNARCHIVER(paravector);

@
\subsection[Implementation of the cycle class]{Implementation of the [[cycle]] class}
\label{sec:impl-cycle-class}

We start from definitions of constructors in [[cycle]] class
<<cycle.cpp>>=
<<license>>
#include <cycle.h>
namespace MoebInv {
using namespace std;
using namespace GiNaC;

#define PRINT_CYCLE  c.s << "("; \
 k.print(c, level); \
 c.s << ", "; \
 l.print(c, level); \
 c.s << ", "; \
 m.print(c, level); \
 c.s << ")";

@ Macros for implementation of new classes
<<cycle.cpp>>=
 GINAC_IMPLEMENT_REGISTERED_CLASS_OPT(cycle, basic,
           print_func<print_dflt>(&cycle::do_print).
									  //           print_func<print_python>(&cycle::do_print_python).
           print_func<print_latex>(&cycle::do_print_latex))

 GINAC_IMPLEMENT_REGISTERED_CLASS(cycle2D, cycle)
//,    print_func<print_dflt>(&cycle2D::do_print)

GINAC_IMPLEMENT_REGISTERED_CLASS_OPT(paravector, basic,
										 print_func<print_dflt>(&paravector::do_print).
										 print_func<print_latex>(&paravector::do_print_latex))

@ tinfo is an important part of class definitions
<<cycle.cpp>>=
return_type_t cycle::return_type_tinfo() const
{
	if (is_a<numeric>(get_dim()))
		switch (ex_to<numeric>(get_dim()).to_int()) {
		case 2:
			return make_return_type_t<cycle2D>();
		default:
		return make_return_type_t<cycle>();
		}
	else
		return make_return_type_t<cycle>();
}

cycle::cycle() : unit(), k(), l(), m()
{
}

@
\subsubsection{Main constructor of cycle from all parameters given}
\label{sec:main-constr-cycle}

If all parameters of the cycle are given this constructor is used.
<<cycle.cpp>>=
cycle::cycle(const ex & k1, const ex & l1, const ex & m1, const ex & metr) // Main constructor
 : k(k1), m(m1)
{
	ex D, metric;

@  The first portion of the code processes various form of
presentation for [[l]].
<<cycle.cpp>>=
	  if (is_a<indexed>(l1.simplify_indexed())) {
		  l = ex_to<indexed>(l1.simplify_indexed());
		  if (ex_to<indexed>(l).get_indices().size() == 1) {
			  D = ex_to<varidx>(ex_to<indexed>(l).get_indices()[0]).get_dim();
		  } else
			  throw(std::invalid_argument("cycle::cycle(): the second parameter should be an indexed object"
										  "with one varindex"));
	  } else if (is_a<matrix>(l1) && (min(ex_to<matrix>(l1).rows(), ex_to<matrix>(l1).cols()) ==1)) {
		  D = max(ex_to<matrix>(l1).rows(), ex_to<matrix>(l1).cols());
		  l = indexed(l1, varidx((new symbol)->setflag(status_flags::dynallocated), D));
	  } else if (l1.info(info_flags::list) && (l1.nops() > 0)) {
		  D = l1.nops();
		  l = indexed(matrix(1, l1.nops(), ex_to<lst>(l1)),
					  varidx((new symbol)->setflag(status_flags::dynallocated), D));

@ If [[l1]] is zero we will try to get missing information from the matrix in
the next chunk, otherwise throw an exception.
<<cycle.cpp>>=
	} else if (not l1.simplify_indexed().is_zero()) {
		  throw(std::invalid_argument("cycle::cycle(): the second parameter should be an indexed object, "
									  "matrix or list"));
	  }

@ Now we process the metric parameter, in case [[l1]] did not provide
information on the dimensionality we try to get it here.
<<cycle.cpp>>=
	if (is_a<clifford>(metr)) {
		if (D.is_zero())
			D = ex_to<varidx>(metr.op(1)).get_dim();
		unit =metr;
	} else {
		if (D.is_zero()) {
			if (is_a<indexed>(metr))
				D = ex_to<varidx>(metr.op(1)).get_dim();
			else if (is_a<matrix>(metr))
				D = ex_to<matrix>(metr).rows();
			else {
				exvector indices = metr.get_free_indices();
				if (indices.size() == 2)
					D = ex_to<varidx>(indices[0]).get_dim();
			}
		}

@ For metric of unknown type we throw an exception.
<<cycle.cpp>>=
	if (D.is_zero())
		throw(std::invalid_argument("cycle::cycle(): the metric should be either tensor, "
									"matrix, Clifford unit or indexed by two indices. "
									"Otherwise supply the through the second parameter."));

@ Now we try to build the Clifford unit either for vector or
paravector formalism.
<<cycle.cpp>>=
	try {
		unit = clifford_unit(varidx((new symbol)->setflag(status_flags::dynallocated), D), metr);
	} catch (std::exception &p) {
		try {
			unit = clifford_unit(varidx((new symbol)->setflag(status_flags::dynallocated), D-1), metr);
		} catch (std::exception &p1) {
			throw(std::invalid_argument("cycle::cycle(): the metricis not suitable for both vector "
										"and paravector formalism"));
		}
	}
}
}

@
\subsubsection{Specific cycle constructors}
\label{sec:spec-cycle-constr}

@ Constructor for cycle with the given determinant [[r_squared]], e.g.
zero-radius cycle by default.
<<cycle.cpp>>=
cycle::cycle(const lst & l, const ex & metr, const ex & r_squared, const ex & e, const ex & sign)
{
	symbol m_temp;
	cycle C(numeric(1), l, m_temp, metr);
	(*this) = C.subject_to(lst{C.radius_sq(e, sign) == r_squared}, lst{m_temp});
}

@ This is the constructor of a cycle identical to the given one with replaced metric
in the point space.
<<cycle.cpp>>=
cycle::cycle(const cycle & C, const ex & metr)
{
	(*this) = metr.is_zero()? C : cycle(C.get_k(), C.get_l(), C.get_m(), metr);
}

@ Constructor of a cycle from a matrix representations. First we check
that matrix is in a proper form.
<<cycle.cpp>>=
cycle::cycle(const matrix & M, const ex & metr, const ex & e, const ex & sign, const ex & dim)
{
	<<Create a Clifford unit >>
	ex M1=M;
	bool is_vector=(dim==0 || dim==D);
	ex Dsp=is_vector?D:dim;

	// Expensive checks, if this conditions are not satisfied,
	// corresponding errors will be generated later by the constructor
	/*
	if (is_vector &&
		not (M.rows() == 2 && M.cols() == 2 && (M.op(0)+M.op(3)).normal().is_zero()))
		throw(std::invalid_argument("cycle::cycle(): in vector formalism the second argument should be "
		"square 2x2 matrix with M(1,1)=-M(2,2)"));

	if (not is_vector &&
		not (M.rows() == 2 && M.cols() == 2 && (M.op(0)+clifford_bar(M.op(3))).normal().is_zero()))
		throw(std::invalid_argument("cycle::cycle(): in paravector formalism the second argument should"
		" be square 2x2 matrix with M(1,1)=-bar(M)(2,2)")); */

@ It may happen, that the scalar part extracted from matrix is equal
to zero and we need to append it manually.
<<cycle.cpp>>=
if (sign.is_zero()) {
	try {
		lst l0=ex_to<lst>(clifford_to_lst(M.op(0), e1));
		<<fixing the size of the list>>

@
<<fixing the size of the list>>=
		if (l0.nops()<Dsp) {
			lst l1=lst{0};
			for (auto & x: l0)
				l1.append(x);
			l0=l1;
		}

@ There are different options for [[sign]], which should be
checked. First we verify is it zero and use the default value in this case.
<<cycle.cpp>>=
		(*this) = cycle(remove_dirac_ONE(M.op(2)), l0, (is_vector?1:-1)*remove_dirac_ONE(M.op(1)), metr);
	} catch  (std::exception &p) {
		lst l0=ex_to<lst>(clifford_to_lst(M.op(0)*clifford_inverse(M.op(2)), e1));
		<<fixing the size of the list>>
		(*this) = cycle(numeric(1), l0,
						(is_vector?1:-1)*canonicalize_clifford(M.op(1)*clifford_inverse(M.op(2))), metr);
	}
} else {
	varidx i0((new symbol)->setflag(status_flags::dynallocated), Dsp),
		i1((new symbol)->setflag(status_flags::dynallocated), Dsp, true);

	ex sign_m, conv;
	sign_m = sign.evalm();

@ If [[sign]] is not zero we process different types which can supply it.
<<cycle.cpp>>=
	if (is_a<tensor>(sign_m))
		conv = indexed(ex_to<tensor>(sign_m), i0, i1);
	else if (is_a<clifford>(sign_m)) {
		if (ex_to<varidx>(sign_m.op(1)).get_dim() == Dsp)
			conv = ex_to<clifford>(sign_m).get_metric(i0, i1);
		else
			throw(std::invalid_argument("cycle::cycle(): the sign should be a Clifford unit with "
										"the dimensionality matching to the second parameter"));
	} else if (is_a<indexed>(sign_m)) {
		exvector ind = ex_to<indexed>(sign_m).get_indices();
		if ((ind.size() == 2) && (ex_to<varidx>(ind[0]).get_dim() == Dsp) && (ex_to<varidx>(ind[1]).get_dim() == Dsp))
			conv = sign_m.subs(lst{ind[0] == i0, ind[1] == i1});
		else
			throw(std::invalid_argument("cycle::cycle(): the sign should be an indexed object "
										"with two indices and their dimensionality matching to "
										"the second parameter"));

@  The sign given as a matrix is oftenly used.
<<cycle.cpp>>=
	} else if (is_a<matrix>(sign_m)) {
		if ((ex_to<matrix>(sign_m).cols() == Dsp) && (ex_to<matrix>(sign_m).rows() == Dsp))
			conv = indexed(ex_to<matrix>(sign_m), i0, i1);
		else
			throw(std::invalid_argument("cycle::cycle(): the sign should be a square matrix with the "
										"dimensionality matching to the second parameter"));
	} else
		throw(std::invalid_argument("cycle::cycle(): the sign should be either tensor, indexed, matrix "
									"or Clifford unit"));

@ Then all blocks of the matrix are used to construct the cycle in
main constructor.
<<cycle.cpp>>=
	try {
		lst l0=ex_to<lst>(clifford_to_lst(M.op(0), e1));
		<<fixing the size of the list>>
		(*this) = cycle(remove_dirac_ONE(M.op(2)), indexed(matrix(1, ex_to<numeric>(Dsp).to_int(),
																   l0), i0.toggle_variance())*conv, (is_vector?1:-1)*remove_dirac_ONE(M.op(1)), metr);
	} catch  (std::exception &p) {
		lst l0=ex_to<lst>(clifford_to_lst(M.op(0)*clifford_inverse(M.op(2)), e1));
		<<fixing the size of the list>>
		(*this) = cycle(numeric(1), indexed(matrix(1, ex_to<numeric>(Dsp).to_int(), l0), i0.toggle_variance())*conv,
						(is_vector?1:-1)*canonicalize_clifford(M.op(1)*clifford_inverse(M.op(2))), metr);
	}
}
}

@ We need the proper Clifford unit to decompose M(0,0) element into
vector for [[l]].
<<Create a Clifford unit >>=
ex e1, D=dim;
if (e.is_zero()) {
	if (is_a<clifford>(metr)) {
		D=ex_to<varidx>(metr.op(1)).get_dim();
		e1=metr;
	} else {
		ex metr1;
		if (is_a<matrix>(metr)) {
			D = ex_to<matrix>(metr).cols();
			metr1 = metr;
		} else if (is_a<indexed>(metr)) {
			D = ex_to<varidx>(ex_to<indexed>(metr).get_indices()[0]).get_dim();
			metr1 = metr;
		} else
			throw(std::invalid_argument("cycle(): Could not determine the dimensionality of point space "
										"from the supplied metric or Clifford unit"));

		e1 = clifford_unit(varidx((new symbol)->setflag(status_flags::dynallocated), D), metr1);
	}
} else {
	if (! is_a<clifford>(e))
		throw(std::invalid_argument("cycle(): if e is supplied, it shall be a Clifford unit"));
	e1 = e;
	D = ex_to<varidx>(e.op(1)).get_dim();
 }

@
\subsubsection[Class cycle members access]{Class [[cycle]] members access}
\label{sec:class-cycle-members}

@  We append paravector formalism values to Clifford unit values.
<<cycle.cpp>>=
ex expand_paravector_metric(const ex & unit) {
	int D=ex_to<numeric>(ex_to<idx>(unit.get_free_indices()[0]).get_dim()).to_int();
	matrix M=ex_to<matrix>(unit_matrix(D+1));
	M(0,0)=numeric(-1);
	for (int i=0; i<D; ++i)
		for (int j=0; j<D; ++j)
			M(i+1,j+1)=ex_to<clifford>(unit).get_metric(i,j);
	return indexed(M, varidx((new symbol)->setflag(status_flags::dynallocated), D+1),
				   varidx((new symbol)->setflag(status_flags::dynallocated), D+1));
}

@
<<cycle.cpp>>=
ex cycle::get_metric() const {
	if (ex_to<idx>(unit.op(1)).get_dim() == get_dim())
		return ex_to<clifford>(unit).get_metric();
	else if (is_a<numeric>(get_dim())) {
		return expand_paravector_metric(unit);
	} else
		throw(std::runtime_error("cycle::get_metric(): cannot return metric for paravector formalism "
								 "with symbolic dimensions"));
}

@ Similar procedure for specific indices.
<<cycle.cpp>>=
ex cycle::get_metric(const ex &i0, const ex &i1) const {
	if (ex_to<idx>(unit.op(1)).get_dim() == get_dim())
		return ex_to<clifford>(unit).get_metric(i0, i1);

@ We avoid calculations of unnecessary elements if only one value is
requested.
<<cycle.cpp>>=
	else if (is_a<idx>(i0) && ex_to<idx>(i0).is_numeric() &&
			 is_a<idx>(i1) && ex_to<idx>(i1).is_numeric()) {
		int j0= ex_to<numeric>(ex_to<idx>(i0).get_value()).to_int(),
			j1= ex_to<numeric>(ex_to<idx>(i1).get_value()).to_int();
		if ( j0 > 0 && j1 > 0)
			return ex_to<clifford>(unit).get_metric(varidx(j0-1,get_dim()-1), varidx(j1-1,get_dim()-1));
		else if ( j0 == 0 && j1 == 0)
			return -numeric(1);
		else
			return 0;
	} else if (is_a<numeric>(get_dim())) {
		ex metr=expand_paravector_metric(unit);
		return metr.subs(lst{metr.op(1)==i0,metr.op(2)==i1});
	} else
		throw(std::runtime_error("cycle::get_metric(): cannot return metric for paravector formalism "
								 "with symbolic dimensions"));
 }

@ Class [[cycle]] has four operands.
<<cycle.cpp>>=
ex cycle::op(size_t i) const
{
 GINAC_ASSERT(i<nops());

 switch (i) {
 case 0:
  return k;
 case 1:
  return l;
 case 2:
  return m;
 case 3:
  return unit;
 default:
  throw(std::invalid_argument("cycle::op(): requested operand out of the range (4)"));
 }
}

@ Operands may be set through this method.
<<cycle.cpp>>=
ex & cycle::let_op(size_t i)
{
 GINAC_ASSERT(i<nops());

 ensure_if_modifiable();
 switch (i) {
 case 0:
  return k;
 case 1:
  return l;
 case 2:
  return m;
 case 3:
  return unit;
 default:
  throw(std::invalid_argument("cycle::let_op(): requested operand out of the range (4)"));
 }
}

@ Substitutions works as usual in \GiNaC.
<<cycle.cpp>>=
cycle cycle::subs(const ex & e, unsigned options) const
{
	exmap em;
	if (e.info(info_flags::list)) {
		lst l = ex_to<lst>(e);
		for (const auto & i : l)
			em.insert(std::make_pair(i.op(0), i.op(1)));
	} else if (is_a<relational>(e))
		em.insert(std::make_pair(e.op(0), e.op(1)));
	else
		throw(std::invalid_argument("cycle::subs(): the parameter should be a relational or a lst"));
	return cycle(k.subs(em, options),l.subs(em, options),m.subs(em, options),unit.subs(em, options));
}

@
\subsubsection[Service methods for the GiNaC infrastructure]{Service methods for the {\GiNaC} infrastructure}
\label{sec:serv-meth-ginac}

Standard parts involving archiving, comparison and printing of the [[cycle]] class
<<cycle.cpp>>=

@ Archiving routine.
<<cycle.cpp>>=
void cycle::archive(archive_node &n) const
{
	inherited::archive(n);
	n.add_ex("k-param", k);
	n.add_ex("l-param", l);
	n.add_ex("m-param", m);
	n.add_ex("unit", unit);
}

@ Un-archiving routine.
<<cycle.cpp>>=
void cycle::read_archive(const archive_node &n, lst &sym_lst)
{
	inherited::read_archive(n, sym_lst);
	n.find_ex("k-param", k, sym_lst);
	n.find_ex("l-param", l, sym_lst);
	n.find_ex("m-param", m, sym_lst);
	n.find_ex("unit", unit, sym_lst);
}
GINAC_BIND_UNARCHIVER(cycle);

//const char *cycle::get_class_name() { return "cycle"; }

@ Comparison of [[cycle]]s.
<<cycle.cpp>>=
int cycle::compare_same_type(const basic &other) const
{
       GINAC_ASSERT(is_a<cycle>(other));
	   return inherited::compare_same_type(other);
/*
	const cycle &o = static_cast<const cycle &>(other);
	if ((unit == o.unit) && (l*o.get_k() - o.get_l()*k).is_zero() && (m*o.get_k() - o.get_m()*k).is_zero())
		return 0;
	else if ((unit < o.unit)
			 || (l*o.get_k() < o.get_l()*k) || (m*o.get_k() < o.get_m()*k))
		return -1;
	else
		return 1;*/
}

@ Equality of [[cycle]]s.
<<cycle.cpp>>=
bool cycle::is_equal(const basic & other, bool projectively, bool ignore_unit) const
{
	if (not is_a<cycle>(other))
		return false;
	const cycle o = ex_to<cycle>(other);
	ex factor=0, ofactor=0;

	if (not (ignore_unit || unit.is_equal(o.unit)))
		return false;

	if (projectively) {
		// Check that coefficients are scalar multiples of other
		if (not (m*o.get_k()-o.get_m()*k).normal().is_zero())
			return false;
		// Set up coefficients for proportionality
		if (get_k().normal().is_zero()) {
			factor=get_m();
			ofactor=o.get_m();
		} else {
			factor=get_k();
			ofactor=o.get_k();
		}

	} else
		// Check the exact equality of coefficients
		if (not ((get_k()-o.get_k()).normal().is_zero() && (get_m()-o.get_m()).normal().is_zero()))
			return false;


@ Now we iterate through the coefficients of [[l]].
<<cycle.cpp>>=
	if (is_a<numeric>(get_dim())) {
		int D = ex_to<numeric>(get_dim()).to_int();
		if (! (is_a<numeric>(o.get_dim()) && D ==ex_to<numeric>(o.get_dim()).to_int()))
			return false;

		for (int i=0; i<D; i++)
			if (projectively) {
				// search the the first non-zero coefficient
				if (factor.is_zero()) {
					factor=get_l(i);
					ofactor=o.get_l(i);
				} else
					if (! (get_l(i)*ofactor-o.get_l(i)*factor).normal().is_zero())
						return false;
			} else
				if (! (get_l(i)-o.get_l(i)).normal().is_zero())
					return false;

		return true;
	} else
		return (l*ofactor-o.get_l()*factor).normal().is_zero();
}

@  We return a [[lst]] of equations, which describes the condition of
the given [[cycle]] to be given by the same point of the projective space
as [[other]].
<<cycle.cpp>>=
ex cycle::the_same_as(const basic & other) const
{
 if (! (is_a<cycle>(other) && (get_dim() == ex_to<cycle>(other).get_dim())))
	 return lst{1==0};
 ex f=1, f1=1;
 lst res;

@ If [[k]] is non-zero than we chose it as a normalizing factor.
<<cycle.cpp>>=
 if (not k.is_zero()) {
  f = k;
  f1 = ex_to<cycle>(other).get_k();
  res.append(f1*m ==f*ex_to<cycle>(other).get_m());

@ Otherwise we try [[m]] for this.
<<cycle.cpp>>=
 } else if (not m.is_zero()) {
  f = m;
  f1 = ex_to<cycle>(other).get_m();
 }

@ And then we build equations equating corresopnding [[l]]s.
<<cycle.cpp>>=
 if (ex_to<varidx>(unit.op(1)).is_numeric()) {
  int D = ex_to<numeric>(get_dim()).to_int();
  for (int i=0; i < D; ++i)
   res.append(f1*get_l(i)==f*ex_to<cycle>(other).get_l(i));
 } else
  res.append(f1*l==f*ex_to<cycle>(other).get_l());
 return res;
}


@ A [[cycle]] is zero if and only if its all components are zero
<<cycle.cpp>>=
bool cycle::is_zero() const
{
 return (k.is_zero() && l.is_zero() && m.is_zero());
}

@ Real and imaginary part of the representing vector.
<<cycle.cpp>>=
ex cycle::real_part() const
{
	return cycle(k.real_part(),indexed(l.op(0).real_part(),l.op(1)),m.real_part(),unit);
}

ex cycle::imag_part() const
{
	return cycle(k.imag_part(),indexed(l.op(0).imag_part(),l.op(1)),m.imag_part(),unit);
}

@ Printing of [[cycle]]s.
<<cycle.cpp>>=
void cycle::do_print(const print_dflt & c, unsigned level) const
{
 PRINT_CYCLE
}

/*void cycle::do_print_python(const print_dflt & c, unsigned level) const
{
 PRINT_CYCLE
 }*/

void cycle::do_print_latex(const print_latex & c, unsigned level) const
{
 PRINT_CYCLE
}

@
\subsubsection{Linear operation on cycles}
\label{sec:line-oper-cycl-1}
Here are linear operations on [[cycle]] defined as methods.
<<cycle.cpp>>=
cycle cycle::add(const cycle & rh) const
{
	if (get_dim() != rh.get_dim())
		throw(std::invalid_argument("cycle::add(): cannot add two cycles from diferent dimensions"));

	ex ln=indexed(((get_l().is_zero()?0:get_l().op(0))+(rh.get_l().is_zero()?0:rh.get_l().op(0))).evalm(),
				  varidx((new symbol)->setflag(status_flags::dynallocated), get_dim()));
	return cycle(get_k()+rh.get_k(), ln, get_m()+rh.get_m(), unit);
}
cycle cycle::sub(const cycle & rh) const
{
	if (get_dim() != rh.get_dim())
		throw(std::invalid_argument("cycle::add(): cannot subtract two cycles from diferent dimensions"));

	ex ln=indexed(((get_l().is_zero()?0:get_l().op(0))-(rh.get_l().is_zero()?0:rh.get_l().op(0))).evalm(),
				  varidx((new symbol)->setflag(status_flags::dynallocated), get_dim()));
	return cycle(get_k()-rh.get_k(), ln, get_m()-rh.get_m(), unit);
}
cycle cycle::exmul(const ex & rh) const
{
	return cycle(get_k()*rh, indexed(get_l().is_zero() ? 0 : (get_l().op(0)*rh).evalm(),
									 varidx((new symbol)->setflag(status_flags::dynallocated), get_dim())),
				 get_m()*rh, unit);
}
cycle cycle::div(const ex & rh) const
{
	return exmul(pow(rh, numeric(-1)));
}

@ The same linear structure is represented in operators overloading.
<<cycle.cpp>>=
const cycle operator+(const cycle & lh, const cycle & rh)
{
 return lh.add(rh);
}
const cycle operator-(const cycle & lh, const cycle & rh)
{
 return lh.sub(rh);
}
const cycle operator*(const cycle & lh, const ex & rh)
{
 return lh.exmul(rh);
}
const cycle operator*(const ex & lh, const cycle & rh)
{
 return rh.exmul(lh);
}
const cycle operator/(const cycle & lh, const ex & rh)
{
 return lh.div(rh);
}
const ex operator*(const cycle & lh, const cycle & rh)
{
 return lh.mul(rh);
}

@ We make a specialisation of these operation for [[cycle2D]] class as well.
<<cycle.cpp>>=
const cycle2D operator+(const cycle2D & lh, const cycle2D & rh)
{
 return ex_to<cycle2D>(lh.add(rh));
}
const cycle2D operator-(const cycle2D & lh, const cycle2D & rh)
{
 return ex_to<cycle2D>(lh.sub(rh));
}
const cycle2D operator*(const cycle2D & lh, const ex & rh)
{
 return ex_to<cycle2D>(lh.exmul(rh));
}
const cycle2D operator*(const ex & lh, const cycle2D & rh)
{
 return ex_to<cycle2D>(rh.exmul(lh));
}
const cycle2D operator/(const cycle2D & lh, const ex & rh)
{
 return ex_to<cycle2D>(lh.div(rh));
}
const ex operator*(const cycle2D & lh, const cycle2D & rh)
{
 return ex_to<cycle2D>(lh.mul(rh));
}

@
\subsubsection[Specific methods for cycle]{Specific methods for [[cycle]]}
\label{sec:specific-methods}

@
We oftenly need to normalise cycles to get rid of ambiguity in their
definition. This is typically by prescribing a value to [[k]].
<<cycle.cpp>>=
cycle cycle::normalize(const ex & k_new, const ex & e) const
{
	ex ratio = 0;
	if (k_new.is_zero()) // Make the determinant equal 1
		ratio = sqrt(radius_sq(e));
	else { // First non-zero coefficient among k, m, l_0, l_1, ... is set to k_new
		if (!k.is_zero())
			ratio = k/k_new;
		else if (!m.is_zero())
			ratio = m/k_new;
		else {
			int D = ex_to<numeric>(get_dim()).to_int();
			for (int i=0; i<D; i++)
				if (!l.subs(l.op(1) == i).is_zero()) {
					ratio = l.subs(l.op(1) == i)/k_new;
					break;
				}
		}
	}
	if (ratio.is_zero()) // No normalisation is possible
		return (*this);

	return cycle((k/ratio).normal(), indexed((l.op(0)/ratio).evalm().normal(), l.op(1)), (m/ratio).normal(), unit);
}

@ The normalisation to determinant \(\pm 1\). We try to avoid
imaginary numbers, thus if [[-d/D]] is known to be nonnegative, then
we use it for square root.
<<cycle.cpp>>=
cycle cycle::normalize_det(const ex & e, const ex & sign, const ex & D, bool fix_paravector) const
{
	ex d = det(e, sign, 0, fix_paravector);
	if (d.is_zero())
		return *this;

	ex ratio=sqrt(((-d/D).info(info_flags::nonnegative)? -1: 1)*d/D);
	return cycle((k/ratio).normal(), indexed((l.op(0)/ratio).evalm().normal(), l.op(1)), (m/ratio).normal(), unit);
}


@ This methods returns a centre of the [[cycle]] depending from the
provided metric.
<<cycle.cpp>>=
ex cycle::center(const ex & metr, bool return_matrix) const
{
	if (is_a<numeric>(get_dim())) {
		ex e1, M, D = get_dim();
		if (metr.is_zero())
			e1 = unit;
		else {
			if (is_a<clifford>(metr))
				e1=metr;

@ otherwise we delegate to [[clifford_unit]] constructor to find the metric.
<<cycle.cpp>>=
			else
				try {
					e1 = clifford_unit(varidx(0, D), metr);
				} catch (exception &p) {
					throw(std::invalid_argument("cycle::center(): supplied metric"
												" is not suitable for Clifford unit"));
				}
		}

@ Now we adjust for paravector formalism.
<<cycle.cpp>>=
		if (D==ex_to<idx>(e1.op(1)).get_dim())
			M=ex_to<clifford>(e1).get_metric();
		else
			M=expand_paravector_metric(e1);
		exvector f_ind=M.get_free_indices();

@ Finally, the centre is constructed for the cycle and given metric by
the formula~\cite[Defn.~\ref{E-de:center-first}]{Kisil05a}:
\begin{displaymath}
  \left(-e_0^2\frac{l_0}{k}, -e_1^2\frac{l_1}{k}, \ldots, -e_{D-1}^2\frac{l_{D-1}}{k}\right)
\end{displaymath}
<<cycle.cpp>>=
		lst c;
		for(int i=0; i<D; i++)
			if (k.is_zero())
				c.append(get_l(i));
			else
				//c.append(jump_fnct(-ex_to<clifford>(e1).get_metric(varidx(i, D), varidx(i, D)))*get_l(i)/k);
				c.append(-M.subs(lst{f_ind[0]==i, f_ind[1]==i})*get_l(i)/k);
		return (return_matrix? (ex)matrix(ex_to<numeric>(D).to_int(), 1, c) : (ex)c);
	} else {
		return l/k;
	}
}

@
\subsubsection{Build cycle with given properties}
\label{sec:build-cycle-with}

We oftenly need [[cycle]]s with prescribed properties, e.g. when
converting of [[cycle]]s to normalised form or matrix. This routine
takes a system of linear equations with the [[cycle]] parameters and
try to resolve it. The list of unknown parameters is either supplied
or build automatically in a way suitable for most applications.
<<cycle.cpp>>=
cycle cycle::subject_to(const ex & condition, const ex & vars) const
{
 lst vars1;
 if (vars.info(info_flags::list) &&(vars.nops() != 0))
	 vars1 = ex_to<lst>(vars);
 else if (is_a<symbol>(vars))
	 vars1 = lst{vars};
 else if ((vars == 0) || (vars.nops() == 0)) {
	 if (is_a<symbol>(m))
   vars1.append(m);
	 if (is_a<numeric>(get_dim()))
		 for (int i = 0; i < ex_to<numeric>(get_dim()).to_double(); i++)
			 if (is_a<symbol>(get_l(i)))
				 vars1.append(get_l(i));
	 if (is_a<symbol>(k))
   vars1.append(k);
	 if (vars1.nops() == 0)
		 throw(std::invalid_argument("cycle::subject_to(): could not construct the default list of "
									 "parameters"));
 } else
	 throw(std::invalid_argument("cycle::subject_to(): second parameter should be a list of symbols"
								 " or a single symbol"));

 return subs(lsolve(condition.info(info_flags::relation_equal)? lst{condition} : condition,
								 vars1), subs_options::algebraic | subs_options::no_pattern);
}

@ An utility function, which creates an additional Clifford unit from
various types of expressions. We need to know the default Clifford
[[unit]] for this and the dimensionality [[D]] of a cycle.
<<cycle.cpp>>=
ex make_clifford_unit(const ex & e, const ex & D, const ex & unit) {
	varidx i1((new symbol)->setflag(status_flags::dynallocated), D),
		i1s((new symbol)->setflag(status_flags::dynallocated), D-1);

@ First, we process the supplied [[e]] to the standard form of the
Clifford unit. In the next two cases it is always for vector formalism.
<<cycle.cpp>>=
	if (e.is_zero()) {
		if (ex_to<idx>(unit.op(1)).get_dim()==D)
			return unit.subs(unit.op(1) == i1);
		else
			return unit.subs(unit.op(1) == i1s);

@ We need to run through every possible type of the argument to see
either vector or paravector formalism is used for it.
<<cycle.cpp>>=
	} else if (is_a<clifford>(e)) {
		if (ex_to<idx>(e.op(1)).get_dim()==D)
			return e.subs(e.op(1) == i1);
		else if (ex_to<idx>(e.op(1)).get_dim()==D-1)
			return e.subs(e.op(1) == i1s);
		else
			throw(std::invalid_argument("make_clifford_unit(): "
										"Clifford unit has unsuitable dimensionality"));

@ A similar type of obtaining dimensionality is used for indexed objects.
<<cycle.cpp>>=
	} else if (is_a<indexed>(e)) {
		if (ex_to<idx>(e.op(1)).get_dim()==D)
			return clifford_unit(i1, e);
		else if (ex_to<idx>(e.op(1)).get_dim()==D-1)
			return clifford_unit(i1s, e);
		else
			throw(std::invalid_argument("make_clifford_unit(): "
										"indexed object has unsuitable dimensionality"));

@ The final pair of supported types.
<<cycle.cpp>>=
	} else if (is_a<tensor>(e)) {
		return clifford_unit(i1, e);
	} else if (is_a<matrix>(e)) {
		int C=ex_to<matrix>(e).cols();
		if (C==D)
			return clifford_unit(i1, e);
		else if (C==D-1)
			return clifford_unit(i1s, e);
		else
			throw(std::invalid_argument("make_clifford_unit(): matrix has unsuitable size"));

@ Other typeas are not supported.
<<cycle.cpp>>=
	} else
		throw(std::invalid_argument("make_clifford_unit(): expect a clifford number, matrix, tensor or "
									"indexed as the first parameter"));
}

@
\subsubsection[Conversion of the cycle to the matrix form]{Conversion of the [[cycle]] to the matrix form}
\label{sec:conv-cycle-matr}

This method is inverse to the constructor of the [[cycle]] from its
matrix, see~\eqref{eq:matrix-from-cycle}
and~\cite[\S~\ref{E-sec:fillm-spring-cnops}]{Kisil05a}. This can use
either vector or paravector formalism.
<<cycle.cpp>>=
matrix cycle::to_matrix(const ex & e, const ex & sign, bool conjugate) const
{
	ex conv, // Indexed object for convolution with l
		D = get_dim();

	ex es = make_clifford_unit(e, D, unit); // The Clifford unit to be used in the matrix
	ex one = dirac_ONE(ex_to<clifford>(es).get_representation_label());

	varidx i0((new symbol)->setflag(status_flags::dynallocated), D),
		i1((new symbol)->setflag(status_flags::dynallocated), D);

@ Then we work out the sign, which should be used.
<<cycle.cpp>>=
	ex sign_m = sign.evalm();

	if (is_a<tensor>(sign_m))
		conv = indexed(ex_to<tensor>(sign_m), i0, i1.toggle_variance());
	else if (is_a<clifford>(sign_m)) {
		if (ex_to<varidx>(sign_m.op(1)).get_dim() == D)
			conv = ex_to<clifford>(sign_m).get_metric(i0, i1.toggle_variance());
		else
			throw(std::invalid_argument("cycle::to_matrix(): the sign should be a Clifford unit with the "
										"dimensionality matching to the second parameter"));
	} else if (is_a<indexed>(sign_m)) {
		exvector ind = ex_to<indexed>(sign_m).get_indices();
		if ((ind.size() == 2) && (ex_to<varidx>(ind[0]).get_dim() == D) && (ex_to<varidx>(ind[1]).get_dim() == D))
			conv = sign_m.subs(lst{ind[0] == i0, ind[1] == i1.toggle_variance()});
		else
			throw(std::invalid_argument("cycle::to_matrix(): the sign should be an indexed object with two "
										"indices and their dimensionality matching to the second parameter"));
	} else if (is_a<matrix>(sign_m)) {
		if ((ex_to<matrix>(sign_m).cols() == D) && (ex_to<matrix>(sign_m).rows() == D))
			conv = indexed(ex_to<matrix>(sign_m), i0, i1.toggle_variance());
		else
			throw(std::invalid_argument("cycle::to_matrix(): the sign should be a square matrix with the "
										"dimensionality matching to the second parameter"));
	} else
		throw(std::invalid_argument("cycle::to_matrix(): the sign should be either tensor, indexed, "
									"matrix or Clifford unit"));

@ When all components are ready the key element of the matrix can be
build. If we use vector formalism the base element is simple. Finally,
the matrix is constructed.
<<cycle.cpp>>=
	if ( ex_to<idx>(es.op(1)).get_dim() == D) {
		ex a00 = expand_dummy_sum(l.subs(ex_to<indexed>(l).get_indices()[0] == i0.toggle_variance())
								  * conv * es.subs(es.op(1)==i1));
		return matrix(2, 2, lst{a00, m * one, k * one, -a00});

@ For a [[paravector]] formalism a bit more care is required.
<<cycle.cpp>>=
	} else {
		ex lconv=simplify_indexed(l.subs(ex_to<indexed>(l).get_indices()[0] == i0.toggle_variance()) * conv);
		if (is_a<indexed>(lconv)) {
			ex scalar_p = expand_dummy_sum(lconv.subs(ex_to<indexed>(lconv).get_indices()[0] == 0)*one),
				vector_p = expand_dummy_sum(indexed(paravector(lconv.op(0)),
													ex_to<varidx>(es.op(1)).toggle_variance())* es);
			return matrix(2, 2, lst{scalar_p+ (conjugate?-1:1)*vector_p, -m * one, k * one, -scalar_p+(conjugate?-1:1)*vector_p});

@ This shall not happen.
<<cycle.cpp>>=
		} else
			throw(std::runtime_error("cycle::to_matrix(): after convolution with sign the indexed "
									 "objext disappered"));
	}
}

@
\subsubsection{Calculation of a value of cycle at a point}
\label{sec:calc-value-cycle}

This is used in the construction of a relational [[cycle::passing]]
describing incidence of a point to cycle.  Calculation of the value of the cycle on the
homogeneous  coordinates.
<<cycle.cpp>>=
ex cycle::val(const ex & y, const ex & x) const
{
	ex y0, D = get_dim();
	varidx i0, i1;
	if (is_a<indexed>(y)) {
		i0 = ex_to<varidx>(ex_to<indexed>(y).get_indices()[0]);
		if ((ex_to<indexed>(y).get_indices().size() == 1) && (i0.get_dim() == D)) {
			y0 = ex_to<indexed>(y);
			i1 = varidx((new symbol)->setflag(status_flags::dynallocated), D);
		} else
			throw(std::invalid_argument("cycle::val(): the second parameter should be "
										"an indexed object with one varindex"));

@ Other cases are treated similarly.
<<cycle.cpp>>=
	} else if (y.info(info_flags::list) && (y.nops() == D)) {
		i0 = varidx((new symbol)->setflag(status_flags::dynallocated), D);
		i1 = varidx((new symbol)->setflag(status_flags::dynallocated), D);
		y0 = indexed(matrix(1, y.nops(), ex_to<lst>(y)), i0);
	} else if (is_a<matrix>(y) && (min(ex_to<matrix>(y).rows(), ex_to<matrix>(y).cols()) ==1)
			   && (D == max(ex_to<matrix>(y).rows(), ex_to<matrix>(y).cols()))) {
		i0 = varidx((new symbol)->setflag(status_flags::dynallocated), D);
		i1 = varidx((new symbol)->setflag(status_flags::dynallocated), D);
		y0 = indexed(y, i0);
	} else
		throw(std::invalid_argument("cycle::val(): the second parameter should be a indexed object, "
									"matrix or list"));

		return expand_dummy_sum(-k*y0*y0.subs(i0 == i1)*get_metric(i0.toggle_variance(), i1.toggle_variance())
							- numeric(2)*x* l*y0.subs(i0 == ex_to<varidx>(ex_to<indexed>(l).get_indices()[0]).toggle_variance())
								+m*pow(x,2));
}

@
\subsubsection[Matrix methods for cycle]{Matrix methods for [[cycle]]}
\label{sec:matrix-methods-cycle}

The method [[det()]] may be defined in several ways.  An alternative
to the present definition is \emph{pseudodeterminant}~\cite[(4.9)]{Cnops02a}
\begin{webcode}[[ex cycle::det(const ex & e, const ex & sign)) const]]
[[{ex M = normalize().to_matrix(e, sign);]]
[[    return remove_dirac_ONE(M.op(0)*clifford_star(M.op(3))-M.op(1)*clifford_star(M.op(2))) ; }]]
\end{webcode}
However due to the structure of matrix this coincides with the usual
determinant of the matrix.
<<cycle.cpp>>=
ex cycle::det(const ex & e, const ex & sign, const ex & k_norm, bool fix_paravector) const
{
	ex es = make_clifford_unit(e, get_dim(), unit); // The Clifford unit to be used in the matrix
	return (fix_paravector && (ex_to<idx>(es.op(1)).get_dim() != get_dim())? -1 : 1)*
		remove_dirac_ONE((k_norm.is_zero()?*this:normalize(k_norm))
							.to_matrix(es, sign).determinant());
}
@ %def det

@ Similarly, we need to fix the value of the cycle product, so it sign
will not depend on either vector or paravector formalism is used.
<<cycle.cpp>>=
ex cycle::cycle_product(const cycle & C, const ex & e, const ex & sign) const {
	ex es = make_clifford_unit(e, get_dim(), unit); // The Clifford unit to be used in the matrix
	bool is_paravect = (ex_to<idx>(es.op(1)).get_dim() == get_dim());
	return (is_paravect? 1 : -1)*
		scalar_part(ex_to<matrix>(mul(ex_to<cycle>(C).to_matrix(es, sign,true), es, sign)).trace());
}
@ %def cycle_product

@ Multiplication of cycles in the matrix representations and their
similarity with respect to elements of \(\SL\) and other cycles.
<<cycle.cpp>>=
ex cycle::mul(const ex & C, const ex & e, const ex & sign, const ex & sign1) const
{
	if (is_a<cycle>(C)) {
		return canonicalize_clifford(to_matrix(e, sign).mul(
				ex_to<cycle>(C).to_matrix(e.is_zero()?unit:e, sign1.is_zero()?sign:sign1)));
	} else if (is_a<matrix>(C) && (ex_to<matrix>(C).rows() == 2)  && (ex_to<matrix>(C).cols() == 2)) {
		return canonicalize_clifford(to_matrix(e, sign).mul(ex_to<matrix>(C)));
	} else
		throw(std::invalid_argument("cycle::mul(): cannot multiply a cycle by anything but a cycle "
									"or 2x2 matrix"));
}

@
\subsubsection[Actions of cycle as matrix]{Actions of [[cycle]] as matrix}
\label{sec:actions-cycle-as}

[[cycle]] in the matrix form can act on other objects, or matrices can
acts on [[cycle]].


@ Any \(2\times 2\)-matrix acts on a [[cycle]] by the similarity: \(M:
C\mapsto MCM^{-1}\).
<<cycle.cpp>>=
cycle cycle::matrix_similarity(const ex & M, const ex & e, const ex & sign, bool not_inverse,
							   const ex & sign_inv) const
{
	if (not (is_a<matrix>(M) && ex_to<matrix>(M).rows()==2 && ex_to<matrix>(M).cols()==2))
		throw(std::invalid_argument("cycle::matrix_similarity(): the first parameter sgould be "
									"a 2x2 matrix"));
	return matrix_similarity(M.op(0), M.op(1), M.op(2), M.op(3), e, sign, not_inverse, sign_inv);
}

@ The same method works if the matrix is provided by its four
elements.
<<cycle.cpp>>=
cycle cycle::matrix_similarity(const ex & a, const ex & b, const ex & c, const ex & d, const ex & e,
          const ex & sign, bool not_inverse, const ex & sign_inv) const
{
	ex es = make_clifford_unit(e, get_dim(), unit); // The Clifford unit to be used in the matrix
	matrix R=ex_to<matrix>(canonicalize_clifford(matrix(2,2,not_inverse?lst{a, b, c, d}:lst{clifford_star(d), -clifford_star(b), -clifford_star(c), clifford_star(a)})
												 .mul(ex_to<matrix>(mul(matrix(2,2,not_inverse?lst{clifford_star(d), -clifford_star(b), -clifford_star(c), clifford_star(a)}:lst{a, b, c, d}), es, sign)))
												 .evalm()).normal());


@ We do some anti-symmetrisation of the matrix before the call of
[[cycle()]] constructor since matrix should posses it anyway but it
may not be apparent to \GiNaC.
<<cycle.cpp>>=
			/*			if (ex_to<idx>(es.op(1)).get_dim() == get_dim())
				return cycle(matrix(2,2,lst{(R.op(0)-R.op(3))/numeric(2),R.op(1),
								R.op(2),(-R.op(0)+R.op(3))/numeric(2)}), unit, es, sign_inv, get_dim());
			else
				return cycle(matrix(2,2,lst{(R.op(0)-clifford_bar(R.op(3)))/numeric(2),R.op(1),R.op(2),
								(-clifford_bar(R.op(0))+R.op(3))/numeric(2)}), unit, es, sign_inv, get_dim());
			*/
			return cycle(R, unit, es, sign_inv, get_dim());
}

@  For elements of \(\SL\) we have a specific method which make the
proper ``cliffordization'' of the matrix first.
<<cycle.cpp>>=
cycle cycle::sl2_similarity(const ex & a, const ex & b, const ex & c, const ex & d, const ex & e,
							const ex & sign, bool not_inverse, const ex & sign_inv) const
{
//	ex sign_inv=is_a<matrix>(sign)?pow(sign,-1):sign;
	relational sl2_rel = (c*b == (d*a-1));

@  We check either the condition \(ad-bc=1\) can be used for
substitution later.
<<cycle.cpp>>=
	ex det=(a*d-b*c).eval();
	ex es=e.is_zero()?unit:e;
	if (is_a<numeric>(det) && (ex_to<numeric>(det).evalf() !=1))
		sl2_rel = (c*b==c*b);

@ Evaluation of the matrix corresponding to the cycle.
<<cycle.cpp>>=
	matrix R=ex_to<matrix>(canonicalize_clifford(
							   sl2_clifford(a, b, c, d, es, not_inverse)
							   .mul(ex_to<matrix>(mul(sl2_clifford(a, b, c, d, es, !not_inverse), es, sign_inv)))
							   .evalm().subs(sl2_rel, subs_options::algebraic | subs_options::no_pattern)).normal());

@ In vector formalism we make anti-symmetrisation of the matrix,
and accordingly in para-vector.
<<cycle.cpp>>=
	/*if (ex_to<idx>(es.op(1)).get_dim()==get_dim())
	  return cycle(matrix(2,2,lst{(R.op(0)-R.op(3))/numeric(2),R.op(1),R.op(2),
	  (-R.op(0)+R.op(3))/numeric(2)}), unit, e, sign, get_dim());
	  else
	  return cycle(matrix(2,2,lst{(R.op(0)-clifford_bar(R).op(3))/numeric(2),R.op(1),
	  R.op(2),(-clifford_bar(R).op(0)+R.op(3))/numeric(2)}), unit, e, sign, get_dim());*/
		return cycle(R, unit, e, sign, get_dim());
}

@
<<cycle.cpp>>=
cycle cycle::sl2_similarity(const ex & M, const ex & e, const ex & sign, bool not_inverse,
							const ex & sign_inv) const
{
	if (is_a<matrix>(M) || M.info(info_flags::list))
		return sl2_similarity(M.op(0), M.op(1), M.op(2), M.op(3), e, sign, not_inverse, sign_inv);
	else
		throw(std::invalid_argument("sl2_similarity(): expect a list or matrix as the first parameter"));
}

@ [[cycle]] acts on other [[cycle]] by the similarity: \(C: C_1 \mapsto
CC_1C\), see~\cite[~\eqref{E-eq:cycle-conjugation}]{Kisil05a}. If the
metric [[e]] for similarity is not given, then we use the metric of
\(C_1\) for this.
<<cycle.cpp>>=
cycle cycle::cycle_similarity(const cycle & C, const ex & e, const ex & sign, const ex & sign1,
							  const ex & sign_inv) const
{
//	ex sign_inv=is_a<matrix>(sign)?pow(sign,-1):sign;
	ex es = make_clifford_unit(e, get_dim(), unit); // The Clifford unit to be used in the matrix
	if (ex_to<idx>(es.op(1)).get_dim() == get_dim()) {// Vector formalism
        return cycle(ex_to<matrix>(canonicalize_clifford(C.mul(mul(C, es, sign,sign1.is_zero()?sign:sign1),
															   es, sign1.is_zero()?sign:sign1))),
					 unit, es, sign_inv, get_dim());
	} else { // Paravector formalism
		matrix M=ex_to<matrix>(to_matrix(es,sign,true)),
			M1=ex_to<matrix>(C.to_matrix(es,sign1.is_zero()?sign:sign1));
		return cycle(ex_to<matrix>(canonicalize_clifford((-M1*M*M1).evalm())),
					 unit, es, sign_inv, get_dim());
	}
}

@ Moebius map created by the cycle matrix.
<<cycle.cpp>>=
ex cycle::moebius_map(const ex & P, const ex & e, const ex & sign) const {
	return clifford_moebius_map(to_matrix(e, sign), P, (e.is_zero()?unit:e));
}
@ %def moebius_map

@
<<cycle.cpp>>=
ex cycle::is_f_orthogonal(const cycle & C, const ex & e, const ex & sign, const ex & sign1,
						  const ex & sign_inv) const
{
	ex es=make_clifford_unit(e, get_dim(), unit);
	ex signc=sign1.is_zero()?sign:sign1;

	matrix M=ex_to<matrix>(to_matrix(es,sign,true)),
		M1=ex_to<matrix>(C.to_matrix(es,sign1.is_zero()?sign:sign1)),
		P= ex_to<matrix>(canonicalize_clifford((M*M1*M).evalm()));
	/*	if (ex_to<idx>(es.op(1)).get_dim() == get_dim()) { // Vector formalism
		P = ex_to<matrix>(canonicalize_clifford((M*M1*M).evalm()));
	} else { // Paravector formalism
		//		P = ex_to<matrix>(canonicalize_clifford((clifford_bar(M)*M1*clifford_bar(M)).evalm()));
		P = ex_to<matrix>(canonicalize_clifford(((M)*M1*(M)).evalm()));
		}*/

	return (cycle(P, es, es, sign_inv, get_dim()).get_l(get_dim()-1).normal() == 0);
//	return (C.cycle_similarity(*this, e, sign, sign1).get_l(get_dim()-1).normal() == 0);
}

@
\subsection[Implementation of the cycle2D class]{Implementation of the [[cycle2D]] class}
\label{sec:impl-cycle2D-class}

The derived class [[cycle2D]] for two dimensional cycles. Here
constructors, archiving, and comparison come first.
<<cycle.cpp>>=
cycle2D::cycle2D() : inherited()
{
}

@
<<cycle.cpp>>=
cycle2D::cycle2D(const ex & k1, const ex & l1, const ex & m1, const ex & metr)
 : inherited(k1, l1, m1, metr)
{
 if (get_dim() != 2)
  throw(std::invalid_argument("cycle2D::cycle2D(): class cycle2D is defined in two dimensions"));
}

@
<<cycle.cpp>>=
cycle2D::cycle2D(const lst & l, const ex & r_squared, const ex & metr, const ex & e, const ex & sign)
 : inherited(l, r_squared, metr, e, sign)
{
 if (get_dim() != 2)
  throw(std::invalid_argument("cycle2D::cycle2D(): class cycle2D is defined in two dimensions"));
}

@
<<cycle.cpp>>=
cycle2D::cycle2D(const matrix & M, const ex & metr, const ex & e, const ex & sign)
	: inherited(M, metr, e, sign, 2)
{
 if (get_dim() != 2)
  throw(std::invalid_argument("cycle2D::cycle2D(): class cycle2D is defined in two dimensions"));
}

@
<<cycle.cpp>>=
cycle2D::cycle2D(const cycle & C, const ex & metr)
{
 (*this) = cycle2D(C.get_k(), C.get_l(), C.get_m(), (metr.is_zero()? C.get_unit(): metr));
}

@
<<cycle.cpp>>=
void cycle2D::archive(archive_node &n) const
{
	inherited::archive(n);
}

//cycle2D::cycle2D(const archive_node &n, lst &sym_lst) : inherited(n, sym_lst) {; }

void cycle2D::read_archive(const archive_node &n, lst &sym_lst)
{
	inherited::read_archive(n, sym_lst);
}
GINAC_BIND_UNARCHIVER(cycle2D);

int cycle2D::compare_same_type(const basic &other) const
{
       GINAC_ASSERT(is_a<cycle2D>(other));
	return inherited::compare_same_type(other);
}

//const char *cycle2D::get_class_name() { return "cycle2D"; }

@ Real and imaginary part of the representing vector.
<<cycle.cpp>>=
ex cycle2D::real_part() const
{
	return cycle2D(k.real_part(),lst{get_l(0).real_part(),get_l(1).real_part()},m.real_part(),unit);
}

ex cycle2D::imag_part() const
{
	return cycle2D(k.imag_part(),lst{get_l(0).imag_part(),get_l(1).imag_part()},m.imag_part(),unit);
}

@
\subsubsection[The member functions of the derived class cycle2D]{The member functions of the derived class [[cycle2D]]}
\label{sec:memb-funct-deriv}

The standard definition of the focus for a parabola is
\begin{displaymath}
  \left(\frac{l}{k}, \frac{m}{2n} - \frac{l^2}{2nk} + \frac{n}{2k}\right).
\end{displaymath}
We calculate focus of a cycle based on its determinant in the
corresponding metric.
<<cycle.cpp>>=
ex cycle2D::focus(const ex & e, bool return_matrix) const
{
	lst f=lst{//jump_fnct(-get_metric(varidx(0, 2), varidx(0, 2)))*
		get_l(0)/k,
		(-det(e, (new tensdelta)->setflag(status_flags::dynallocated), 0, true)/(numeric(2)*get_l(1)*k)).normal()};
	return (return_matrix? (ex)matrix(2, 1, f) : (ex)f);
}

@
<<cycle.cpp>>=
lst cycle2D::roots(const ex & y, bool first) const
{
	ex D = get_dim();
	lst k_sign = lst{-k*get_metric(varidx(0, D), varidx(0, D)), -k*get_metric(varidx(1, D), varidx(1, D))};
	int i0 = (first?0:1), i1 = (first?1:0);
	ex c = k_sign.op(i1)*pow(y, 2) - numeric(2)*get_l(i1)*y+m;
	if (k_sign.op(i0).is_zero())
		return (get_l(i0).is_zero() ? lst{} : lst{c/get_l(i0)/numeric(2)});
	else {
		ex disc = sqrt(pow(get_l(i0), 2) - k_sign.op(i0)*c);
		return lst{(get_l(i0)-disc)/k_sign.op(i0), (get_l(i0)+disc)/k_sign.op(i0)};
	}
}

@
<<cycle.cpp>>=
lst cycle2D::line_intersect(const ex & a, const ex & b) const
{
	ex D = get_dim();
	ex pm = -k*get_metric(varidx(1, D), varidx(1, D));
	return cycle2D(k*(numeric(1)+pm*pow(a,2)).normal(),
				   lst{(get_l(0)+get_l(1)*a-pm*a*b).normal(), 0},
				   (m-numeric(2)*get_l(1)*b+pm*pow(b,2)).normal()).roots();
 }

@
<<cycle.cpp>>=
cycle2D cycle2D::sl2_similarity(const ex & M1, const ex & M2, const ex & e,
								const ex & sign, bool not_inverse, const ex & sign_inv) const {
	if ((is_a<matrix>(M1) || M1.info(info_flags::list)) && (is_a<matrix>(M2) || M2.info(info_flags::list)))
		return sl2_similarity(M1.op(0), M1.op(1), M1.op(2), M1.op(3),
							  M2.op(0), M2.op(1), M2.op(2), M2.op(3),e, sign, not_inverse, sign_inv);
	else
		throw(std::invalid_argument("cycle2D::sl2_similarity(): expect a lsts or matrices as "
									"the first parameter"));
;
 }

@
<<cycle.cpp>>=
cycle2D cycle2D::sl2_similarity(const ex & a1, const ex & b1, const ex & c1, const ex & d1,
								const ex & a2, const ex & b2, const ex & c2, const ex & d2,
								const ex & e, const ex & sign, bool not_inverse, const ex & sign_inv) const {
	ex es=e.is_zero()?unit:e;
	matrix R=ex_to<matrix>(canonicalize_clifford(
												 sl2_clifford(a1, b1, c1, d1, a2, b2, c2, d2, es, not_inverse)
												 .mul(ex_to<matrix>(mul(sl2_clifford(a1, b1, c1, d1,
																					 a2, b2, c2, d2, es, !not_inverse), es, sign_inv)))
												 .evalm()).normal());
	return cycle(R, unit, e, sign, get_dim());
 }

@ This method try to guess either it was called for a single real matrix [[M]] and a Clifford unit [[e]], or [[e]] supplies a second matrix.
<<cycle.cpp>>=
cycle2D cycle2D::sl2_similarity(const ex & M, const ex & e) const {
	if (is_a<matrix>(e))
		return sl2_similarity(M, e, unit, (new tensdelta)->setflag(status_flags::dynallocated), true,
							  (new tensdelta)->setflag(status_flags::dynallocated));
	else
		return sl2_similarity(M, e, (new tensdelta)->setflag(status_flags::dynallocated), true,
							  (new tensdelta)->setflag(status_flags::dynallocated));
 }

@
<<cycle.cpp>>=
cycle2D cycle2D::sl2_similarity(const ex & M, const ex & e, const ex & sign) const {
	if (is_a<matrix>(e))
		return sl2_similarity(M, e, sign, (new tensdelta)->setflag(status_flags::dynallocated), true,
							  (new tensdelta)->setflag(status_flags::dynallocated));
	else
		return sl2_similarity(M, e, sign, true, (new tensdelta)->setflag(status_flags::dynallocated));
 }

@
\subsubsection[Drawing cycle2D]{Drawing [[cycle2D]]}
\label{sec:drawing-cycle2d}

Some auxilliary functions used for drawing
<<cycle.cpp>>=
inline ex max(const ex &a, const ex &b) {return ex_to<numeric>((a-b).evalf()).is_positive()?a:b;}
inline ex min(const ex &a, const ex &b) {return ex_to<numeric>((a-b).evalf()).is_positive()?b:a;}

@ The most complicated member function in the class [[cycle2D]]
<<cycle.cpp>>=
#define DRAW_ARC(X, S)   u = X; \
    v = ex_to<numeric>(Cf.roots(X, !not_swapped).op(zero_or_one).evalf()).to_double(); \
    du = dir*(-k_d*signv*v+lv);    \
    dv = dir*(k_d*signu*u-lu);        \
    if (not_swapped)            \
     ost << S <<  u << "," << v << "){" << du << "," << dv << "}"; \
    else                \
     ost << S <<  v << "," << u << "){" << (sign == 0? dv : -dv) << "," << (sign == 0? du : -du) << "}";

@ an auxillary function to find small numbers
<<cycle.cpp>>=
bool is_almost_zero(const ex & x)
{
	if (is_a<numeric>(x))
		return (abs(ex_to<numeric>(x).to_double()) < 0.0000000001);
	else
		return x.is_zero();
}

@ an auxillary function to find almost numbers
<<cycle.cpp>>=
bool is_almost_negative(const ex & x)
{
	if (is_a<numeric>(x))
		return (ex_to<numeric>(x.evalf()).to_double() < 0.0000000001);
	else
		return x.is_zero();
}

@ The main drawing routine for [[cycle2D]].
<<cycle.cpp>>=
void cycle2D::metapost_draw(ostream & ost, const ex & xmin, const ex & xmax,
							const ex & ymin, const ex & ymax,
							const lst & color, const string more_options, bool with_header,
							int points_per_arc, bool asymptote, const string picture, bool only_path,
							bool is_continuation, const string imaginary_options) const
{
 ostringstream draw_start, draw_options;
 string already_drawn =(is_continuation? "^^(" : "(" ); // Was any arc already drawn?
draw_start << "draw" << (asymptote ? "(" : " ") << picture << (picture.size()==0? "" : ",") << "(";
 ios_base::fmtflags keep_flags = ost.flags(); // Keep stream's flags to be restored on the exit
 draw_options.flags(keep_flags); // Synchronise flags between the streams
 draw_options.precision(ost.precision()); // Synchronise flags between the streams

@ Each drawing command is concluded by options containing color,
etc. They are formatted differently for \Asymptote\ and \MetaPost.
<<cycle.cpp>>=
 ost << fixed;
 draw_options << fixed;
 if (color.nops() == 3) {
  if (asymptote)
   draw_options  << ",rgb("
       << ex_to<numeric>(color.op(0)).to_double() << ","
       << ex_to<numeric>(color.op(1)).to_double() <<","
       << ex_to<numeric>(color.op(2)).to_double() << ")";
  else
   draw_options  << showpos << " withcolor "
       << ex_to<numeric>(color.op(0)).to_double() << "*red"
       << ex_to<numeric>(color.op(1)).to_double() <<"*green"
       << ex_to<numeric>(color.op(2)).to_double() << "*blue ";
 }
 if (more_options != "") {
	 if (color.nops() == 3)
		 draw_options << "+";
	 else
		 draw_options << ",";
	 draw_options << more_options;
 }
 draw_options << (asymptote ? ");" : ";") << endl;

@ A drawing command can be also preceded by a human-readable comment
describing the cycle to be drawn.
<<cycle.cpp>>=
if (with_header) {
  ost << (asymptote ? "// Asymptote" : "% Metapost") << " data in [" << xmin << ","
   << xmax << "]x[" << ymin << ","
	  << ymax << "] for ";

 ostringstream equat;
 equat << (ex)passing(lst{symbol("u"), symbol("v")});
 if (equat.str().length()< 256)
	 ost << equat.str();
 else
	 ost << " [approx.] " << ex_to<cycle2D>(evalf()).passing(lst{symbol("u"), symbol("v")});
 }

 if (k.is_zero() && l.subs(l.op(1) == 0).is_zero() && l.subs(l.op(1) == 1).is_zero() && \
m.is_zero()) {
  ost << " zero cycle, (whole plane) " << endl;
  ost.flags(keep_flags);
  return;
 }

@ There are several parameters which control the output. Their values
depend from either we draw [[cycle]] in the original coordinates or
swap the [[u]] and [[v]]
<<cycle.cpp>>=
	cycle2D Cf=ex_to<cycle2D>(evalf()).normalize();
	double  xc = ex_to<numeric>(Cf.center().op(0)).to_double(),
		yc = ex_to<numeric>(Cf.center().op(1)).to_double(); // the center of cycle
	double sign0 = ex_to<numeric>(-get_metric(varidx(0, 2), varidx(0, 2)).evalf()).to_double(),
	sign1 = ex_to<numeric>(-get_metric(varidx(1, 2), varidx(1, 2)).evalf()).to_double(),
	sign = sign0 * sign1;
	double determinant = ex_to<numeric>(Cf.radius_sq()).to_double(),
		r=ex_to<numeric>(GiNaC::sqrt(GiNaC::abs(determinant))).to_double();
	double epsilon=0.0000000001;
	bool not_swapped = (sign>0 || sign1==0 || ((sign <0) && (determinant < epsilon)));
	double signu = (not_swapped?sign0:sign1), signv = (not_swapped?sign1:sign0);
	int iu = (not_swapped?0:1), iv = (not_swapped?1:0);
	double umin =  ex_to<numeric>((not_swapped ? xmin : ymin).evalf()).to_double(),
		umax =  ex_to<numeric>((not_swapped ? xmax : ymax).evalf()).to_double(),
		vmin =  ex_to<numeric>((not_swapped ? ymin:  xmin).evalf()).to_double(),
		vmax =  ex_to<numeric>((not_swapped ? ymax : xmax).evalf()).to_double(),
		uc =  (not_swapped ? xc:  yc), vc =  (not_swapped ? yc : xc);
	lst b_roots = ex_to<lst>(Cf.roots(vmin, not_swapped).evalf()),
		t_roots = ex_to<lst>(Cf.roots(vmax, not_swapped).evalf());

@ Here is the outline of the rest of the method. It effectively splits
into several cases depending from the space metric and degeneracy of
[[cycle2D]].
<<cycle.cpp>>=
	<<Imaginary coefficients>>
	<<Draw a straight line>>
	<<Find intersection points with the boundary>>
	if (sign > 0) { // elliptic metric
		<<Draw a circle>>
			} else { // parabolic or hyperbolic  metric
		<<Draw a parabola or hyperbola>>
			}
ost << endl;
ost.flags(keep_flags);
return;
}

@ If line is detected we identify its visible portion.
<<Draw a straight line>>=
if (b_roots.nops() != 2) { // a linear object
	if (Cf.get_k().is_zero() && Cf.get_l(0).is_zero() && Cf.get_l(1).is_zero()) {
		if (with_header)
			ost << " the zero-radius cycle at infinity" << endl;
		return;
	}
	if (with_header)
		ost << " (straight line)" << endl;
	double u1, u2, v1, v2;
	if (b_roots.nops() == 1){ // a "non-horisontal" line
		u1 = std::max(std::min(ex_to<numeric>(b_roots.op(0)).to_double(), umax), umin);
		u2 = std::min(std::max(ex_to<numeric>(t_roots.op(0)).to_double(), umin), umax);
	} else { // a "horisontal" line
		u1 = umin;
		u2 = umax;
	}

@ Vertical lines case.
<<Draw a straight line>>=
if (Cf.get_l(iv).is_zero()) { // a vertical line
	if (ex_to<numeric>(b_roots.op(0)- umin).to_double() > -epsilon
		&& ex_to<numeric>(umax-b_roots.op(0)).to_double() > -epsilon ) {
		v1 =  vmin;
		v2 =  vmax;
	} else { // out of scope
		ost.flags(keep_flags);
		return;
	}

@ Look for the visible portion of generic line.
<<Draw a straight line>>=
} else {
	v1 = ex_to<numeric>(Cf.roots(u1, !not_swapped).op(0)).to_double();
	v2 = ex_to<numeric>(Cf.roots(u2, !not_swapped).op(0)).to_double();
	if ((std::max(v1, v2)-vmax > epsilon) || (std::min(v1, v2) -vmin < -epsilon )) {
		ost.flags(keep_flags);
		return; //out of scope
	}
}

@ Actual drawing of the line.
<<Draw a straight line>>=
	ost <<  (only_path ? already_drawn : draw_start.str())
		<< (not_swapped? u1: v1) << "," << (not_swapped ? v1: u1)
		<< ")--(" << (not_swapped ? u2: v2) << "," << (not_swapped ? v2: u2) << ")"
		<< (only_path ? "" : draw_options.str());
already_drawn="^^(";
if (with_header)
	ost << endl;
ost.flags(keep_flags);
return;
}

@ Make initially this intervals (left[i], right[i]) irrelevant for
drawing by default, if necessary, it will be redefined letter on.
<<Find intersection points with the boundary>>=
double left[2] = {std::max(std::min(uc, umax), umin),
				   std::max(std::min(uc, umax), umin)},
	right[2] = {std::max(std::min(uc, umax), umin),
				std::max(std::min(uc, umax), umin)};

	if (ex_to<numeric>(b_roots.op(0).evalf()).is_real()) {
		if (ex_to<numeric>((b_roots.op(0)-b_roots.op(1)).evalf()).is_positive())
			b_roots = lst{b_roots.op(1), b_roots.op(0)}; // rearrange to have minimum value first
		left[0] = std::min(std::max(ex_to<numeric>(b_roots.op(0)).to_double(), umin), umax);
		right[0] = std::max(std::min(ex_to<numeric>(b_roots.op(1)).to_double(), umax), umin);
	}
	if (ex_to<numeric>(t_roots.op(0).evalf()).is_real()) {
		if (ex_to<numeric>((t_roots.op(0)-t_roots.op(1)).evalf()).is_positive())
			t_roots = lst{t_roots.op(1), t_roots.op(0)}; // rearrange to have minimum value first
		left[1] = std::min(std::max(ex_to<numeric>(t_roots.op(0)).to_double(), umin), umax);
		right[1] = std::max(std::min(ex_to<numeric>(t_roots.op(1)).to_double(), umax), umin);
	}

@ If a [[cycle2D]] has complex coefficients it still may intersect the
real plain in a couple of points. To find them we first solve the
linear equation.
<<Imaginary coefficients>>=
	if (! (Cf.get_k().imag_part().is_zero() && Cf.get_l(0).imag_part().is_zero()
		   && Cf.get_l(1).imag_part().is_zero() && Cf.get_m().imag_part().is_zero())) {
		if (imaginary_options == "invisible")
			return;
		realsymbol x1("x1"), y1("y1");
		cycle2D CI=ex_to<cycle2D>(Cf.imag_part());
		lst sol=ex_to<lst>(lsolve(lst{CI.val(lst{x1,y1})==0}, lst{x1,y1}));

@  Then we use the linear substitution to solve the quadratic equation.
<<Imaginary coefficients>>=
		CI=ex_to<cycle2D>(Cf.normalize().real_part());
		ex eq=(CI.val(lst{x1,y1}).subs(sol)).normal();
		ex t=(eq.has(x1)?x1:y1),  s=(eq.has(x1)?y1:x1);
		double A, B, C, D;
		A=ex_to<numeric>(eq.coeff(ex_to<symbol>(t),2)).to_double();
		B=ex_to<numeric>(eq.coeff(ex_to<symbol>(t),1)).to_double();
		C=ex_to<numeric>(eq.coeff(ex_to<symbol>(t),0)).to_double();
		D=B*B-4*A*C;

@ If the quadratic equation has real roots we draw respective points.
<<Imaginary coefficients>>=
		if (abs(A)<epsilon || D>=0){
			if (with_header)
				ost << endl << "// imaginary coefficients, the intersection with the real plane is dots only";

@ Two roots are follow.
<<Imaginary coefficients>>=
			for(int i=-1; i<2; i+=2) {
				double t1;
				if (abs(A)<epsilon) {
					i=1; // No need for second pass
					if (abs(B)<epsilon)
						return; // trivial identity
					else
						t1=-C/B;
				} else
					t1= ex_to<numeric>((-B+i*sqrt((numeric)D))/2.0/A).to_double();
				exmap em;
				em.insert(std::make_pair(t, t1));
				ex s1=s.subs(sol.subs(em));
				uc=ex_to<numeric>(eq.has(x1)? t1 : s1).to_double();
				vc=ex_to<numeric>(eq.has(x1)? s1 : t1).to_double();

@ After the double check, we reset the drawing style to the hard-coded
style for imaginary objects.
<<Imaginary coefficients>>=
				if (abs(ex_to<numeric>(Cf.val(lst{uc,vc}).evalf()).to_double()) < epsilon) {
					if (asymptote)
						draw_options.str(","+imaginary_options+");");
					else
						draw_options.str(" "+imaginary_options+";");
					ost << endl;
					{<<place a dot>>}
				} else {
					std::cerr << "Calculation of dots in imaginary cycle is inaccurate" << std::endl;
				}
			}

@ If the quadratic equation does not have real roots we draw respective points.
<<Imaginary coefficients>>=
	} else
		if (with_header)
			ost << endl << "// imaginary coefficients, no intersection with the real plane" << endl;
	ost << endl;
	return;
}

@ We start from the most involved case of a circle with a positive
radius. To this end we calculate coordinates [[u[2][4]]] and
[[v[2][4]]] of endpoints for up to four arcs making the circle.  The
\(x\)-components of intersection points with vertical boundaries are
rearranged appropriately.
<<Draw a circle>>=
if (determinant > epsilon) {
 double u[2][4], v[2][4];
 if (with_header)
  ost << " /circle of radius " << r  << endl;
 if (uc+r < umin || uc-r > umax || vc+r< vmin || vc-r > vmax ||
	 pow(std::max(umax-uc,uc-umin),2.0)+pow(std::max(vmax-vc,vc-vmin),2.0)<determinant) {
	  if (with_header)
		  ost << "   // out of the window " << endl;
 } else {

@ Depending from the y-position of the centre we draw different
arcs. The first case is the centre is above the horizontal strip.
<<Draw a circle>>=
	if ( vc-vmax > epsilon) {
		u[0][2] = left[1]; u[0][3] = right[1];
		u[1][2] = left[0]; u[1][3] = right[0];
		u[0][0] = u[1][0] = uc;
		u[0][1] = u[1][1] = uc;

@ The case when the centre is in the  the horizontal strip.
<<Draw a circle>>=
	} else if (vc-vmin > epsilon) {
		u[0][0] = left[1]; u[0][1] = right[1];
		u[0][2] = right[0]; u[0][3] = left[0];

		if (uc-r-umin > epsilon)
			u[1][0] = u[1][3] = uc-r;
		else
			u[1][0] = u[1][3] = umin;

		if (umax-uc-r > epsilon)
			u[1][1] = u[1][2] = uc+r;
		else
			u[1][1] = u[1][2] = umax;

@ Finally, the centre is below the horizontal strip.
<<Draw a circle>>=
 } else {
  u[0][0] = left[1]; u[0][1] = right[1];
  u[1][0] = left[0]; u[1][1] = right[0];
  u[0][2] = u[1][2] = uc;
  u[0][3] = u[1][3] = uc;
 }

@ We calculate now the \(y\)-components of the endpoints corresponding
to \(x\)-components found before.
<<Draw a circle>>=
 lst y_roots;
 for (int j=0; j<2; j++)
  for (int i=0; i<4; i++)
   if (abs(u[j][i]-uc) < epsilon) // Touch the horizontal boundary?
    v[j][i] = (i==0 || i ==1? vc+r : vc-r);
   else if (abs(u[j][i]-uc-r)<epsilon || abs(u[j][i]-uc+r)<epsilon) // Touch the vertical boundary?
    v[j][i] = vc;
   else {
    y_roots = Cf.roots(u[j][i], false);
    if (ex_to<numeric>(y_roots.op(0)).is_real()) { // does circle intersect the boundary?
     if (i<2)
		 v[j][i] = std::min(ex_to<numeric>(std::max(y_roots.op(0), y_roots.op(1))).to_double(), vmax);
     else
		 v[j][i] = std::max(ex_to<numeric>(std::min(y_roots.op(0), y_roots.op(1))).to_double(), vmin);
    } else
     v[j][i] = vc;
   }

@ Now we drawing up to four arcs which make the visible part of the
circle. Each arc is defined through its two endpoints and tangent
vector in them.
<<Draw a circle>>=
 for (int i=0; i<4; i++) {// actual drawing of four arcs
  int s = (i==0 || i ==2? -1:1);
  if ((u[0][i] != u[1][i]) || (v[0][i] != v[1][i])) {// do not draw empty arc
   ost << "  " << (only_path ? already_drawn : draw_start.str()) << u[0][i] <<","
	   << v[0][i] << "){" << s*(v[0][i]-vc) << "," << s*(uc-u[0][i])
	   << (asymptote ? "}::{" : "}...{")
	   << s*(v[1][i]-vc) << "," << s*(uc-u[1][i]) << "}(" << u[1][i] <<"," << v[1][i] << ")"
	   << (only_path ? "" : draw_options.str());
   already_drawn="^^(";
  }
 }
 }

@ Finally, for zero-radius circles we draw a point and do not draw
anything for circles with an imaginary radius.
<<Draw a circle>>=
} else if (is_almost_zero(determinant)) {
	if (with_header)
		ost << " /circle of zero-radius" << endl;
	<<place a dot>>

@ This code places a dot at the point [[(U,V)]].
<<place a dot>>=
	double U=ex_to<numeric>(uc).to_double();
	double V=ex_to<numeric>(vc).to_double();
	if ((umin <=U) && (umax>=U) && (vmin<=V) && (vmax>=V)) {
		ost << (asymptote ? (only_path ? already_drawn : "dot(") : "draw " )
			<< picture << (picture.size()==0? "" : ",")
			<< (only_path ? "" : "(")
			<< uc << "," << vc << ")" << (only_path ? "" : draw_options.str());
	already_drawn="^^(";

@
<<place a dot>>=
	} else
		if (with_header)
			ost << "// the vertex is out of range" << endl;

@
<<Draw a circle>>=
} else
	if (with_header)
		ost << " /circle of imaginary radius--not drawing" << endl;

@ First we look if the parabola or hyperbola are degenerates into two
lines, then treat two types of cycles separately.
<<Draw a parabola or hyperbola>>=
double u, v, du, dv, k_d = ex_to<numeric>(Cf.get_k()).to_double(),
                 lu = ex_to<numeric>(Cf.get_l(iu)).to_double(),
                 lv = ex_to<numeric>(Cf.get_l(iv)).to_double();

bool change_branch = (sign != 0); // either to do a swap of branches
int zero_or_one = (sign == 0 || k_d*signv > 0 ? 0 : 1); // for parabola and positive k take first

if (sign == 0) {
 <<Treating a parabola>>
} else {
 <<Treating a hyperbola>>
}

@ For parabolas degenerated into two parallel lines we draw them by
the recursive call of this function\\
[[cycle2D::metapost_draw()]].
<<Treating a parabola>>=
if (sign0 == 0 && Cf.get_l(0).is_zero()) {
	if (with_header)
		ost << " /parabola degenerated into two horizontal lines" << endl;
	cycle2D(0, lst{0, 1}, 2*b_roots.op(0), unit).metapost_draw(ost, xmin, xmax, ymin, ymax, color, more_options,
																	   false, 0, asymptote, picture, only_path, is_continuation);
	cycle2D(0, lst{0, 1}, 2*b_roots.op(1), unit).metapost_draw(ost, xmin, xmax, ymin, ymax, color, more_options,
																	   false, 0, asymptote, picture, only_path, true);
	if (with_header)
		ost << endl;
	ost.flags(keep_flags);
	return;

@   Two vertical lines are drawn here
<<Treating a parabola>>=
} else if (sign1 == 0 && Cf.get_l(1).is_zero()) {
	if (with_header)
		ost << " /parabola degenerated into two vertical lines" << endl;
	cycle2D(0, lst{1, 0}, 2*b_roots.op(0), unit).metapost_draw(ost, xmin, xmax, ymin, ymax, color, more_options,
																	   false, 0, asymptote, picture, only_path, is_continuation);
	cycle2D(0, lst{1, 0}, 2*b_roots.op(1), unit).metapost_draw(ost, xmin, xmax, ymin, ymax, color, more_options,
																	   false, 0, asymptote, picture, only_path, true);
	if (with_header)
		ost << endl;
	ost.flags(keep_flags);
	return;
}

@ If a proper parabola is detected we rearrange intervals
appropriately in order to draw pieces properly.
<<Treating a parabola>>=
if (with_header)
	ost << " /parabola" << endl;
 if (right[0]-left[0] > epsilon && right[1]-left[1] > epsilon) {
	if (k_d*(signu*lv+signv*lu) > 0) { //rearrange intervals
		double e = left[1]; left[1] = right[0]; right[0] = left[0]; left[0] =e;
	} else {
		double e = left[1]; left[1] = right[1]; right[1] = right[0]; right[0] =e;
	}
 }

@ Parabolas can be exactly represented by a cubic B\'ezier arc if the
second and third control points correspondingly are:
\begin{eqnarray*}
  &&\left(\frac{2}{3} x_0+\frac{1}{3} x_1, \frac{1}{n}\left(\frac{1}{6} x_0^2 k + \frac{1}{3} x_0
  x_1 k- \frac{2}{3} x_0 l- \frac{1}{3} l x_1+\frac{1}{2}m \right)\right),\\
  &&\left(\frac{1}{3} x_0+\frac{2}{3} x_1, \frac{1}{n}\left(\frac{1}{3} x_0 k x_1-\frac{1}{3} x_0
  l-\frac{2}{3} l x_1+\frac{1}{6} k x_1^2+\frac{1}{2}m \right)\right).
\end{eqnarray*}
<<Treating a parabola>>=
for (int i =0; i < 2; i++) {
	if (right[i]-left[i] > epsilon) { // a proper branch of a parabola
		double cp[8];
		if (not_swapped) {
			cp[0] = left[i];
			cp[1] = ex_to<numeric>(Cf.val(lst{cp[0],0})/2.0/Cf.get_l(1)).to_double();
			cp[6] = right[i];
			cp[7] = ex_to<numeric>(Cf.val(lst{cp[6],0})/2.0/Cf.get_l(1)).to_double();
			cp[2] = 2.0/3.0*cp[0]+1.0/3.0*cp[6];
			cp[3] = ex_to<numeric>((numeric(1,6)*cp[0]*cp[0]*Cf.get_k() + 1.0/3.0*cp[0]*cp[6]*Cf.get_k()
									- 2.0/3.0*cp[0]*Cf.get_l(0)- 1.0/3.0*Cf.get_l(0)*cp[6]+Cf.get_m()/2.0)/Cf.get_l(1)).to_double();
			cp[4] = 1.0/3.0*cp[0]+2.0/3.0*cp[6];
			cp[5] = ex_to<numeric>((1.0/3.0*cp[0]*Cf.get_k()*cp[6]-1.0/3.0*cp[0]*Cf.get_l(0)
									-2.0/3.0*Cf.get_l(0)*cp[6]+numeric(1,6)*Cf.get_k()*cp[6]*cp[6]
									+Cf.get_m()/2.0)/Cf.get_l(1)).to_double();

@ The similar formulae for swapped drawing.
<<Treating a parabola>>=
  } else {
			cp[1] = left[i];
			cp[0] = ex_to<numeric>(Cf.val(lst{0,cp[1]})/2.0/Cf.get_l(0)).to_double();
			cp[7] = right[i];
			cp[6] = ex_to<numeric>(Cf.val(lst{0,cp[7]})/2.0/Cf.get_l(0)).to_double();
			cp[3] = 2.0/3.0*cp[1]+1.0/3.0*cp[7];
			cp[2] = ex_to<numeric>((numeric(1,6)*cp[1]*cp[1]*Cf.get_k() + 1.0/3.0*cp[1]*cp[7]*Cf.get_k()
									- 2.0/3.0*cp[1]*Cf.get_l(1)- 1.0/3.0*Cf.get_l(1)*cp[7]+Cf.get_m()/2.0)/Cf.get_l(0)).to_double();
			cp[5] = 1.0/3.0*cp[1]+2.0/3.0*cp[7];
			cp[4] = ex_to<numeric>((1.0/3.0*cp[1]*Cf.get_k()*cp[7]-1.0/3.0*cp[1]*Cf.get_l(1)
									-2.0/3.0*Cf.get_l(1)*cp[7]+numeric(1,6)*Cf.get_k()*cp[7]*cp[7]
									+Cf.get_m()/2.0)/Cf.get_l(0)).to_double();
  }

@ The actual drawing of the parabola arcs.
<<Treating a parabola>>=
	ost <<  (only_path ? already_drawn : draw_start.str()) << cp[0] << "," << cp[1] << ") .. controls (";
if (asymptote)
	ost <<  cp[2] << "," << cp[3] << ") and (" <<  cp[4] << "," << cp[5] << ") .. (";
else
	ost <<  "(" << cp[2] << "," << cp[3] << ")) and ((" <<  cp[4] << "," << cp[5] << ")) .. (";
ost <<  cp[6] << "," << cp[7] << ")" << (only_path ? "" : draw_options.str());
already_drawn="^^(";
	}
}

@ If a hyperbola degenerates into a light cone we draw it as two
separate lines.
<<Treating a hyperbola>>=
if (abs(determinant)<epsilon) {
	if (with_header)
		ost << " / a light cone at (" << xc << "," << yc <<")" << endl;
	cycle2D(0, lst{1, 1}, 2*(uc+vc), unit).metapost_draw(ost, xmin, xmax, ymin, ymax, color, more_options,
																 false, 0, asymptote, picture, only_path, is_continuation);
	cycle2D(0, lst{1, -1}, 2*(uc-vc), unit).metapost_draw(ost, xmin, xmax, ymin, ymax, color, more_options,
																  false, 0, asymptote, picture, only_path, true);

@ We also put a dot to single out the light cone vertex.
<<Treating a hyperbola>>=
	if (! only_path) {
		<<place a dot>>
		if (with_header)
			ost << endl;
	}
	ost.flags(keep_flags);
	return;

@ Otherwise we rearrange the interwals for hyperbola branches.
<<Treating a hyperbola>>=
} else {
	if (with_header)
		ost << " /hyperbola" << endl;
	if (vmin-vc > epsilon) {
		double e = left[1]; left[1] = right[0]; right[0] = left[0]; left[0] =e;
		change_branch = false;
		zero_or_one = (k_d*signv > 0 ? 1 : 0);
	}
	if (vc-vmax > epsilon) {
		double e = left[1]; left[1] = right[1]; right[1] = right[0]; right[0] =e;
		change_branch = false;
		zero_or_one = (k_d*signv > 0 ? 0 : 1);
	}
}

@ Two arcs of the hyperbola are drown now
<<Treating a hyperbola>>=
int points = (points_per_arc == 0? 7 : points_per_arc);
for (int i =0; i < 2; i++) {
	double dir = ex_to<numeric>(csgn(signv*(2*zero_or_one-1))).to_double(); //direction of the tangent vectors
	//double dir = ((sign == 0? lv : signv*(2*zero_or_one-1))<0?-1:1); direction of the tangent vectors (second alternative)
	if (right[i]-left[i] > epsilon ) { // a proper branch of the hyperbola

@ Points for the spline are placed equally spaced in the hyperbolic
angle parameter.
<<Treating a hyperbola>>=
		double f_left=ex_to<numeric>(asinh((left[i]-uc)/r)).to_double(),
					 f_right=ex_to<numeric>(asinh((right[i]-uc)/r)).to_double();
		DRAW_ARC(ex_to<numeric>(sinh(f_left)*r+uc).to_double(), (only_path ? already_drawn : draw_start.str()));
		for (int j=1; j<points; j++) {
			DRAW_ARC(ex_to<numeric>(sinh(f_left*(1.0-j/(points-1.0))+f_right*j/(points-1.0))*r+uc).to_double(),
					 (asymptote ? "::(" : "...(") );
		}
		ost << (only_path ? "" : draw_options.str());
		already_drawn="^^(";
	}
	if (change_branch)
		zero_or_one = 1 - zero_or_one; // make a swap for the next branch of hyperbola
 }

@
\subsubsection{Methods in [[paravector]] class}
\label{sec:meth-parav-class}

@ Constructors and archivers.
<<cycle.cpp>>=
paravector::paravector() : vector() {
#if GINAC_VERSION_ATLEAST(1,7,1)
#else
	std::cerr << "GiNaC version is prior 1.7.1, the paravector formalism will not work properly!!!" << std::endl;
#endif
}

paravector::paravector(const ex & b) {
#if GINAC_VERSION_ATLEAST(1,7,1)
#else
	std::cerr << "GiNaC version is prior 1.7.1, the paravector formalism will not work properly!!!" << std::endl;
#endif
	vector=ex_to<basic>(b);
}

void paravector::archive(archive_node &n) const {
	inherited::archive(n);
	n.add_ex("vector", vector);
}

void paravector::read_archive(const archive_node &n, lst &sym_lst) {
	inherited::read_archive(n, sym_lst);
	n.find_ex("vector", vector, sym_lst);
}
GINAC_BIND_UNARCHIVER(paravector);

@ This is the only non-trivial method in the class which motivate its existanse
<<cycle.cpp>>=
ex paravector::eval_indexed(const basic & i) const {
	GINAC_ASSERT(i.nops() == 2 && is_a<idx>(i.op(1)));

	idx mu;

@ We build an index with the shifts index.
<<cycle.cpp>>=
	if (is_a<varidx>(i.op(1))) {
		if (ex_to<varidx>(i.op(1)).is_contravariant()) {
			mu=varidx(ex_to<varidx>(i.op(1)).get_value()+1, ex_to<varidx>(i.op(1)).get_dim()+1,false);
		} else {
			mu=varidx(ex_to<varidx>(i.op(1)).get_value()+1, ex_to<varidx>(i.op(1)).get_dim()+1,true);
		}
	} else if(is_a<idx>(i.op(1)))
		mu=idx(ex_to<varidx>(i.op(1)).get_value()+1, ex_to<varidx>(i.op(1)).get_dim()+1);
	else
		throw(std::invalid_argument("paravector::eval_indexed(): second argument shall be an index"));

@ Now we build the indexed object and check if a simplification occures.
<<cycle.cpp>>=
	ex e=indexed(vector, mu);

	if (is_a<indexed>(e) && e.op(1).is_equal(mu))
		return i.hold();
	else
		return e;
}

@ Paravectors are printed in the standard way.
<<cycle.cpp>>=
void paravector::do_print(const print_dflt & c, unsigned level) const {
	c.s << vector;
}

void paravector::do_print_latex(const print_latex & c, unsigned level) const {
	c.s << vector;
}

@ Substitution method.
<<cycle.cpp>>=
ex paravector::subs(const ex & e, unsigned options) const {
	return paravector(vector.subs(e,options));
}

ex paravector::subs(const exmap & m, unsigned options) const {
	return paravector(vector.subs(m,options));
}

@ Some more service methods.
<<cycle.cpp>>=
return_type_t paravector::return_type_tinfo() const {
	return make_return_type_t<paravector>();
}

int paravector::compare_same_type(const basic &other) const {
	GINAC_ASSERT(is_a<paravector>(other));
	return inherited::compare_same_type(other);
}

@ Finally, there are service methods to access the component of the [[paravector]].
<<cycle.cpp>>=
ex paravector::op(size_t i) const {
	GINAC_ASSERT(i==0);
	return vector;
}

ex & paravector::let_op(size_t i) {
	GINAC_ASSERT(i==0);
	return vector;
}

@
\subsection{Auxiliary functions implementation}
The auxillary functions defined as well.

@
\subsubsection{Heaviside function}
\label{sec:heaviside-function}

We define Heaviside function: \(\chi(x)=1\) for \(x\geq0\) and \(\chi(x)=0\) for \(x<0\).
<<cycle.cpp>>=
//////////
// Jump function
//////////

static ex jump_fnct_evalf(const ex & arg) {
	if (is_exactly_a<numeric>(arg)) {
		if ((ex_to<numeric>(arg).is_real() && ex_to<numeric>(arg).is_positive())
			|| ex_to<numeric>(arg).is_zero())
			return numeric(1);
		else
			return numeric(-1);
	}

	return jump_fnct(arg).hold();
}

@
<<cycle.cpp>>=
static ex jump_fnct_eval(const ex & arg) {
	if (is_exactly_a<numeric>(arg)) {
		if ((ex_to<numeric>(arg).is_real() && ex_to<numeric>(arg).is_positive())
			|| ex_to<numeric>(arg).is_zero())
			return numeric(1);
		else
			return numeric(-1);
	} else if (is_exactly_a<mul>(arg) &&
			   is_exactly_a<numeric>(arg.op(arg.nops()-1))) {
		numeric oc = ex_to<numeric>(arg.op(arg.nops()-1));
		if (oc.is_real()) {
			if (oc > 0)
				// jump_fnct(42*x) -> jump_fnct(x)
				return jump_fnct(arg/oc).hold();
			else
				// jump_fnct(-42*x) -> jump_fnct(-x)
				return jump_fnct(-arg/oc).hold();
		}
	}
	return jump_fnct(arg).hold();
}

@
<<cycle.cpp>>=
static ex jump_fnct_conjugate(const ex & arg) {
	return jump_fnct(arg);
}

@
<<cycle.cpp>>=
static ex jump_fnct_power(const ex & arg, const ex & exp) {
	if (is_a<numeric>(exp) && ex_to<numeric>(exp).is_integer()) {
		if (ex_to<numeric>(exp).is_even())
			return numeric(1);
		else
			return jump_fnct(arg);
	}
	if (is_a<numeric>(exp) && ex_to<numeric>(-exp).is_positive())
		return ex_to<basic>(pow(jump_fnct(arg), -exp)).hold();
	return ex_to<basic>(pow(jump_fnct(arg), exp)).hold();
}

@
<<cycle.cpp>>=
static void jump_fnct_print_dflt_text(const ex & x, const print_context & c) {
	c.s << "H("; x.print(c); c.s << ")";
}

static void jump_fnct_print_latex(const ex & x, const print_context & c) {
	c.s << "\\chi("; x.print(c); c.s << ")";
}

@ All above methods are used to register the function now.
<<cycle.cpp>>=
REGISTER_FUNCTION(jump_fnct, eval_func(jump_fnct_eval).
      evalf_func(jump_fnct_evalf).
      latex_name("\\chi").
      //text_name("H").
      print_func<print_dflt>(jump_fnct_print_dflt_text).
      print_func<print_latex>(jump_fnct_print_latex).
      //derivative_func(2*delta).
      power_func(jump_fnct_power).
      conjugate_func(jump_fnct_conjugate));

@ This function prints if its parameter is zero in a prominent way.
<<cycle.cpp>>=
const string equality(const ex & E) {
	if (E.normal().is_zero())
		return "-equal-";
	else
		return "DIFFERENT!!!";
}

@ This function decodes metric sign into human-readable form.
<<cycle.cpp>>=
const string eph_case(const numeric & sign) {
	if (numeric(sign-(-1)).is_zero())
		return "Elliptic case (sign = -1)";
	if (numeric(sign).is_zero())
		return "Parabolic case (sign = 0)";
	if (numeric(sign-1).is_zero())
		return "Hyperbolic case (sign = 1)";
	return "Unknown case!!!!";
}

@ We are trying find a scalar part of the given expression.
<<cycle.cpp>>=
ex scalar_part(const ex & e) {
	ex given=canonicalize_clifford(e.expand()),
		out=0, term;
	if (is_a<add>(given)){
		for (size_t i=0; i<given.nops(); i++) {
			try {
				term=remove_dirac_ONE(given.op(i));
			} catch (exception &p) {
				term=0;
			}
			out+=term;
		}
		return out.normal();
	} else{
		try {
			return remove_dirac_ONE(given);
		} catch (exception &p) {
			return 0;
		}
	}
}

@ Elements of \(\SL\) are transformed into appropriate ``cliffordian''
matrix. This is really a wrapper for the next function.
<<cycle.cpp>>=
matrix sl2_clifford(const ex & M, const ex & e, bool not_inverse) {
	if (is_a<matrix>(M) || M.info(info_flags::list))
		return sl2_clifford(M.op(0), M.op(1), M.op(2), M.op(3), e, not_inverse);
	else
		throw(std::invalid_argument("sl2_clifford(): expect a list or matrix as the first parameter"));
}

@ A Clifford valued matrix from real values is constructed here.
<<cycle.cpp>>=
matrix sl2_clifford(const ex & a, const ex & b, const ex & c, const ex & d, const ex & e, bool not_inverse) {
	if (is_a<clifford>(e)) {
		ex e0,
			one = dirac_ONE(ex_to<clifford>(e).get_representation_label());
		if (ex_to<idx>(e.op(1)).get_dim()==2)
			e0 = e.subs(e.op(1) == 0);
		else
			e0 = one;
		if (not_inverse)
			return matrix(2, 2,
						  lst{a * one, b * e0,
								  c * pow(e0, 3), d * one});
		else
			return matrix(2, 2,
						  lst{d * one, -b * e0,
								  -c * pow(e0, 3), a * one});
	} else
		throw(std::invalid_argument("sl2_clifford(): expect a clifford numeber as a parameter"));
}

@  This is really a wrapper for the next function.
<<cycle.cpp>>=
matrix sl2_clifford(const ex & M1, const ex & M2, const ex & e, bool not_inverse) {
	if ((is_a<matrix>(M1) || M1.info(info_flags::list)) && (is_a<matrix>(M2) || M2.info(info_flags::list)))
		return sl2_clifford(M1.op(0), M1.op(1), M1.op(2), M1.op(3), M2.op(0), M2.op(1), M2.op(2), M2.op(3),
							e, not_inverse);
	else
		throw(std::invalid_argument("sl2_clifford(): expect a list or matrix as the first parameter"));
}

@ A Clifford valued matrix from real values is constructed here.
<<cycle.cpp>>=
matrix sl2_clifford(const ex & a1, const ex & b1, const ex & c1, const ex & d1,
					const ex & a2, const ex & b2, const ex & c2, const ex & d2,
					const ex & e, bool not_inverse) {
	if (is_a<clifford>(e)) {
		ex one = dirac_ONE(ex_to<clifford>(e).get_representation_label());
		if (ex_to<idx>(e.op(1)).get_dim()==2) {
			ex e0 = e.subs(e.op(1) == 0);
			ex e1 = e.subs(e.op(1) == 1);
			ex e01=e0*e1;
			if (not_inverse)
				return matrix(2, 2,
							  lst{a1*one+a2*e01, b1*e0+b2*e1,
									  -c1*e0+c2*e1, d1*one-d2*e01});
			else
				return matrix(2, 2,
							  lst{d1*one+d2*e01, -b1*e0-b2*e1,
									  c1*e0-c2*e1, a1*one-a2*e01});

@ Matrices for paravector formalism are obvious.
<<cycle.cpp>>=
		} else {
			ex e0 = e.subs(e.op(1) == 0);
			if (not_inverse)
				return matrix(2, 2,
							  lst{a1*one+a2*e0, b1*one+b2*e0,
									  c1*one+c2*e0, d1*one+d2*e0});
			else
				return matrix(2, 2,
							  lst{d1*one+d2*e0, -b1*one-b2*e0,
									  -c1*one-c2*e0, a1*one+a2*e0});
		}
	} else
		throw(std::invalid_argument("sl2_clifford(): expect a clifford numeber as a parameter"));
}

} // namespace MoebInv

@
\section{License}
\label{sec:license}
This programme is distributed under GNU GPLv3~\cite{GNUGPL}.
<<license>>=
// The library to operate cycles in non-Euclidean geometry
//
//  Copyright (C) 2004-2018 Vladimir V. Kisil
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//  
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//  
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.

@
\section{Index of Identifiers}
\label{sec:index-identifiers}
\small
\nowebindex

@
%\fi

\end{document}

% Local Variables:
% indent-tabs-mode:"t"
% font-lock-mode:"on"
% End:
